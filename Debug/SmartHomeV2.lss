
SmartHomeV2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006c8c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000007c  00800060  00006c8c  00006d20  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000069a  008000dc  008000dc  00006d9c  2**0
                  ALLOC
  3 .stab         00007e18  00000000  00000000  00006d9c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003d68  00000000  00000000  0000ebb4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  0001291c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  00012a5c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  00012bcc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  00014815  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  00015700  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  000164b0  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  00016610  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  0001689d  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0001706b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 f1 0c 	jmp	0x19e2	; 0x19e2 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 6b 2e 	jmp	0x5cd6	; 0x5cd6 <__vector_16>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ec e8       	ldi	r30, 0x8C	; 140
      68:	fc e6       	ldi	r31, 0x6C	; 108
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ac 3d       	cpi	r26, 0xDC	; 220
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	ac ed       	ldi	r26, 0xDC	; 220
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a6 37       	cpi	r26, 0x76	; 118
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 79 32 	call	0x64f2	; 0x64f2 <main>
      8a:	0c 94 44 36 	jmp	0x6c88	; 0x6c88 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 ee 35 	jmp	0x6bdc	; 0x6bdc <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a8 eb       	ldi	r26, 0xB8	; 184
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 0a 36 	jmp	0x6c14	; 0x6c14 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 fa 35 	jmp	0x6bf4	; 0x6bf4 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 16 36 	jmp	0x6c2c	; 0x6c2c <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 fa 35 	jmp	0x6bf4	; 0x6bf4 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 16 36 	jmp	0x6c2c	; 0x6c2c <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 ee 35 	jmp	0x6bdc	; 0x6bdc <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	88 eb       	ldi	r24, 0xB8	; 184
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 0a 36 	jmp	0x6c14	; 0x6c14 <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 fa 35 	jmp	0x6bf4	; 0x6bf4 <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 16 36 	jmp	0x6c2c	; 0x6c2c <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 fa 35 	jmp	0x6bf4	; 0x6bf4 <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 16 36 	jmp	0x6c2c	; 0x6c2c <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 fa 35 	jmp	0x6bf4	; 0x6bf4 <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 16 36 	jmp	0x6c2c	; 0x6c2c <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 fe 35 	jmp	0x6bfc	; 0x6bfc <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 1a 36 	jmp	0x6c34	; 0x6c34 <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     b46:	df 93       	push	r29
     b48:	cf 93       	push	r28
     b4a:	cd b7       	in	r28, 0x3d	; 61
     b4c:	de b7       	in	r29, 0x3e	; 62
     b4e:	27 97       	sbiw	r28, 0x07	; 7
     b50:	0f b6       	in	r0, 0x3f	; 63
     b52:	f8 94       	cli
     b54:	de bf       	out	0x3e, r29	; 62
     b56:	0f be       	out	0x3f, r0	; 63
     b58:	cd bf       	out	0x3d, r28	; 61
     b5a:	9d 83       	std	Y+5, r25	; 0x05
     b5c:	8c 83       	std	Y+4, r24	; 0x04
     b5e:	6e 83       	std	Y+6, r22	; 0x06
     b60:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     b62:	8a e1       	ldi	r24, 0x1A	; 26
     b64:	90 e0       	ldi	r25, 0x00	; 0
     b66:	0e 94 7b 08 	call	0x10f6	; 0x10f6 <pvPortMalloc>
     b6a:	9a 83       	std	Y+2, r25	; 0x02
     b6c:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     b6e:	89 81       	ldd	r24, Y+1	; 0x01
     b70:	9a 81       	ldd	r25, Y+2	; 0x02
     b72:	00 97       	sbiw	r24, 0x00	; 0
     b74:	09 f4       	brne	.+2      	; 0xb78 <xCoRoutineCreate+0x32>
     b76:	6f c0       	rjmp	.+222    	; 0xc56 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     b78:	80 91 dc 00 	lds	r24, 0x00DC
     b7c:	90 91 dd 00 	lds	r25, 0x00DD
     b80:	00 97       	sbiw	r24, 0x00	; 0
     b82:	41 f4       	brne	.+16     	; 0xb94 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     b84:	89 81       	ldd	r24, Y+1	; 0x01
     b86:	9a 81       	ldd	r25, Y+2	; 0x02
     b88:	90 93 dd 00 	sts	0x00DD, r25
     b8c:	80 93 dc 00 	sts	0x00DC, r24
			prvInitialiseCoRoutineLists();
     b90:	0e 94 0a 08 	call	0x1014	; 0x1014 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     b94:	8e 81       	ldd	r24, Y+6	; 0x06
     b96:	82 30       	cpi	r24, 0x02	; 2
     b98:	10 f0       	brcs	.+4      	; 0xb9e <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     b9a:	81 e0       	ldi	r24, 0x01	; 1
     b9c:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     b9e:	e9 81       	ldd	r30, Y+1	; 0x01
     ba0:	fa 81       	ldd	r31, Y+2	; 0x02
     ba2:	11 8e       	std	Z+25, r1	; 0x19
     ba4:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     ba6:	e9 81       	ldd	r30, Y+1	; 0x01
     ba8:	fa 81       	ldd	r31, Y+2	; 0x02
     baa:	8e 81       	ldd	r24, Y+6	; 0x06
     bac:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     bae:	e9 81       	ldd	r30, Y+1	; 0x01
     bb0:	fa 81       	ldd	r31, Y+2	; 0x02
     bb2:	8f 81       	ldd	r24, Y+7	; 0x07
     bb4:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     bb6:	e9 81       	ldd	r30, Y+1	; 0x01
     bb8:	fa 81       	ldd	r31, Y+2	; 0x02
     bba:	8c 81       	ldd	r24, Y+4	; 0x04
     bbc:	9d 81       	ldd	r25, Y+5	; 0x05
     bbe:	91 83       	std	Z+1, r25	; 0x01
     bc0:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     bc2:	89 81       	ldd	r24, Y+1	; 0x01
     bc4:	9a 81       	ldd	r25, Y+2	; 0x02
     bc6:	02 96       	adiw	r24, 0x02	; 2
     bc8:	0e 94 11 09 	call	0x1222	; 0x1222 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     bcc:	89 81       	ldd	r24, Y+1	; 0x01
     bce:	9a 81       	ldd	r25, Y+2	; 0x02
     bd0:	0c 96       	adiw	r24, 0x0c	; 12
     bd2:	0e 94 11 09 	call	0x1222	; 0x1222 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     bd6:	e9 81       	ldd	r30, Y+1	; 0x01
     bd8:	fa 81       	ldd	r31, Y+2	; 0x02
     bda:	89 81       	ldd	r24, Y+1	; 0x01
     bdc:	9a 81       	ldd	r25, Y+2	; 0x02
     bde:	91 87       	std	Z+9, r25	; 0x09
     be0:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     be2:	e9 81       	ldd	r30, Y+1	; 0x01
     be4:	fa 81       	ldd	r31, Y+2	; 0x02
     be6:	89 81       	ldd	r24, Y+1	; 0x01
     be8:	9a 81       	ldd	r25, Y+2	; 0x02
     bea:	93 8b       	std	Z+19, r25	; 0x13
     bec:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     bee:	8e 81       	ldd	r24, Y+6	; 0x06
     bf0:	28 2f       	mov	r18, r24
     bf2:	30 e0       	ldi	r19, 0x00	; 0
     bf4:	85 e0       	ldi	r24, 0x05	; 5
     bf6:	90 e0       	ldi	r25, 0x00	; 0
     bf8:	82 1b       	sub	r24, r18
     bfa:	93 0b       	sbc	r25, r19
     bfc:	e9 81       	ldd	r30, Y+1	; 0x01
     bfe:	fa 81       	ldd	r31, Y+2	; 0x02
     c00:	95 87       	std	Z+13, r25	; 0x0d
     c02:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     c04:	e9 81       	ldd	r30, Y+1	; 0x01
     c06:	fa 81       	ldd	r31, Y+2	; 0x02
     c08:	96 89       	ldd	r25, Z+22	; 0x16
     c0a:	80 91 de 00 	lds	r24, 0x00DE
     c0e:	89 17       	cp	r24, r25
     c10:	28 f4       	brcc	.+10     	; 0xc1c <xCoRoutineCreate+0xd6>
     c12:	e9 81       	ldd	r30, Y+1	; 0x01
     c14:	fa 81       	ldd	r31, Y+2	; 0x02
     c16:	86 89       	ldd	r24, Z+22	; 0x16
     c18:	80 93 de 00 	sts	0x00DE, r24
     c1c:	e9 81       	ldd	r30, Y+1	; 0x01
     c1e:	fa 81       	ldd	r31, Y+2	; 0x02
     c20:	86 89       	ldd	r24, Z+22	; 0x16
     c22:	28 2f       	mov	r18, r24
     c24:	30 e0       	ldi	r19, 0x00	; 0
     c26:	c9 01       	movw	r24, r18
     c28:	88 0f       	add	r24, r24
     c2a:	99 1f       	adc	r25, r25
     c2c:	88 0f       	add	r24, r24
     c2e:	99 1f       	adc	r25, r25
     c30:	88 0f       	add	r24, r24
     c32:	99 1f       	adc	r25, r25
     c34:	82 0f       	add	r24, r18
     c36:	93 1f       	adc	r25, r19
     c38:	ac 01       	movw	r20, r24
     c3a:	4b 51       	subi	r20, 0x1B	; 27
     c3c:	5f 4f       	sbci	r21, 0xFF	; 255
     c3e:	89 81       	ldd	r24, Y+1	; 0x01
     c40:	9a 81       	ldd	r25, Y+2	; 0x02
     c42:	9c 01       	movw	r18, r24
     c44:	2e 5f       	subi	r18, 0xFE	; 254
     c46:	3f 4f       	sbci	r19, 0xFF	; 255
     c48:	ca 01       	movw	r24, r20
     c4a:	b9 01       	movw	r22, r18
     c4c:	0e 94 21 09 	call	0x1242	; 0x1242 <vListInsertEnd>

		xReturn = pdPASS;
     c50:	81 e0       	ldi	r24, 0x01	; 1
     c52:	8b 83       	std	Y+3, r24	; 0x03
     c54:	02 c0       	rjmp	.+4      	; 0xc5a <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     c56:	8f ef       	ldi	r24, 0xFF	; 255
     c58:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
     c5a:	8b 81       	ldd	r24, Y+3	; 0x03
}
     c5c:	27 96       	adiw	r28, 0x07	; 7
     c5e:	0f b6       	in	r0, 0x3f	; 63
     c60:	f8 94       	cli
     c62:	de bf       	out	0x3e, r29	; 62
     c64:	0f be       	out	0x3f, r0	; 63
     c66:	cd bf       	out	0x3d, r28	; 61
     c68:	cf 91       	pop	r28
     c6a:	df 91       	pop	r29
     c6c:	08 95       	ret

00000c6e <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     c6e:	df 93       	push	r29
     c70:	cf 93       	push	r28
     c72:	00 d0       	rcall	.+0      	; 0xc74 <vCoRoutineAddToDelayedList+0x6>
     c74:	00 d0       	rcall	.+0      	; 0xc76 <vCoRoutineAddToDelayedList+0x8>
     c76:	00 d0       	rcall	.+0      	; 0xc78 <vCoRoutineAddToDelayedList+0xa>
     c78:	cd b7       	in	r28, 0x3d	; 61
     c7a:	de b7       	in	r29, 0x3e	; 62
     c7c:	9c 83       	std	Y+4, r25	; 0x04
     c7e:	8b 83       	std	Y+3, r24	; 0x03
     c80:	7e 83       	std	Y+6, r23	; 0x06
     c82:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     c84:	20 91 df 00 	lds	r18, 0x00DF
     c88:	30 91 e0 00 	lds	r19, 0x00E0
     c8c:	8b 81       	ldd	r24, Y+3	; 0x03
     c8e:	9c 81       	ldd	r25, Y+4	; 0x04
     c90:	82 0f       	add	r24, r18
     c92:	93 1f       	adc	r25, r19
     c94:	9a 83       	std	Y+2, r25	; 0x02
     c96:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     c98:	80 91 dc 00 	lds	r24, 0x00DC
     c9c:	90 91 dd 00 	lds	r25, 0x00DD
     ca0:	02 96       	adiw	r24, 0x02	; 2
     ca2:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     ca6:	e0 91 dc 00 	lds	r30, 0x00DC
     caa:	f0 91 dd 00 	lds	r31, 0x00DD
     cae:	89 81       	ldd	r24, Y+1	; 0x01
     cb0:	9a 81       	ldd	r25, Y+2	; 0x02
     cb2:	93 83       	std	Z+3, r25	; 0x03
     cb4:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     cb6:	20 91 df 00 	lds	r18, 0x00DF
     cba:	30 91 e0 00 	lds	r19, 0x00E0
     cbe:	89 81       	ldd	r24, Y+1	; 0x01
     cc0:	9a 81       	ldd	r25, Y+2	; 0x02
     cc2:	82 17       	cp	r24, r18
     cc4:	93 07       	cpc	r25, r19
     cc6:	70 f4       	brcc	.+28     	; 0xce4 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     cc8:	80 91 0b 01 	lds	r24, 0x010B
     ccc:	90 91 0c 01 	lds	r25, 0x010C
     cd0:	20 91 dc 00 	lds	r18, 0x00DC
     cd4:	30 91 dd 00 	lds	r19, 0x00DD
     cd8:	2e 5f       	subi	r18, 0xFE	; 254
     cda:	3f 4f       	sbci	r19, 0xFF	; 255
     cdc:	b9 01       	movw	r22, r18
     cde:	0e 94 6d 09 	call	0x12da	; 0x12da <vListInsert>
     ce2:	0d c0       	rjmp	.+26     	; 0xcfe <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     ce4:	80 91 09 01 	lds	r24, 0x0109
     ce8:	90 91 0a 01 	lds	r25, 0x010A
     cec:	20 91 dc 00 	lds	r18, 0x00DC
     cf0:	30 91 dd 00 	lds	r19, 0x00DD
     cf4:	2e 5f       	subi	r18, 0xFE	; 254
     cf6:	3f 4f       	sbci	r19, 0xFF	; 255
     cf8:	b9 01       	movw	r22, r18
     cfa:	0e 94 6d 09 	call	0x12da	; 0x12da <vListInsert>
	}

	if( pxEventList )
     cfe:	8d 81       	ldd	r24, Y+5	; 0x05
     d00:	9e 81       	ldd	r25, Y+6	; 0x06
     d02:	00 97       	sbiw	r24, 0x00	; 0
     d04:	61 f0       	breq	.+24     	; 0xd1e <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     d06:	80 91 dc 00 	lds	r24, 0x00DC
     d0a:	90 91 dd 00 	lds	r25, 0x00DD
     d0e:	9c 01       	movw	r18, r24
     d10:	24 5f       	subi	r18, 0xF4	; 244
     d12:	3f 4f       	sbci	r19, 0xFF	; 255
     d14:	8d 81       	ldd	r24, Y+5	; 0x05
     d16:	9e 81       	ldd	r25, Y+6	; 0x06
     d18:	b9 01       	movw	r22, r18
     d1a:	0e 94 6d 09 	call	0x12da	; 0x12da <vListInsert>
	}
}
     d1e:	26 96       	adiw	r28, 0x06	; 6
     d20:	0f b6       	in	r0, 0x3f	; 63
     d22:	f8 94       	cli
     d24:	de bf       	out	0x3e, r29	; 62
     d26:	0f be       	out	0x3f, r0	; 63
     d28:	cd bf       	out	0x3d, r28	; 61
     d2a:	cf 91       	pop	r28
     d2c:	df 91       	pop	r29
     d2e:	08 95       	ret

00000d30 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     d30:	df 93       	push	r29
     d32:	cf 93       	push	r28
     d34:	00 d0       	rcall	.+0      	; 0xd36 <prvCheckPendingReadyList+0x6>
     d36:	cd b7       	in	r28, 0x3d	; 61
     d38:	de b7       	in	r29, 0x3e	; 62
     d3a:	3a c0       	rjmp	.+116    	; 0xdb0 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     d3c:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     d3e:	e0 91 12 01 	lds	r30, 0x0112
     d42:	f0 91 13 01 	lds	r31, 0x0113
     d46:	86 81       	ldd	r24, Z+6	; 0x06
     d48:	97 81       	ldd	r25, Z+7	; 0x07
     d4a:	9a 83       	std	Y+2, r25	; 0x02
     d4c:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     d4e:	89 81       	ldd	r24, Y+1	; 0x01
     d50:	9a 81       	ldd	r25, Y+2	; 0x02
     d52:	0c 96       	adiw	r24, 0x0c	; 12
     d54:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>
		}
		portENABLE_INTERRUPTS();
     d58:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     d5a:	89 81       	ldd	r24, Y+1	; 0x01
     d5c:	9a 81       	ldd	r25, Y+2	; 0x02
     d5e:	02 96       	adiw	r24, 0x02	; 2
     d60:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     d64:	e9 81       	ldd	r30, Y+1	; 0x01
     d66:	fa 81       	ldd	r31, Y+2	; 0x02
     d68:	96 89       	ldd	r25, Z+22	; 0x16
     d6a:	80 91 de 00 	lds	r24, 0x00DE
     d6e:	89 17       	cp	r24, r25
     d70:	28 f4       	brcc	.+10     	; 0xd7c <prvCheckPendingReadyList+0x4c>
     d72:	e9 81       	ldd	r30, Y+1	; 0x01
     d74:	fa 81       	ldd	r31, Y+2	; 0x02
     d76:	86 89       	ldd	r24, Z+22	; 0x16
     d78:	80 93 de 00 	sts	0x00DE, r24
     d7c:	e9 81       	ldd	r30, Y+1	; 0x01
     d7e:	fa 81       	ldd	r31, Y+2	; 0x02
     d80:	86 89       	ldd	r24, Z+22	; 0x16
     d82:	28 2f       	mov	r18, r24
     d84:	30 e0       	ldi	r19, 0x00	; 0
     d86:	c9 01       	movw	r24, r18
     d88:	88 0f       	add	r24, r24
     d8a:	99 1f       	adc	r25, r25
     d8c:	88 0f       	add	r24, r24
     d8e:	99 1f       	adc	r25, r25
     d90:	88 0f       	add	r24, r24
     d92:	99 1f       	adc	r25, r25
     d94:	82 0f       	add	r24, r18
     d96:	93 1f       	adc	r25, r19
     d98:	ac 01       	movw	r20, r24
     d9a:	4b 51       	subi	r20, 0x1B	; 27
     d9c:	5f 4f       	sbci	r21, 0xFF	; 255
     d9e:	89 81       	ldd	r24, Y+1	; 0x01
     da0:	9a 81       	ldd	r25, Y+2	; 0x02
     da2:	9c 01       	movw	r18, r24
     da4:	2e 5f       	subi	r18, 0xFE	; 254
     da6:	3f 4f       	sbci	r19, 0xFF	; 255
     da8:	ca 01       	movw	r24, r20
     daa:	b9 01       	movw	r22, r18
     dac:	0e 94 21 09 	call	0x1242	; 0x1242 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     db0:	80 91 0d 01 	lds	r24, 0x010D
     db4:	88 23       	and	r24, r24
     db6:	09 f0       	breq	.+2      	; 0xdba <prvCheckPendingReadyList+0x8a>
     db8:	c1 cf       	rjmp	.-126    	; 0xd3c <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
     dba:	0f 90       	pop	r0
     dbc:	0f 90       	pop	r0
     dbe:	cf 91       	pop	r28
     dc0:	df 91       	pop	r29
     dc2:	08 95       	ret

00000dc4 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     dc4:	df 93       	push	r29
     dc6:	cf 93       	push	r28
     dc8:	00 d0       	rcall	.+0      	; 0xdca <prvCheckDelayedList+0x6>
     dca:	00 d0       	rcall	.+0      	; 0xdcc <prvCheckDelayedList+0x8>
     dcc:	cd b7       	in	r28, 0x3d	; 61
     dce:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     dd0:	0e 94 66 14 	call	0x28cc	; 0x28cc <xTaskGetTickCount>
     dd4:	20 91 e1 00 	lds	r18, 0x00E1
     dd8:	30 91 e2 00 	lds	r19, 0x00E2
     ddc:	82 1b       	sub	r24, r18
     dde:	93 0b       	sbc	r25, r19
     de0:	90 93 e4 00 	sts	0x00E4, r25
     de4:	80 93 e3 00 	sts	0x00E3, r24
     de8:	85 c0       	rjmp	.+266    	; 0xef4 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     dea:	80 91 df 00 	lds	r24, 0x00DF
     dee:	90 91 e0 00 	lds	r25, 0x00E0
     df2:	01 96       	adiw	r24, 0x01	; 1
     df4:	90 93 e0 00 	sts	0x00E0, r25
     df8:	80 93 df 00 	sts	0x00DF, r24
		xPassedTicks--;
     dfc:	80 91 e3 00 	lds	r24, 0x00E3
     e00:	90 91 e4 00 	lds	r25, 0x00E4
     e04:	01 97       	sbiw	r24, 0x01	; 1
     e06:	90 93 e4 00 	sts	0x00E4, r25
     e0a:	80 93 e3 00 	sts	0x00E3, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     e0e:	80 91 df 00 	lds	r24, 0x00DF
     e12:	90 91 e0 00 	lds	r25, 0x00E0
     e16:	00 97       	sbiw	r24, 0x00	; 0
     e18:	09 f0       	breq	.+2      	; 0xe1c <prvCheckDelayedList+0x58>
     e1a:	64 c0       	rjmp	.+200    	; 0xee4 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     e1c:	80 91 09 01 	lds	r24, 0x0109
     e20:	90 91 0a 01 	lds	r25, 0x010A
     e24:	9a 83       	std	Y+2, r25	; 0x02
     e26:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     e28:	80 91 0b 01 	lds	r24, 0x010B
     e2c:	90 91 0c 01 	lds	r25, 0x010C
     e30:	90 93 0a 01 	sts	0x010A, r25
     e34:	80 93 09 01 	sts	0x0109, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     e38:	89 81       	ldd	r24, Y+1	; 0x01
     e3a:	9a 81       	ldd	r25, Y+2	; 0x02
     e3c:	90 93 0c 01 	sts	0x010C, r25
     e40:	80 93 0b 01 	sts	0x010B, r24
     e44:	4f c0       	rjmp	.+158    	; 0xee4 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     e46:	e0 91 09 01 	lds	r30, 0x0109
     e4a:	f0 91 0a 01 	lds	r31, 0x010A
     e4e:	05 80       	ldd	r0, Z+5	; 0x05
     e50:	f6 81       	ldd	r31, Z+6	; 0x06
     e52:	e0 2d       	mov	r30, r0
     e54:	86 81       	ldd	r24, Z+6	; 0x06
     e56:	97 81       	ldd	r25, Z+7	; 0x07
     e58:	9c 83       	std	Y+4, r25	; 0x04
     e5a:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     e5c:	eb 81       	ldd	r30, Y+3	; 0x03
     e5e:	fc 81       	ldd	r31, Y+4	; 0x04
     e60:	22 81       	ldd	r18, Z+2	; 0x02
     e62:	33 81       	ldd	r19, Z+3	; 0x03
     e64:	80 91 df 00 	lds	r24, 0x00DF
     e68:	90 91 e0 00 	lds	r25, 0x00E0
     e6c:	82 17       	cp	r24, r18
     e6e:	93 07       	cpc	r25, r19
     e70:	08 f4       	brcc	.+2      	; 0xe74 <prvCheckDelayedList+0xb0>
     e72:	40 c0       	rjmp	.+128    	; 0xef4 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     e74:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     e76:	8b 81       	ldd	r24, Y+3	; 0x03
     e78:	9c 81       	ldd	r25, Y+4	; 0x04
     e7a:	02 96       	adiw	r24, 0x02	; 2
     e7c:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     e80:	eb 81       	ldd	r30, Y+3	; 0x03
     e82:	fc 81       	ldd	r31, Y+4	; 0x04
     e84:	84 89       	ldd	r24, Z+20	; 0x14
     e86:	95 89       	ldd	r25, Z+21	; 0x15
     e88:	00 97       	sbiw	r24, 0x00	; 0
     e8a:	29 f0       	breq	.+10     	; 0xe96 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     e8c:	8b 81       	ldd	r24, Y+3	; 0x03
     e8e:	9c 81       	ldd	r25, Y+4	; 0x04
     e90:	0c 96       	adiw	r24, 0x0c	; 12
     e92:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     e96:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     e98:	eb 81       	ldd	r30, Y+3	; 0x03
     e9a:	fc 81       	ldd	r31, Y+4	; 0x04
     e9c:	96 89       	ldd	r25, Z+22	; 0x16
     e9e:	80 91 de 00 	lds	r24, 0x00DE
     ea2:	89 17       	cp	r24, r25
     ea4:	28 f4       	brcc	.+10     	; 0xeb0 <prvCheckDelayedList+0xec>
     ea6:	eb 81       	ldd	r30, Y+3	; 0x03
     ea8:	fc 81       	ldd	r31, Y+4	; 0x04
     eaa:	86 89       	ldd	r24, Z+22	; 0x16
     eac:	80 93 de 00 	sts	0x00DE, r24
     eb0:	eb 81       	ldd	r30, Y+3	; 0x03
     eb2:	fc 81       	ldd	r31, Y+4	; 0x04
     eb4:	86 89       	ldd	r24, Z+22	; 0x16
     eb6:	28 2f       	mov	r18, r24
     eb8:	30 e0       	ldi	r19, 0x00	; 0
     eba:	c9 01       	movw	r24, r18
     ebc:	88 0f       	add	r24, r24
     ebe:	99 1f       	adc	r25, r25
     ec0:	88 0f       	add	r24, r24
     ec2:	99 1f       	adc	r25, r25
     ec4:	88 0f       	add	r24, r24
     ec6:	99 1f       	adc	r25, r25
     ec8:	82 0f       	add	r24, r18
     eca:	93 1f       	adc	r25, r19
     ecc:	ac 01       	movw	r20, r24
     ece:	4b 51       	subi	r20, 0x1B	; 27
     ed0:	5f 4f       	sbci	r21, 0xFF	; 255
     ed2:	8b 81       	ldd	r24, Y+3	; 0x03
     ed4:	9c 81       	ldd	r25, Y+4	; 0x04
     ed6:	9c 01       	movw	r18, r24
     ed8:	2e 5f       	subi	r18, 0xFE	; 254
     eda:	3f 4f       	sbci	r19, 0xFF	; 255
     edc:	ca 01       	movw	r24, r20
     ede:	b9 01       	movw	r22, r18
     ee0:	0e 94 21 09 	call	0x1242	; 0x1242 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     ee4:	e0 91 09 01 	lds	r30, 0x0109
     ee8:	f0 91 0a 01 	lds	r31, 0x010A
     eec:	80 81       	ld	r24, Z
     eee:	88 23       	and	r24, r24
     ef0:	09 f0       	breq	.+2      	; 0xef4 <prvCheckDelayedList+0x130>
     ef2:	a9 cf       	rjmp	.-174    	; 0xe46 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     ef4:	80 91 e3 00 	lds	r24, 0x00E3
     ef8:	90 91 e4 00 	lds	r25, 0x00E4
     efc:	00 97       	sbiw	r24, 0x00	; 0
     efe:	09 f0       	breq	.+2      	; 0xf02 <prvCheckDelayedList+0x13e>
     f00:	74 cf       	rjmp	.-280    	; 0xdea <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     f02:	80 91 df 00 	lds	r24, 0x00DF
     f06:	90 91 e0 00 	lds	r25, 0x00E0
     f0a:	90 93 e2 00 	sts	0x00E2, r25
     f0e:	80 93 e1 00 	sts	0x00E1, r24
}
     f12:	0f 90       	pop	r0
     f14:	0f 90       	pop	r0
     f16:	0f 90       	pop	r0
     f18:	0f 90       	pop	r0
     f1a:	cf 91       	pop	r28
     f1c:	df 91       	pop	r29
     f1e:	08 95       	ret

00000f20 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     f20:	df 93       	push	r29
     f22:	cf 93       	push	r28
     f24:	00 d0       	rcall	.+0      	; 0xf26 <vCoRoutineSchedule+0x6>
     f26:	cd b7       	in	r28, 0x3d	; 61
     f28:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     f2a:	0e 94 98 06 	call	0xd30	; 0xd30 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     f2e:	0e 94 e2 06 	call	0xdc4	; 0xdc4 <prvCheckDelayedList>
     f32:	0a c0       	rjmp	.+20     	; 0xf48 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     f34:	80 91 de 00 	lds	r24, 0x00DE
     f38:	88 23       	and	r24, r24
     f3a:	09 f4       	brne	.+2      	; 0xf3e <vCoRoutineSchedule+0x1e>
     f3c:	66 c0       	rjmp	.+204    	; 0x100a <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     f3e:	80 91 de 00 	lds	r24, 0x00DE
     f42:	81 50       	subi	r24, 0x01	; 1
     f44:	80 93 de 00 	sts	0x00DE, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     f48:	80 91 de 00 	lds	r24, 0x00DE
     f4c:	28 2f       	mov	r18, r24
     f4e:	30 e0       	ldi	r19, 0x00	; 0
     f50:	c9 01       	movw	r24, r18
     f52:	88 0f       	add	r24, r24
     f54:	99 1f       	adc	r25, r25
     f56:	88 0f       	add	r24, r24
     f58:	99 1f       	adc	r25, r25
     f5a:	88 0f       	add	r24, r24
     f5c:	99 1f       	adc	r25, r25
     f5e:	82 0f       	add	r24, r18
     f60:	93 1f       	adc	r25, r19
     f62:	fc 01       	movw	r30, r24
     f64:	eb 51       	subi	r30, 0x1B	; 27
     f66:	ff 4f       	sbci	r31, 0xFF	; 255
     f68:	80 81       	ld	r24, Z
     f6a:	88 23       	and	r24, r24
     f6c:	19 f3       	breq	.-58     	; 0xf34 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     f6e:	80 91 de 00 	lds	r24, 0x00DE
     f72:	28 2f       	mov	r18, r24
     f74:	30 e0       	ldi	r19, 0x00	; 0
     f76:	c9 01       	movw	r24, r18
     f78:	88 0f       	add	r24, r24
     f7a:	99 1f       	adc	r25, r25
     f7c:	88 0f       	add	r24, r24
     f7e:	99 1f       	adc	r25, r25
     f80:	88 0f       	add	r24, r24
     f82:	99 1f       	adc	r25, r25
     f84:	82 0f       	add	r24, r18
     f86:	93 1f       	adc	r25, r19
     f88:	8b 51       	subi	r24, 0x1B	; 27
     f8a:	9f 4f       	sbci	r25, 0xFF	; 255
     f8c:	9a 83       	std	Y+2, r25	; 0x02
     f8e:	89 83       	std	Y+1, r24	; 0x01
     f90:	e9 81       	ldd	r30, Y+1	; 0x01
     f92:	fa 81       	ldd	r31, Y+2	; 0x02
     f94:	01 80       	ldd	r0, Z+1	; 0x01
     f96:	f2 81       	ldd	r31, Z+2	; 0x02
     f98:	e0 2d       	mov	r30, r0
     f9a:	82 81       	ldd	r24, Z+2	; 0x02
     f9c:	93 81       	ldd	r25, Z+3	; 0x03
     f9e:	e9 81       	ldd	r30, Y+1	; 0x01
     fa0:	fa 81       	ldd	r31, Y+2	; 0x02
     fa2:	92 83       	std	Z+2, r25	; 0x02
     fa4:	81 83       	std	Z+1, r24	; 0x01
     fa6:	e9 81       	ldd	r30, Y+1	; 0x01
     fa8:	fa 81       	ldd	r31, Y+2	; 0x02
     faa:	21 81       	ldd	r18, Z+1	; 0x01
     fac:	32 81       	ldd	r19, Z+2	; 0x02
     fae:	89 81       	ldd	r24, Y+1	; 0x01
     fb0:	9a 81       	ldd	r25, Y+2	; 0x02
     fb2:	03 96       	adiw	r24, 0x03	; 3
     fb4:	28 17       	cp	r18, r24
     fb6:	39 07       	cpc	r19, r25
     fb8:	59 f4       	brne	.+22     	; 0xfd0 <vCoRoutineSchedule+0xb0>
     fba:	e9 81       	ldd	r30, Y+1	; 0x01
     fbc:	fa 81       	ldd	r31, Y+2	; 0x02
     fbe:	01 80       	ldd	r0, Z+1	; 0x01
     fc0:	f2 81       	ldd	r31, Z+2	; 0x02
     fc2:	e0 2d       	mov	r30, r0
     fc4:	82 81       	ldd	r24, Z+2	; 0x02
     fc6:	93 81       	ldd	r25, Z+3	; 0x03
     fc8:	e9 81       	ldd	r30, Y+1	; 0x01
     fca:	fa 81       	ldd	r31, Y+2	; 0x02
     fcc:	92 83       	std	Z+2, r25	; 0x02
     fce:	81 83       	std	Z+1, r24	; 0x01
     fd0:	e9 81       	ldd	r30, Y+1	; 0x01
     fd2:	fa 81       	ldd	r31, Y+2	; 0x02
     fd4:	01 80       	ldd	r0, Z+1	; 0x01
     fd6:	f2 81       	ldd	r31, Z+2	; 0x02
     fd8:	e0 2d       	mov	r30, r0
     fda:	86 81       	ldd	r24, Z+6	; 0x06
     fdc:	97 81       	ldd	r25, Z+7	; 0x07
     fde:	90 93 dd 00 	sts	0x00DD, r25
     fe2:	80 93 dc 00 	sts	0x00DC, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     fe6:	e0 91 dc 00 	lds	r30, 0x00DC
     fea:	f0 91 dd 00 	lds	r31, 0x00DD
     fee:	40 81       	ld	r20, Z
     ff0:	51 81       	ldd	r21, Z+1	; 0x01
     ff2:	80 91 dc 00 	lds	r24, 0x00DC
     ff6:	90 91 dd 00 	lds	r25, 0x00DD
     ffa:	e0 91 dc 00 	lds	r30, 0x00DC
     ffe:	f0 91 dd 00 	lds	r31, 0x00DD
    1002:	27 89       	ldd	r18, Z+23	; 0x17
    1004:	62 2f       	mov	r22, r18
    1006:	fa 01       	movw	r30, r20
    1008:	09 95       	icall

	return;
}
    100a:	0f 90       	pop	r0
    100c:	0f 90       	pop	r0
    100e:	cf 91       	pop	r28
    1010:	df 91       	pop	r29
    1012:	08 95       	ret

00001014 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    1014:	df 93       	push	r29
    1016:	cf 93       	push	r28
    1018:	0f 92       	push	r0
    101a:	cd b7       	in	r28, 0x3d	; 61
    101c:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    101e:	19 82       	std	Y+1, r1	; 0x01
    1020:	13 c0       	rjmp	.+38     	; 0x1048 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1022:	89 81       	ldd	r24, Y+1	; 0x01
    1024:	28 2f       	mov	r18, r24
    1026:	30 e0       	ldi	r19, 0x00	; 0
    1028:	c9 01       	movw	r24, r18
    102a:	88 0f       	add	r24, r24
    102c:	99 1f       	adc	r25, r25
    102e:	88 0f       	add	r24, r24
    1030:	99 1f       	adc	r25, r25
    1032:	88 0f       	add	r24, r24
    1034:	99 1f       	adc	r25, r25
    1036:	82 0f       	add	r24, r18
    1038:	93 1f       	adc	r25, r19
    103a:	8b 51       	subi	r24, 0x1B	; 27
    103c:	9f 4f       	sbci	r25, 0xFF	; 255
    103e:	0e 94 e7 08 	call	0x11ce	; 0x11ce <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    1042:	89 81       	ldd	r24, Y+1	; 0x01
    1044:	8f 5f       	subi	r24, 0xFF	; 255
    1046:	89 83       	std	Y+1, r24	; 0x01
    1048:	89 81       	ldd	r24, Y+1	; 0x01
    104a:	82 30       	cpi	r24, 0x02	; 2
    104c:	50 f3       	brcs	.-44     	; 0x1022 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    104e:	87 ef       	ldi	r24, 0xF7	; 247
    1050:	90 e0       	ldi	r25, 0x00	; 0
    1052:	0e 94 e7 08 	call	0x11ce	; 0x11ce <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    1056:	80 e0       	ldi	r24, 0x00	; 0
    1058:	91 e0       	ldi	r25, 0x01	; 1
    105a:	0e 94 e7 08 	call	0x11ce	; 0x11ce <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    105e:	8d e0       	ldi	r24, 0x0D	; 13
    1060:	91 e0       	ldi	r25, 0x01	; 1
    1062:	0e 94 e7 08 	call	0x11ce	; 0x11ce <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1066:	87 ef       	ldi	r24, 0xF7	; 247
    1068:	90 e0       	ldi	r25, 0x00	; 0
    106a:	90 93 0a 01 	sts	0x010A, r25
    106e:	80 93 09 01 	sts	0x0109, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1072:	80 e0       	ldi	r24, 0x00	; 0
    1074:	91 e0       	ldi	r25, 0x01	; 1
    1076:	90 93 0c 01 	sts	0x010C, r25
    107a:	80 93 0b 01 	sts	0x010B, r24
}
    107e:	0f 90       	pop	r0
    1080:	cf 91       	pop	r28
    1082:	df 91       	pop	r29
    1084:	08 95       	ret

00001086 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    1086:	df 93       	push	r29
    1088:	cf 93       	push	r28
    108a:	00 d0       	rcall	.+0      	; 0x108c <xCoRoutineRemoveFromEventList+0x6>
    108c:	00 d0       	rcall	.+0      	; 0x108e <xCoRoutineRemoveFromEventList+0x8>
    108e:	0f 92       	push	r0
    1090:	cd b7       	in	r28, 0x3d	; 61
    1092:	de b7       	in	r29, 0x3e	; 62
    1094:	9d 83       	std	Y+5, r25	; 0x05
    1096:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1098:	ec 81       	ldd	r30, Y+4	; 0x04
    109a:	fd 81       	ldd	r31, Y+5	; 0x05
    109c:	05 80       	ldd	r0, Z+5	; 0x05
    109e:	f6 81       	ldd	r31, Z+6	; 0x06
    10a0:	e0 2d       	mov	r30, r0
    10a2:	86 81       	ldd	r24, Z+6	; 0x06
    10a4:	97 81       	ldd	r25, Z+7	; 0x07
    10a6:	9b 83       	std	Y+3, r25	; 0x03
    10a8:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    10aa:	8a 81       	ldd	r24, Y+2	; 0x02
    10ac:	9b 81       	ldd	r25, Y+3	; 0x03
    10ae:	0c 96       	adiw	r24, 0x0c	; 12
    10b0:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    10b4:	8a 81       	ldd	r24, Y+2	; 0x02
    10b6:	9b 81       	ldd	r25, Y+3	; 0x03
    10b8:	9c 01       	movw	r18, r24
    10ba:	24 5f       	subi	r18, 0xF4	; 244
    10bc:	3f 4f       	sbci	r19, 0xFF	; 255
    10be:	8d e0       	ldi	r24, 0x0D	; 13
    10c0:	91 e0       	ldi	r25, 0x01	; 1
    10c2:	b9 01       	movw	r22, r18
    10c4:	0e 94 21 09 	call	0x1242	; 0x1242 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    10c8:	ea 81       	ldd	r30, Y+2	; 0x02
    10ca:	fb 81       	ldd	r31, Y+3	; 0x03
    10cc:	96 89       	ldd	r25, Z+22	; 0x16
    10ce:	e0 91 dc 00 	lds	r30, 0x00DC
    10d2:	f0 91 dd 00 	lds	r31, 0x00DD
    10d6:	86 89       	ldd	r24, Z+22	; 0x16
    10d8:	98 17       	cp	r25, r24
    10da:	18 f0       	brcs	.+6      	; 0x10e2 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    10dc:	81 e0       	ldi	r24, 0x01	; 1
    10de:	89 83       	std	Y+1, r24	; 0x01
    10e0:	01 c0       	rjmp	.+2      	; 0x10e4 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    10e2:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    10e4:	89 81       	ldd	r24, Y+1	; 0x01
}
    10e6:	0f 90       	pop	r0
    10e8:	0f 90       	pop	r0
    10ea:	0f 90       	pop	r0
    10ec:	0f 90       	pop	r0
    10ee:	0f 90       	pop	r0
    10f0:	cf 91       	pop	r28
    10f2:	df 91       	pop	r29
    10f4:	08 95       	ret

000010f6 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    10f6:	df 93       	push	r29
    10f8:	cf 93       	push	r28
    10fa:	00 d0       	rcall	.+0      	; 0x10fc <pvPortMalloc+0x6>
    10fc:	00 d0       	rcall	.+0      	; 0x10fe <pvPortMalloc+0x8>
    10fe:	cd b7       	in	r28, 0x3d	; 61
    1100:	de b7       	in	r29, 0x3e	; 62
    1102:	9c 83       	std	Y+4, r25	; 0x04
    1104:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    1106:	1a 82       	std	Y+2, r1	; 0x02
    1108:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    110a:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    110e:	80 91 16 01 	lds	r24, 0x0116
    1112:	90 91 17 01 	lds	r25, 0x0117
    1116:	2b 81       	ldd	r18, Y+3	; 0x03
    1118:	3c 81       	ldd	r19, Y+4	; 0x04
    111a:	82 0f       	add	r24, r18
    111c:	93 1f       	adc	r25, r19
    111e:	25 e0       	ldi	r18, 0x05	; 5
    1120:	8c 3d       	cpi	r24, 0xDC	; 220
    1122:	92 07       	cpc	r25, r18
    1124:	18 f5       	brcc	.+70     	; 0x116c <pvPortMalloc+0x76>
    1126:	20 91 16 01 	lds	r18, 0x0116
    112a:	30 91 17 01 	lds	r19, 0x0117
    112e:	8b 81       	ldd	r24, Y+3	; 0x03
    1130:	9c 81       	ldd	r25, Y+4	; 0x04
    1132:	28 0f       	add	r18, r24
    1134:	39 1f       	adc	r19, r25
    1136:	80 91 16 01 	lds	r24, 0x0116
    113a:	90 91 17 01 	lds	r25, 0x0117
    113e:	82 17       	cp	r24, r18
    1140:	93 07       	cpc	r25, r19
    1142:	a0 f4       	brcc	.+40     	; 0x116c <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    1144:	80 91 16 01 	lds	r24, 0x0116
    1148:	90 91 17 01 	lds	r25, 0x0117
    114c:	88 5e       	subi	r24, 0xE8	; 232
    114e:	9e 4f       	sbci	r25, 0xFE	; 254
    1150:	9a 83       	std	Y+2, r25	; 0x02
    1152:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    1154:	20 91 16 01 	lds	r18, 0x0116
    1158:	30 91 17 01 	lds	r19, 0x0117
    115c:	8b 81       	ldd	r24, Y+3	; 0x03
    115e:	9c 81       	ldd	r25, Y+4	; 0x04
    1160:	82 0f       	add	r24, r18
    1162:	93 1f       	adc	r25, r19
    1164:	90 93 17 01 	sts	0x0117, r25
    1168:	80 93 16 01 	sts	0x0116, r24
		}	
	}
	xTaskResumeAll();
    116c:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    1170:	89 81       	ldd	r24, Y+1	; 0x01
    1172:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1174:	0f 90       	pop	r0
    1176:	0f 90       	pop	r0
    1178:	0f 90       	pop	r0
    117a:	0f 90       	pop	r0
    117c:	cf 91       	pop	r28
    117e:	df 91       	pop	r29
    1180:	08 95       	ret

00001182 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1182:	df 93       	push	r29
    1184:	cf 93       	push	r28
    1186:	00 d0       	rcall	.+0      	; 0x1188 <vPortFree+0x6>
    1188:	cd b7       	in	r28, 0x3d	; 61
    118a:	de b7       	in	r29, 0x3e	; 62
    118c:	9a 83       	std	Y+2, r25	; 0x02
    118e:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    1190:	0f 90       	pop	r0
    1192:	0f 90       	pop	r0
    1194:	cf 91       	pop	r28
    1196:	df 91       	pop	r29
    1198:	08 95       	ret

0000119a <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    119a:	df 93       	push	r29
    119c:	cf 93       	push	r28
    119e:	cd b7       	in	r28, 0x3d	; 61
    11a0:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    11a2:	10 92 17 01 	sts	0x0117, r1
    11a6:	10 92 16 01 	sts	0x0116, r1
}
    11aa:	cf 91       	pop	r28
    11ac:	df 91       	pop	r29
    11ae:	08 95       	ret

000011b0 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    11b0:	df 93       	push	r29
    11b2:	cf 93       	push	r28
    11b4:	cd b7       	in	r28, 0x3d	; 61
    11b6:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    11b8:	20 91 16 01 	lds	r18, 0x0116
    11bc:	30 91 17 01 	lds	r19, 0x0117
    11c0:	8c ed       	ldi	r24, 0xDC	; 220
    11c2:	95 e0       	ldi	r25, 0x05	; 5
    11c4:	82 1b       	sub	r24, r18
    11c6:	93 0b       	sbc	r25, r19
}
    11c8:	cf 91       	pop	r28
    11ca:	df 91       	pop	r29
    11cc:	08 95       	ret

000011ce <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    11ce:	df 93       	push	r29
    11d0:	cf 93       	push	r28
    11d2:	00 d0       	rcall	.+0      	; 0x11d4 <vListInitialise+0x6>
    11d4:	cd b7       	in	r28, 0x3d	; 61
    11d6:	de b7       	in	r29, 0x3e	; 62
    11d8:	9a 83       	std	Y+2, r25	; 0x02
    11da:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    11dc:	89 81       	ldd	r24, Y+1	; 0x01
    11de:	9a 81       	ldd	r25, Y+2	; 0x02
    11e0:	03 96       	adiw	r24, 0x03	; 3
    11e2:	e9 81       	ldd	r30, Y+1	; 0x01
    11e4:	fa 81       	ldd	r31, Y+2	; 0x02
    11e6:	92 83       	std	Z+2, r25	; 0x02
    11e8:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    11ea:	e9 81       	ldd	r30, Y+1	; 0x01
    11ec:	fa 81       	ldd	r31, Y+2	; 0x02
    11ee:	8f ef       	ldi	r24, 0xFF	; 255
    11f0:	9f ef       	ldi	r25, 0xFF	; 255
    11f2:	94 83       	std	Z+4, r25	; 0x04
    11f4:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    11f6:	89 81       	ldd	r24, Y+1	; 0x01
    11f8:	9a 81       	ldd	r25, Y+2	; 0x02
    11fa:	03 96       	adiw	r24, 0x03	; 3
    11fc:	e9 81       	ldd	r30, Y+1	; 0x01
    11fe:	fa 81       	ldd	r31, Y+2	; 0x02
    1200:	96 83       	std	Z+6, r25	; 0x06
    1202:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1204:	89 81       	ldd	r24, Y+1	; 0x01
    1206:	9a 81       	ldd	r25, Y+2	; 0x02
    1208:	03 96       	adiw	r24, 0x03	; 3
    120a:	e9 81       	ldd	r30, Y+1	; 0x01
    120c:	fa 81       	ldd	r31, Y+2	; 0x02
    120e:	90 87       	std	Z+8, r25	; 0x08
    1210:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1212:	e9 81       	ldd	r30, Y+1	; 0x01
    1214:	fa 81       	ldd	r31, Y+2	; 0x02
    1216:	10 82       	st	Z, r1
}
    1218:	0f 90       	pop	r0
    121a:	0f 90       	pop	r0
    121c:	cf 91       	pop	r28
    121e:	df 91       	pop	r29
    1220:	08 95       	ret

00001222 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    1222:	df 93       	push	r29
    1224:	cf 93       	push	r28
    1226:	00 d0       	rcall	.+0      	; 0x1228 <vListInitialiseItem+0x6>
    1228:	cd b7       	in	r28, 0x3d	; 61
    122a:	de b7       	in	r29, 0x3e	; 62
    122c:	9a 83       	std	Y+2, r25	; 0x02
    122e:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1230:	e9 81       	ldd	r30, Y+1	; 0x01
    1232:	fa 81       	ldd	r31, Y+2	; 0x02
    1234:	11 86       	std	Z+9, r1	; 0x09
    1236:	10 86       	std	Z+8, r1	; 0x08
}
    1238:	0f 90       	pop	r0
    123a:	0f 90       	pop	r0
    123c:	cf 91       	pop	r28
    123e:	df 91       	pop	r29
    1240:	08 95       	ret

00001242 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1242:	df 93       	push	r29
    1244:	cf 93       	push	r28
    1246:	00 d0       	rcall	.+0      	; 0x1248 <vListInsertEnd+0x6>
    1248:	00 d0       	rcall	.+0      	; 0x124a <vListInsertEnd+0x8>
    124a:	00 d0       	rcall	.+0      	; 0x124c <vListInsertEnd+0xa>
    124c:	cd b7       	in	r28, 0x3d	; 61
    124e:	de b7       	in	r29, 0x3e	; 62
    1250:	9c 83       	std	Y+4, r25	; 0x04
    1252:	8b 83       	std	Y+3, r24	; 0x03
    1254:	7e 83       	std	Y+6, r23	; 0x06
    1256:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1258:	eb 81       	ldd	r30, Y+3	; 0x03
    125a:	fc 81       	ldd	r31, Y+4	; 0x04
    125c:	81 81       	ldd	r24, Z+1	; 0x01
    125e:	92 81       	ldd	r25, Z+2	; 0x02
    1260:	9a 83       	std	Y+2, r25	; 0x02
    1262:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    1264:	e9 81       	ldd	r30, Y+1	; 0x01
    1266:	fa 81       	ldd	r31, Y+2	; 0x02
    1268:	82 81       	ldd	r24, Z+2	; 0x02
    126a:	93 81       	ldd	r25, Z+3	; 0x03
    126c:	ed 81       	ldd	r30, Y+5	; 0x05
    126e:	fe 81       	ldd	r31, Y+6	; 0x06
    1270:	93 83       	std	Z+3, r25	; 0x03
    1272:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1274:	eb 81       	ldd	r30, Y+3	; 0x03
    1276:	fc 81       	ldd	r31, Y+4	; 0x04
    1278:	81 81       	ldd	r24, Z+1	; 0x01
    127a:	92 81       	ldd	r25, Z+2	; 0x02
    127c:	ed 81       	ldd	r30, Y+5	; 0x05
    127e:	fe 81       	ldd	r31, Y+6	; 0x06
    1280:	95 83       	std	Z+5, r25	; 0x05
    1282:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1284:	e9 81       	ldd	r30, Y+1	; 0x01
    1286:	fa 81       	ldd	r31, Y+2	; 0x02
    1288:	02 80       	ldd	r0, Z+2	; 0x02
    128a:	f3 81       	ldd	r31, Z+3	; 0x03
    128c:	e0 2d       	mov	r30, r0
    128e:	8d 81       	ldd	r24, Y+5	; 0x05
    1290:	9e 81       	ldd	r25, Y+6	; 0x06
    1292:	95 83       	std	Z+5, r25	; 0x05
    1294:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1296:	8d 81       	ldd	r24, Y+5	; 0x05
    1298:	9e 81       	ldd	r25, Y+6	; 0x06
    129a:	e9 81       	ldd	r30, Y+1	; 0x01
    129c:	fa 81       	ldd	r31, Y+2	; 0x02
    129e:	93 83       	std	Z+3, r25	; 0x03
    12a0:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    12a2:	8d 81       	ldd	r24, Y+5	; 0x05
    12a4:	9e 81       	ldd	r25, Y+6	; 0x06
    12a6:	eb 81       	ldd	r30, Y+3	; 0x03
    12a8:	fc 81       	ldd	r31, Y+4	; 0x04
    12aa:	92 83       	std	Z+2, r25	; 0x02
    12ac:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    12ae:	ed 81       	ldd	r30, Y+5	; 0x05
    12b0:	fe 81       	ldd	r31, Y+6	; 0x06
    12b2:	8b 81       	ldd	r24, Y+3	; 0x03
    12b4:	9c 81       	ldd	r25, Y+4	; 0x04
    12b6:	91 87       	std	Z+9, r25	; 0x09
    12b8:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    12ba:	eb 81       	ldd	r30, Y+3	; 0x03
    12bc:	fc 81       	ldd	r31, Y+4	; 0x04
    12be:	80 81       	ld	r24, Z
    12c0:	8f 5f       	subi	r24, 0xFF	; 255
    12c2:	eb 81       	ldd	r30, Y+3	; 0x03
    12c4:	fc 81       	ldd	r31, Y+4	; 0x04
    12c6:	80 83       	st	Z, r24
}
    12c8:	26 96       	adiw	r28, 0x06	; 6
    12ca:	0f b6       	in	r0, 0x3f	; 63
    12cc:	f8 94       	cli
    12ce:	de bf       	out	0x3e, r29	; 62
    12d0:	0f be       	out	0x3f, r0	; 63
    12d2:	cd bf       	out	0x3d, r28	; 61
    12d4:	cf 91       	pop	r28
    12d6:	df 91       	pop	r29
    12d8:	08 95       	ret

000012da <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    12da:	df 93       	push	r29
    12dc:	cf 93       	push	r28
    12de:	cd b7       	in	r28, 0x3d	; 61
    12e0:	de b7       	in	r29, 0x3e	; 62
    12e2:	28 97       	sbiw	r28, 0x08	; 8
    12e4:	0f b6       	in	r0, 0x3f	; 63
    12e6:	f8 94       	cli
    12e8:	de bf       	out	0x3e, r29	; 62
    12ea:	0f be       	out	0x3f, r0	; 63
    12ec:	cd bf       	out	0x3d, r28	; 61
    12ee:	9e 83       	std	Y+6, r25	; 0x06
    12f0:	8d 83       	std	Y+5, r24	; 0x05
    12f2:	78 87       	std	Y+8, r23	; 0x08
    12f4:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    12f6:	ef 81       	ldd	r30, Y+7	; 0x07
    12f8:	f8 85       	ldd	r31, Y+8	; 0x08
    12fa:	80 81       	ld	r24, Z
    12fc:	91 81       	ldd	r25, Z+1	; 0x01
    12fe:	9a 83       	std	Y+2, r25	; 0x02
    1300:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1302:	89 81       	ldd	r24, Y+1	; 0x01
    1304:	9a 81       	ldd	r25, Y+2	; 0x02
    1306:	2f ef       	ldi	r18, 0xFF	; 255
    1308:	8f 3f       	cpi	r24, 0xFF	; 255
    130a:	92 07       	cpc	r25, r18
    130c:	39 f4       	brne	.+14     	; 0x131c <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    130e:	ed 81       	ldd	r30, Y+5	; 0x05
    1310:	fe 81       	ldd	r31, Y+6	; 0x06
    1312:	87 81       	ldd	r24, Z+7	; 0x07
    1314:	90 85       	ldd	r25, Z+8	; 0x08
    1316:	9c 83       	std	Y+4, r25	; 0x04
    1318:	8b 83       	std	Y+3, r24	; 0x03
    131a:	18 c0       	rjmp	.+48     	; 0x134c <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    131c:	8d 81       	ldd	r24, Y+5	; 0x05
    131e:	9e 81       	ldd	r25, Y+6	; 0x06
    1320:	03 96       	adiw	r24, 0x03	; 3
    1322:	9c 83       	std	Y+4, r25	; 0x04
    1324:	8b 83       	std	Y+3, r24	; 0x03
    1326:	06 c0       	rjmp	.+12     	; 0x1334 <vListInsert+0x5a>
    1328:	eb 81       	ldd	r30, Y+3	; 0x03
    132a:	fc 81       	ldd	r31, Y+4	; 0x04
    132c:	82 81       	ldd	r24, Z+2	; 0x02
    132e:	93 81       	ldd	r25, Z+3	; 0x03
    1330:	9c 83       	std	Y+4, r25	; 0x04
    1332:	8b 83       	std	Y+3, r24	; 0x03
    1334:	eb 81       	ldd	r30, Y+3	; 0x03
    1336:	fc 81       	ldd	r31, Y+4	; 0x04
    1338:	02 80       	ldd	r0, Z+2	; 0x02
    133a:	f3 81       	ldd	r31, Z+3	; 0x03
    133c:	e0 2d       	mov	r30, r0
    133e:	20 81       	ld	r18, Z
    1340:	31 81       	ldd	r19, Z+1	; 0x01
    1342:	89 81       	ldd	r24, Y+1	; 0x01
    1344:	9a 81       	ldd	r25, Y+2	; 0x02
    1346:	82 17       	cp	r24, r18
    1348:	93 07       	cpc	r25, r19
    134a:	70 f7       	brcc	.-36     	; 0x1328 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    134c:	eb 81       	ldd	r30, Y+3	; 0x03
    134e:	fc 81       	ldd	r31, Y+4	; 0x04
    1350:	82 81       	ldd	r24, Z+2	; 0x02
    1352:	93 81       	ldd	r25, Z+3	; 0x03
    1354:	ef 81       	ldd	r30, Y+7	; 0x07
    1356:	f8 85       	ldd	r31, Y+8	; 0x08
    1358:	93 83       	std	Z+3, r25	; 0x03
    135a:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    135c:	ef 81       	ldd	r30, Y+7	; 0x07
    135e:	f8 85       	ldd	r31, Y+8	; 0x08
    1360:	02 80       	ldd	r0, Z+2	; 0x02
    1362:	f3 81       	ldd	r31, Z+3	; 0x03
    1364:	e0 2d       	mov	r30, r0
    1366:	8f 81       	ldd	r24, Y+7	; 0x07
    1368:	98 85       	ldd	r25, Y+8	; 0x08
    136a:	95 83       	std	Z+5, r25	; 0x05
    136c:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    136e:	ef 81       	ldd	r30, Y+7	; 0x07
    1370:	f8 85       	ldd	r31, Y+8	; 0x08
    1372:	8b 81       	ldd	r24, Y+3	; 0x03
    1374:	9c 81       	ldd	r25, Y+4	; 0x04
    1376:	95 83       	std	Z+5, r25	; 0x05
    1378:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    137a:	8f 81       	ldd	r24, Y+7	; 0x07
    137c:	98 85       	ldd	r25, Y+8	; 0x08
    137e:	eb 81       	ldd	r30, Y+3	; 0x03
    1380:	fc 81       	ldd	r31, Y+4	; 0x04
    1382:	93 83       	std	Z+3, r25	; 0x03
    1384:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1386:	ef 81       	ldd	r30, Y+7	; 0x07
    1388:	f8 85       	ldd	r31, Y+8	; 0x08
    138a:	8d 81       	ldd	r24, Y+5	; 0x05
    138c:	9e 81       	ldd	r25, Y+6	; 0x06
    138e:	91 87       	std	Z+9, r25	; 0x09
    1390:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1392:	ed 81       	ldd	r30, Y+5	; 0x05
    1394:	fe 81       	ldd	r31, Y+6	; 0x06
    1396:	80 81       	ld	r24, Z
    1398:	8f 5f       	subi	r24, 0xFF	; 255
    139a:	ed 81       	ldd	r30, Y+5	; 0x05
    139c:	fe 81       	ldd	r31, Y+6	; 0x06
    139e:	80 83       	st	Z, r24
}
    13a0:	28 96       	adiw	r28, 0x08	; 8
    13a2:	0f b6       	in	r0, 0x3f	; 63
    13a4:	f8 94       	cli
    13a6:	de bf       	out	0x3e, r29	; 62
    13a8:	0f be       	out	0x3f, r0	; 63
    13aa:	cd bf       	out	0x3d, r28	; 61
    13ac:	cf 91       	pop	r28
    13ae:	df 91       	pop	r29
    13b0:	08 95       	ret

000013b2 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    13b2:	df 93       	push	r29
    13b4:	cf 93       	push	r28
    13b6:	00 d0       	rcall	.+0      	; 0x13b8 <vListRemove+0x6>
    13b8:	00 d0       	rcall	.+0      	; 0x13ba <vListRemove+0x8>
    13ba:	cd b7       	in	r28, 0x3d	; 61
    13bc:	de b7       	in	r29, 0x3e	; 62
    13be:	9c 83       	std	Y+4, r25	; 0x04
    13c0:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    13c2:	eb 81       	ldd	r30, Y+3	; 0x03
    13c4:	fc 81       	ldd	r31, Y+4	; 0x04
    13c6:	a2 81       	ldd	r26, Z+2	; 0x02
    13c8:	b3 81       	ldd	r27, Z+3	; 0x03
    13ca:	eb 81       	ldd	r30, Y+3	; 0x03
    13cc:	fc 81       	ldd	r31, Y+4	; 0x04
    13ce:	84 81       	ldd	r24, Z+4	; 0x04
    13d0:	95 81       	ldd	r25, Z+5	; 0x05
    13d2:	15 96       	adiw	r26, 0x05	; 5
    13d4:	9c 93       	st	X, r25
    13d6:	8e 93       	st	-X, r24
    13d8:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    13da:	eb 81       	ldd	r30, Y+3	; 0x03
    13dc:	fc 81       	ldd	r31, Y+4	; 0x04
    13de:	a4 81       	ldd	r26, Z+4	; 0x04
    13e0:	b5 81       	ldd	r27, Z+5	; 0x05
    13e2:	eb 81       	ldd	r30, Y+3	; 0x03
    13e4:	fc 81       	ldd	r31, Y+4	; 0x04
    13e6:	82 81       	ldd	r24, Z+2	; 0x02
    13e8:	93 81       	ldd	r25, Z+3	; 0x03
    13ea:	13 96       	adiw	r26, 0x03	; 3
    13ec:	9c 93       	st	X, r25
    13ee:	8e 93       	st	-X, r24
    13f0:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    13f2:	eb 81       	ldd	r30, Y+3	; 0x03
    13f4:	fc 81       	ldd	r31, Y+4	; 0x04
    13f6:	80 85       	ldd	r24, Z+8	; 0x08
    13f8:	91 85       	ldd	r25, Z+9	; 0x09
    13fa:	9a 83       	std	Y+2, r25	; 0x02
    13fc:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    13fe:	e9 81       	ldd	r30, Y+1	; 0x01
    1400:	fa 81       	ldd	r31, Y+2	; 0x02
    1402:	21 81       	ldd	r18, Z+1	; 0x01
    1404:	32 81       	ldd	r19, Z+2	; 0x02
    1406:	8b 81       	ldd	r24, Y+3	; 0x03
    1408:	9c 81       	ldd	r25, Y+4	; 0x04
    140a:	28 17       	cp	r18, r24
    140c:	39 07       	cpc	r19, r25
    140e:	41 f4       	brne	.+16     	; 0x1420 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1410:	eb 81       	ldd	r30, Y+3	; 0x03
    1412:	fc 81       	ldd	r31, Y+4	; 0x04
    1414:	84 81       	ldd	r24, Z+4	; 0x04
    1416:	95 81       	ldd	r25, Z+5	; 0x05
    1418:	e9 81       	ldd	r30, Y+1	; 0x01
    141a:	fa 81       	ldd	r31, Y+2	; 0x02
    141c:	92 83       	std	Z+2, r25	; 0x02
    141e:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    1420:	eb 81       	ldd	r30, Y+3	; 0x03
    1422:	fc 81       	ldd	r31, Y+4	; 0x04
    1424:	11 86       	std	Z+9, r1	; 0x09
    1426:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1428:	e9 81       	ldd	r30, Y+1	; 0x01
    142a:	fa 81       	ldd	r31, Y+2	; 0x02
    142c:	80 81       	ld	r24, Z
    142e:	81 50       	subi	r24, 0x01	; 1
    1430:	e9 81       	ldd	r30, Y+1	; 0x01
    1432:	fa 81       	ldd	r31, Y+2	; 0x02
    1434:	80 83       	st	Z, r24
}
    1436:	0f 90       	pop	r0
    1438:	0f 90       	pop	r0
    143a:	0f 90       	pop	r0
    143c:	0f 90       	pop	r0
    143e:	cf 91       	pop	r28
    1440:	df 91       	pop	r29
    1442:	08 95       	ret

00001444 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    1444:	df 93       	push	r29
    1446:	cf 93       	push	r28
    1448:	cd b7       	in	r28, 0x3d	; 61
    144a:	de b7       	in	r29, 0x3e	; 62
    144c:	28 97       	sbiw	r28, 0x08	; 8
    144e:	0f b6       	in	r0, 0x3f	; 63
    1450:	f8 94       	cli
    1452:	de bf       	out	0x3e, r29	; 62
    1454:	0f be       	out	0x3f, r0	; 63
    1456:	cd bf       	out	0x3d, r28	; 61
    1458:	9c 83       	std	Y+4, r25	; 0x04
    145a:	8b 83       	std	Y+3, r24	; 0x03
    145c:	7e 83       	std	Y+6, r23	; 0x06
    145e:	6d 83       	std	Y+5, r22	; 0x05
    1460:	58 87       	std	Y+8, r21	; 0x08
    1462:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1464:	eb 81       	ldd	r30, Y+3	; 0x03
    1466:	fc 81       	ldd	r31, Y+4	; 0x04
    1468:	81 e1       	ldi	r24, 0x11	; 17
    146a:	80 83       	st	Z, r24
	pxTopOfStack--;
    146c:	8b 81       	ldd	r24, Y+3	; 0x03
    146e:	9c 81       	ldd	r25, Y+4	; 0x04
    1470:	01 97       	sbiw	r24, 0x01	; 1
    1472:	9c 83       	std	Y+4, r25	; 0x04
    1474:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    1476:	eb 81       	ldd	r30, Y+3	; 0x03
    1478:	fc 81       	ldd	r31, Y+4	; 0x04
    147a:	82 e2       	ldi	r24, 0x22	; 34
    147c:	80 83       	st	Z, r24
	pxTopOfStack--;
    147e:	8b 81       	ldd	r24, Y+3	; 0x03
    1480:	9c 81       	ldd	r25, Y+4	; 0x04
    1482:	01 97       	sbiw	r24, 0x01	; 1
    1484:	9c 83       	std	Y+4, r25	; 0x04
    1486:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    1488:	eb 81       	ldd	r30, Y+3	; 0x03
    148a:	fc 81       	ldd	r31, Y+4	; 0x04
    148c:	83 e3       	ldi	r24, 0x33	; 51
    148e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1490:	8b 81       	ldd	r24, Y+3	; 0x03
    1492:	9c 81       	ldd	r25, Y+4	; 0x04
    1494:	01 97       	sbiw	r24, 0x01	; 1
    1496:	9c 83       	std	Y+4, r25	; 0x04
    1498:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    149a:	8d 81       	ldd	r24, Y+5	; 0x05
    149c:	9e 81       	ldd	r25, Y+6	; 0x06
    149e:	9a 83       	std	Y+2, r25	; 0x02
    14a0:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    14a2:	89 81       	ldd	r24, Y+1	; 0x01
    14a4:	eb 81       	ldd	r30, Y+3	; 0x03
    14a6:	fc 81       	ldd	r31, Y+4	; 0x04
    14a8:	80 83       	st	Z, r24
	pxTopOfStack--;
    14aa:	8b 81       	ldd	r24, Y+3	; 0x03
    14ac:	9c 81       	ldd	r25, Y+4	; 0x04
    14ae:	01 97       	sbiw	r24, 0x01	; 1
    14b0:	9c 83       	std	Y+4, r25	; 0x04
    14b2:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    14b4:	89 81       	ldd	r24, Y+1	; 0x01
    14b6:	9a 81       	ldd	r25, Y+2	; 0x02
    14b8:	89 2f       	mov	r24, r25
    14ba:	99 27       	eor	r25, r25
    14bc:	9a 83       	std	Y+2, r25	; 0x02
    14be:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    14c0:	89 81       	ldd	r24, Y+1	; 0x01
    14c2:	eb 81       	ldd	r30, Y+3	; 0x03
    14c4:	fc 81       	ldd	r31, Y+4	; 0x04
    14c6:	80 83       	st	Z, r24
	pxTopOfStack--;
    14c8:	8b 81       	ldd	r24, Y+3	; 0x03
    14ca:	9c 81       	ldd	r25, Y+4	; 0x04
    14cc:	01 97       	sbiw	r24, 0x01	; 1
    14ce:	9c 83       	std	Y+4, r25	; 0x04
    14d0:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    14d2:	eb 81       	ldd	r30, Y+3	; 0x03
    14d4:	fc 81       	ldd	r31, Y+4	; 0x04
    14d6:	10 82       	st	Z, r1
	pxTopOfStack--;
    14d8:	8b 81       	ldd	r24, Y+3	; 0x03
    14da:	9c 81       	ldd	r25, Y+4	; 0x04
    14dc:	01 97       	sbiw	r24, 0x01	; 1
    14de:	9c 83       	std	Y+4, r25	; 0x04
    14e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    14e2:	eb 81       	ldd	r30, Y+3	; 0x03
    14e4:	fc 81       	ldd	r31, Y+4	; 0x04
    14e6:	80 e8       	ldi	r24, 0x80	; 128
    14e8:	80 83       	st	Z, r24
	pxTopOfStack--;
    14ea:	8b 81       	ldd	r24, Y+3	; 0x03
    14ec:	9c 81       	ldd	r25, Y+4	; 0x04
    14ee:	01 97       	sbiw	r24, 0x01	; 1
    14f0:	9c 83       	std	Y+4, r25	; 0x04
    14f2:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    14f4:	eb 81       	ldd	r30, Y+3	; 0x03
    14f6:	fc 81       	ldd	r31, Y+4	; 0x04
    14f8:	10 82       	st	Z, r1
	pxTopOfStack--;
    14fa:	8b 81       	ldd	r24, Y+3	; 0x03
    14fc:	9c 81       	ldd	r25, Y+4	; 0x04
    14fe:	01 97       	sbiw	r24, 0x01	; 1
    1500:	9c 83       	std	Y+4, r25	; 0x04
    1502:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    1504:	eb 81       	ldd	r30, Y+3	; 0x03
    1506:	fc 81       	ldd	r31, Y+4	; 0x04
    1508:	82 e0       	ldi	r24, 0x02	; 2
    150a:	80 83       	st	Z, r24
	pxTopOfStack--;
    150c:	8b 81       	ldd	r24, Y+3	; 0x03
    150e:	9c 81       	ldd	r25, Y+4	; 0x04
    1510:	01 97       	sbiw	r24, 0x01	; 1
    1512:	9c 83       	std	Y+4, r25	; 0x04
    1514:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    1516:	eb 81       	ldd	r30, Y+3	; 0x03
    1518:	fc 81       	ldd	r31, Y+4	; 0x04
    151a:	83 e0       	ldi	r24, 0x03	; 3
    151c:	80 83       	st	Z, r24
	pxTopOfStack--;
    151e:	8b 81       	ldd	r24, Y+3	; 0x03
    1520:	9c 81       	ldd	r25, Y+4	; 0x04
    1522:	01 97       	sbiw	r24, 0x01	; 1
    1524:	9c 83       	std	Y+4, r25	; 0x04
    1526:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    1528:	eb 81       	ldd	r30, Y+3	; 0x03
    152a:	fc 81       	ldd	r31, Y+4	; 0x04
    152c:	84 e0       	ldi	r24, 0x04	; 4
    152e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1530:	8b 81       	ldd	r24, Y+3	; 0x03
    1532:	9c 81       	ldd	r25, Y+4	; 0x04
    1534:	01 97       	sbiw	r24, 0x01	; 1
    1536:	9c 83       	std	Y+4, r25	; 0x04
    1538:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    153a:	eb 81       	ldd	r30, Y+3	; 0x03
    153c:	fc 81       	ldd	r31, Y+4	; 0x04
    153e:	85 e0       	ldi	r24, 0x05	; 5
    1540:	80 83       	st	Z, r24
	pxTopOfStack--;
    1542:	8b 81       	ldd	r24, Y+3	; 0x03
    1544:	9c 81       	ldd	r25, Y+4	; 0x04
    1546:	01 97       	sbiw	r24, 0x01	; 1
    1548:	9c 83       	std	Y+4, r25	; 0x04
    154a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    154c:	eb 81       	ldd	r30, Y+3	; 0x03
    154e:	fc 81       	ldd	r31, Y+4	; 0x04
    1550:	86 e0       	ldi	r24, 0x06	; 6
    1552:	80 83       	st	Z, r24
	pxTopOfStack--;
    1554:	8b 81       	ldd	r24, Y+3	; 0x03
    1556:	9c 81       	ldd	r25, Y+4	; 0x04
    1558:	01 97       	sbiw	r24, 0x01	; 1
    155a:	9c 83       	std	Y+4, r25	; 0x04
    155c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    155e:	eb 81       	ldd	r30, Y+3	; 0x03
    1560:	fc 81       	ldd	r31, Y+4	; 0x04
    1562:	87 e0       	ldi	r24, 0x07	; 7
    1564:	80 83       	st	Z, r24
	pxTopOfStack--;
    1566:	8b 81       	ldd	r24, Y+3	; 0x03
    1568:	9c 81       	ldd	r25, Y+4	; 0x04
    156a:	01 97       	sbiw	r24, 0x01	; 1
    156c:	9c 83       	std	Y+4, r25	; 0x04
    156e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    1570:	eb 81       	ldd	r30, Y+3	; 0x03
    1572:	fc 81       	ldd	r31, Y+4	; 0x04
    1574:	88 e0       	ldi	r24, 0x08	; 8
    1576:	80 83       	st	Z, r24
	pxTopOfStack--;
    1578:	8b 81       	ldd	r24, Y+3	; 0x03
    157a:	9c 81       	ldd	r25, Y+4	; 0x04
    157c:	01 97       	sbiw	r24, 0x01	; 1
    157e:	9c 83       	std	Y+4, r25	; 0x04
    1580:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    1582:	eb 81       	ldd	r30, Y+3	; 0x03
    1584:	fc 81       	ldd	r31, Y+4	; 0x04
    1586:	89 e0       	ldi	r24, 0x09	; 9
    1588:	80 83       	st	Z, r24
	pxTopOfStack--;
    158a:	8b 81       	ldd	r24, Y+3	; 0x03
    158c:	9c 81       	ldd	r25, Y+4	; 0x04
    158e:	01 97       	sbiw	r24, 0x01	; 1
    1590:	9c 83       	std	Y+4, r25	; 0x04
    1592:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    1594:	eb 81       	ldd	r30, Y+3	; 0x03
    1596:	fc 81       	ldd	r31, Y+4	; 0x04
    1598:	80 e1       	ldi	r24, 0x10	; 16
    159a:	80 83       	st	Z, r24
	pxTopOfStack--;
    159c:	8b 81       	ldd	r24, Y+3	; 0x03
    159e:	9c 81       	ldd	r25, Y+4	; 0x04
    15a0:	01 97       	sbiw	r24, 0x01	; 1
    15a2:	9c 83       	std	Y+4, r25	; 0x04
    15a4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    15a6:	eb 81       	ldd	r30, Y+3	; 0x03
    15a8:	fc 81       	ldd	r31, Y+4	; 0x04
    15aa:	81 e1       	ldi	r24, 0x11	; 17
    15ac:	80 83       	st	Z, r24
	pxTopOfStack--;
    15ae:	8b 81       	ldd	r24, Y+3	; 0x03
    15b0:	9c 81       	ldd	r25, Y+4	; 0x04
    15b2:	01 97       	sbiw	r24, 0x01	; 1
    15b4:	9c 83       	std	Y+4, r25	; 0x04
    15b6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    15b8:	eb 81       	ldd	r30, Y+3	; 0x03
    15ba:	fc 81       	ldd	r31, Y+4	; 0x04
    15bc:	82 e1       	ldi	r24, 0x12	; 18
    15be:	80 83       	st	Z, r24
	pxTopOfStack--;
    15c0:	8b 81       	ldd	r24, Y+3	; 0x03
    15c2:	9c 81       	ldd	r25, Y+4	; 0x04
    15c4:	01 97       	sbiw	r24, 0x01	; 1
    15c6:	9c 83       	std	Y+4, r25	; 0x04
    15c8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    15ca:	eb 81       	ldd	r30, Y+3	; 0x03
    15cc:	fc 81       	ldd	r31, Y+4	; 0x04
    15ce:	83 e1       	ldi	r24, 0x13	; 19
    15d0:	80 83       	st	Z, r24
	pxTopOfStack--;
    15d2:	8b 81       	ldd	r24, Y+3	; 0x03
    15d4:	9c 81       	ldd	r25, Y+4	; 0x04
    15d6:	01 97       	sbiw	r24, 0x01	; 1
    15d8:	9c 83       	std	Y+4, r25	; 0x04
    15da:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    15dc:	eb 81       	ldd	r30, Y+3	; 0x03
    15de:	fc 81       	ldd	r31, Y+4	; 0x04
    15e0:	84 e1       	ldi	r24, 0x14	; 20
    15e2:	80 83       	st	Z, r24
	pxTopOfStack--;
    15e4:	8b 81       	ldd	r24, Y+3	; 0x03
    15e6:	9c 81       	ldd	r25, Y+4	; 0x04
    15e8:	01 97       	sbiw	r24, 0x01	; 1
    15ea:	9c 83       	std	Y+4, r25	; 0x04
    15ec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    15ee:	eb 81       	ldd	r30, Y+3	; 0x03
    15f0:	fc 81       	ldd	r31, Y+4	; 0x04
    15f2:	85 e1       	ldi	r24, 0x15	; 21
    15f4:	80 83       	st	Z, r24
	pxTopOfStack--;
    15f6:	8b 81       	ldd	r24, Y+3	; 0x03
    15f8:	9c 81       	ldd	r25, Y+4	; 0x04
    15fa:	01 97       	sbiw	r24, 0x01	; 1
    15fc:	9c 83       	std	Y+4, r25	; 0x04
    15fe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    1600:	eb 81       	ldd	r30, Y+3	; 0x03
    1602:	fc 81       	ldd	r31, Y+4	; 0x04
    1604:	86 e1       	ldi	r24, 0x16	; 22
    1606:	80 83       	st	Z, r24
	pxTopOfStack--;
    1608:	8b 81       	ldd	r24, Y+3	; 0x03
    160a:	9c 81       	ldd	r25, Y+4	; 0x04
    160c:	01 97       	sbiw	r24, 0x01	; 1
    160e:	9c 83       	std	Y+4, r25	; 0x04
    1610:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    1612:	eb 81       	ldd	r30, Y+3	; 0x03
    1614:	fc 81       	ldd	r31, Y+4	; 0x04
    1616:	87 e1       	ldi	r24, 0x17	; 23
    1618:	80 83       	st	Z, r24
	pxTopOfStack--;
    161a:	8b 81       	ldd	r24, Y+3	; 0x03
    161c:	9c 81       	ldd	r25, Y+4	; 0x04
    161e:	01 97       	sbiw	r24, 0x01	; 1
    1620:	9c 83       	std	Y+4, r25	; 0x04
    1622:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    1624:	eb 81       	ldd	r30, Y+3	; 0x03
    1626:	fc 81       	ldd	r31, Y+4	; 0x04
    1628:	88 e1       	ldi	r24, 0x18	; 24
    162a:	80 83       	st	Z, r24
	pxTopOfStack--;
    162c:	8b 81       	ldd	r24, Y+3	; 0x03
    162e:	9c 81       	ldd	r25, Y+4	; 0x04
    1630:	01 97       	sbiw	r24, 0x01	; 1
    1632:	9c 83       	std	Y+4, r25	; 0x04
    1634:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    1636:	eb 81       	ldd	r30, Y+3	; 0x03
    1638:	fc 81       	ldd	r31, Y+4	; 0x04
    163a:	89 e1       	ldi	r24, 0x19	; 25
    163c:	80 83       	st	Z, r24
	pxTopOfStack--;
    163e:	8b 81       	ldd	r24, Y+3	; 0x03
    1640:	9c 81       	ldd	r25, Y+4	; 0x04
    1642:	01 97       	sbiw	r24, 0x01	; 1
    1644:	9c 83       	std	Y+4, r25	; 0x04
    1646:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    1648:	eb 81       	ldd	r30, Y+3	; 0x03
    164a:	fc 81       	ldd	r31, Y+4	; 0x04
    164c:	80 e2       	ldi	r24, 0x20	; 32
    164e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1650:	8b 81       	ldd	r24, Y+3	; 0x03
    1652:	9c 81       	ldd	r25, Y+4	; 0x04
    1654:	01 97       	sbiw	r24, 0x01	; 1
    1656:	9c 83       	std	Y+4, r25	; 0x04
    1658:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    165a:	eb 81       	ldd	r30, Y+3	; 0x03
    165c:	fc 81       	ldd	r31, Y+4	; 0x04
    165e:	81 e2       	ldi	r24, 0x21	; 33
    1660:	80 83       	st	Z, r24
	pxTopOfStack--;
    1662:	8b 81       	ldd	r24, Y+3	; 0x03
    1664:	9c 81       	ldd	r25, Y+4	; 0x04
    1666:	01 97       	sbiw	r24, 0x01	; 1
    1668:	9c 83       	std	Y+4, r25	; 0x04
    166a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    166c:	eb 81       	ldd	r30, Y+3	; 0x03
    166e:	fc 81       	ldd	r31, Y+4	; 0x04
    1670:	82 e2       	ldi	r24, 0x22	; 34
    1672:	80 83       	st	Z, r24
	pxTopOfStack--;
    1674:	8b 81       	ldd	r24, Y+3	; 0x03
    1676:	9c 81       	ldd	r25, Y+4	; 0x04
    1678:	01 97       	sbiw	r24, 0x01	; 1
    167a:	9c 83       	std	Y+4, r25	; 0x04
    167c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    167e:	eb 81       	ldd	r30, Y+3	; 0x03
    1680:	fc 81       	ldd	r31, Y+4	; 0x04
    1682:	83 e2       	ldi	r24, 0x23	; 35
    1684:	80 83       	st	Z, r24
	pxTopOfStack--;
    1686:	8b 81       	ldd	r24, Y+3	; 0x03
    1688:	9c 81       	ldd	r25, Y+4	; 0x04
    168a:	01 97       	sbiw	r24, 0x01	; 1
    168c:	9c 83       	std	Y+4, r25	; 0x04
    168e:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    1690:	8f 81       	ldd	r24, Y+7	; 0x07
    1692:	98 85       	ldd	r25, Y+8	; 0x08
    1694:	9a 83       	std	Y+2, r25	; 0x02
    1696:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1698:	89 81       	ldd	r24, Y+1	; 0x01
    169a:	eb 81       	ldd	r30, Y+3	; 0x03
    169c:	fc 81       	ldd	r31, Y+4	; 0x04
    169e:	80 83       	st	Z, r24
	pxTopOfStack--;
    16a0:	8b 81       	ldd	r24, Y+3	; 0x03
    16a2:	9c 81       	ldd	r25, Y+4	; 0x04
    16a4:	01 97       	sbiw	r24, 0x01	; 1
    16a6:	9c 83       	std	Y+4, r25	; 0x04
    16a8:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    16aa:	89 81       	ldd	r24, Y+1	; 0x01
    16ac:	9a 81       	ldd	r25, Y+2	; 0x02
    16ae:	89 2f       	mov	r24, r25
    16b0:	99 27       	eor	r25, r25
    16b2:	9a 83       	std	Y+2, r25	; 0x02
    16b4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    16b6:	89 81       	ldd	r24, Y+1	; 0x01
    16b8:	eb 81       	ldd	r30, Y+3	; 0x03
    16ba:	fc 81       	ldd	r31, Y+4	; 0x04
    16bc:	80 83       	st	Z, r24
	pxTopOfStack--;
    16be:	8b 81       	ldd	r24, Y+3	; 0x03
    16c0:	9c 81       	ldd	r25, Y+4	; 0x04
    16c2:	01 97       	sbiw	r24, 0x01	; 1
    16c4:	9c 83       	std	Y+4, r25	; 0x04
    16c6:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    16c8:	eb 81       	ldd	r30, Y+3	; 0x03
    16ca:	fc 81       	ldd	r31, Y+4	; 0x04
    16cc:	86 e2       	ldi	r24, 0x26	; 38
    16ce:	80 83       	st	Z, r24
	pxTopOfStack--;
    16d0:	8b 81       	ldd	r24, Y+3	; 0x03
    16d2:	9c 81       	ldd	r25, Y+4	; 0x04
    16d4:	01 97       	sbiw	r24, 0x01	; 1
    16d6:	9c 83       	std	Y+4, r25	; 0x04
    16d8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    16da:	eb 81       	ldd	r30, Y+3	; 0x03
    16dc:	fc 81       	ldd	r31, Y+4	; 0x04
    16de:	87 e2       	ldi	r24, 0x27	; 39
    16e0:	80 83       	st	Z, r24
	pxTopOfStack--;
    16e2:	8b 81       	ldd	r24, Y+3	; 0x03
    16e4:	9c 81       	ldd	r25, Y+4	; 0x04
    16e6:	01 97       	sbiw	r24, 0x01	; 1
    16e8:	9c 83       	std	Y+4, r25	; 0x04
    16ea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    16ec:	eb 81       	ldd	r30, Y+3	; 0x03
    16ee:	fc 81       	ldd	r31, Y+4	; 0x04
    16f0:	88 e2       	ldi	r24, 0x28	; 40
    16f2:	80 83       	st	Z, r24
	pxTopOfStack--;
    16f4:	8b 81       	ldd	r24, Y+3	; 0x03
    16f6:	9c 81       	ldd	r25, Y+4	; 0x04
    16f8:	01 97       	sbiw	r24, 0x01	; 1
    16fa:	9c 83       	std	Y+4, r25	; 0x04
    16fc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    16fe:	eb 81       	ldd	r30, Y+3	; 0x03
    1700:	fc 81       	ldd	r31, Y+4	; 0x04
    1702:	89 e2       	ldi	r24, 0x29	; 41
    1704:	80 83       	st	Z, r24
	pxTopOfStack--;
    1706:	8b 81       	ldd	r24, Y+3	; 0x03
    1708:	9c 81       	ldd	r25, Y+4	; 0x04
    170a:	01 97       	sbiw	r24, 0x01	; 1
    170c:	9c 83       	std	Y+4, r25	; 0x04
    170e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    1710:	eb 81       	ldd	r30, Y+3	; 0x03
    1712:	fc 81       	ldd	r31, Y+4	; 0x04
    1714:	80 e3       	ldi	r24, 0x30	; 48
    1716:	80 83       	st	Z, r24
	pxTopOfStack--;
    1718:	8b 81       	ldd	r24, Y+3	; 0x03
    171a:	9c 81       	ldd	r25, Y+4	; 0x04
    171c:	01 97       	sbiw	r24, 0x01	; 1
    171e:	9c 83       	std	Y+4, r25	; 0x04
    1720:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    1722:	eb 81       	ldd	r30, Y+3	; 0x03
    1724:	fc 81       	ldd	r31, Y+4	; 0x04
    1726:	81 e3       	ldi	r24, 0x31	; 49
    1728:	80 83       	st	Z, r24
	pxTopOfStack--;
    172a:	8b 81       	ldd	r24, Y+3	; 0x03
    172c:	9c 81       	ldd	r25, Y+4	; 0x04
    172e:	01 97       	sbiw	r24, 0x01	; 1
    1730:	9c 83       	std	Y+4, r25	; 0x04
    1732:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    1734:	8b 81       	ldd	r24, Y+3	; 0x03
    1736:	9c 81       	ldd	r25, Y+4	; 0x04
}
    1738:	28 96       	adiw	r28, 0x08	; 8
    173a:	0f b6       	in	r0, 0x3f	; 63
    173c:	f8 94       	cli
    173e:	de bf       	out	0x3e, r29	; 62
    1740:	0f be       	out	0x3f, r0	; 63
    1742:	cd bf       	out	0x3d, r28	; 61
    1744:	cf 91       	pop	r28
    1746:	df 91       	pop	r29
    1748:	08 95       	ret

0000174a <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    174a:	df 93       	push	r29
    174c:	cf 93       	push	r28
    174e:	cd b7       	in	r28, 0x3d	; 61
    1750:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    1752:	0e 94 95 0c 	call	0x192a	; 0x192a <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1756:	a0 91 f4 06 	lds	r26, 0x06F4
    175a:	b0 91 f5 06 	lds	r27, 0x06F5
    175e:	cd 91       	ld	r28, X+
    1760:	cd bf       	out	0x3d, r28	; 61
    1762:	dd 91       	ld	r29, X+
    1764:	de bf       	out	0x3e, r29	; 62
    1766:	ff 91       	pop	r31
    1768:	ef 91       	pop	r30
    176a:	df 91       	pop	r29
    176c:	cf 91       	pop	r28
    176e:	bf 91       	pop	r27
    1770:	af 91       	pop	r26
    1772:	9f 91       	pop	r25
    1774:	8f 91       	pop	r24
    1776:	7f 91       	pop	r23
    1778:	6f 91       	pop	r22
    177a:	5f 91       	pop	r21
    177c:	4f 91       	pop	r20
    177e:	3f 91       	pop	r19
    1780:	2f 91       	pop	r18
    1782:	1f 91       	pop	r17
    1784:	0f 91       	pop	r16
    1786:	ff 90       	pop	r15
    1788:	ef 90       	pop	r14
    178a:	df 90       	pop	r13
    178c:	cf 90       	pop	r12
    178e:	bf 90       	pop	r11
    1790:	af 90       	pop	r10
    1792:	9f 90       	pop	r9
    1794:	8f 90       	pop	r8
    1796:	7f 90       	pop	r7
    1798:	6f 90       	pop	r6
    179a:	5f 90       	pop	r5
    179c:	4f 90       	pop	r4
    179e:	3f 90       	pop	r3
    17a0:	2f 90       	pop	r2
    17a2:	1f 90       	pop	r1
    17a4:	0f 90       	pop	r0
    17a6:	0f be       	out	0x3f, r0	; 63
    17a8:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    17aa:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    17ac:	81 e0       	ldi	r24, 0x01	; 1
}
    17ae:	cf 91       	pop	r28
    17b0:	df 91       	pop	r29
    17b2:	08 95       	ret

000017b4 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    17b4:	df 93       	push	r29
    17b6:	cf 93       	push	r28
    17b8:	cd b7       	in	r28, 0x3d	; 61
    17ba:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    17bc:	cf 91       	pop	r28
    17be:	df 91       	pop	r29
    17c0:	08 95       	ret

000017c2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    17c2:	0f 92       	push	r0
    17c4:	0f b6       	in	r0, 0x3f	; 63
    17c6:	f8 94       	cli
    17c8:	0f 92       	push	r0
    17ca:	1f 92       	push	r1
    17cc:	11 24       	eor	r1, r1
    17ce:	2f 92       	push	r2
    17d0:	3f 92       	push	r3
    17d2:	4f 92       	push	r4
    17d4:	5f 92       	push	r5
    17d6:	6f 92       	push	r6
    17d8:	7f 92       	push	r7
    17da:	8f 92       	push	r8
    17dc:	9f 92       	push	r9
    17de:	af 92       	push	r10
    17e0:	bf 92       	push	r11
    17e2:	cf 92       	push	r12
    17e4:	df 92       	push	r13
    17e6:	ef 92       	push	r14
    17e8:	ff 92       	push	r15
    17ea:	0f 93       	push	r16
    17ec:	1f 93       	push	r17
    17ee:	2f 93       	push	r18
    17f0:	3f 93       	push	r19
    17f2:	4f 93       	push	r20
    17f4:	5f 93       	push	r21
    17f6:	6f 93       	push	r22
    17f8:	7f 93       	push	r23
    17fa:	8f 93       	push	r24
    17fc:	9f 93       	push	r25
    17fe:	af 93       	push	r26
    1800:	bf 93       	push	r27
    1802:	cf 93       	push	r28
    1804:	df 93       	push	r29
    1806:	ef 93       	push	r30
    1808:	ff 93       	push	r31
    180a:	a0 91 f4 06 	lds	r26, 0x06F4
    180e:	b0 91 f5 06 	lds	r27, 0x06F5
    1812:	0d b6       	in	r0, 0x3d	; 61
    1814:	0d 92       	st	X+, r0
    1816:	0e b6       	in	r0, 0x3e	; 62
    1818:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    181a:	0e 94 70 15 	call	0x2ae0	; 0x2ae0 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    181e:	a0 91 f4 06 	lds	r26, 0x06F4
    1822:	b0 91 f5 06 	lds	r27, 0x06F5
    1826:	cd 91       	ld	r28, X+
    1828:	cd bf       	out	0x3d, r28	; 61
    182a:	dd 91       	ld	r29, X+
    182c:	de bf       	out	0x3e, r29	; 62
    182e:	ff 91       	pop	r31
    1830:	ef 91       	pop	r30
    1832:	df 91       	pop	r29
    1834:	cf 91       	pop	r28
    1836:	bf 91       	pop	r27
    1838:	af 91       	pop	r26
    183a:	9f 91       	pop	r25
    183c:	8f 91       	pop	r24
    183e:	7f 91       	pop	r23
    1840:	6f 91       	pop	r22
    1842:	5f 91       	pop	r21
    1844:	4f 91       	pop	r20
    1846:	3f 91       	pop	r19
    1848:	2f 91       	pop	r18
    184a:	1f 91       	pop	r17
    184c:	0f 91       	pop	r16
    184e:	ff 90       	pop	r15
    1850:	ef 90       	pop	r14
    1852:	df 90       	pop	r13
    1854:	cf 90       	pop	r12
    1856:	bf 90       	pop	r11
    1858:	af 90       	pop	r10
    185a:	9f 90       	pop	r9
    185c:	8f 90       	pop	r8
    185e:	7f 90       	pop	r7
    1860:	6f 90       	pop	r6
    1862:	5f 90       	pop	r5
    1864:	4f 90       	pop	r4
    1866:	3f 90       	pop	r3
    1868:	2f 90       	pop	r2
    186a:	1f 90       	pop	r1
    186c:	0f 90       	pop	r0
    186e:	0f be       	out	0x3f, r0	; 63
    1870:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1872:	08 95       	ret

00001874 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1874:	0f 92       	push	r0
    1876:	0f b6       	in	r0, 0x3f	; 63
    1878:	f8 94       	cli
    187a:	0f 92       	push	r0
    187c:	1f 92       	push	r1
    187e:	11 24       	eor	r1, r1
    1880:	2f 92       	push	r2
    1882:	3f 92       	push	r3
    1884:	4f 92       	push	r4
    1886:	5f 92       	push	r5
    1888:	6f 92       	push	r6
    188a:	7f 92       	push	r7
    188c:	8f 92       	push	r8
    188e:	9f 92       	push	r9
    1890:	af 92       	push	r10
    1892:	bf 92       	push	r11
    1894:	cf 92       	push	r12
    1896:	df 92       	push	r13
    1898:	ef 92       	push	r14
    189a:	ff 92       	push	r15
    189c:	0f 93       	push	r16
    189e:	1f 93       	push	r17
    18a0:	2f 93       	push	r18
    18a2:	3f 93       	push	r19
    18a4:	4f 93       	push	r20
    18a6:	5f 93       	push	r21
    18a8:	6f 93       	push	r22
    18aa:	7f 93       	push	r23
    18ac:	8f 93       	push	r24
    18ae:	9f 93       	push	r25
    18b0:	af 93       	push	r26
    18b2:	bf 93       	push	r27
    18b4:	cf 93       	push	r28
    18b6:	df 93       	push	r29
    18b8:	ef 93       	push	r30
    18ba:	ff 93       	push	r31
    18bc:	a0 91 f4 06 	lds	r26, 0x06F4
    18c0:	b0 91 f5 06 	lds	r27, 0x06F5
    18c4:	0d b6       	in	r0, 0x3d	; 61
    18c6:	0d 92       	st	X+, r0
    18c8:	0e b6       	in	r0, 0x3e	; 62
    18ca:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    18cc:	0e 94 9b 14 	call	0x2936	; 0x2936 <vTaskIncrementTick>
	vTaskSwitchContext();
    18d0:	0e 94 70 15 	call	0x2ae0	; 0x2ae0 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    18d4:	a0 91 f4 06 	lds	r26, 0x06F4
    18d8:	b0 91 f5 06 	lds	r27, 0x06F5
    18dc:	cd 91       	ld	r28, X+
    18de:	cd bf       	out	0x3d, r28	; 61
    18e0:	dd 91       	ld	r29, X+
    18e2:	de bf       	out	0x3e, r29	; 62
    18e4:	ff 91       	pop	r31
    18e6:	ef 91       	pop	r30
    18e8:	df 91       	pop	r29
    18ea:	cf 91       	pop	r28
    18ec:	bf 91       	pop	r27
    18ee:	af 91       	pop	r26
    18f0:	9f 91       	pop	r25
    18f2:	8f 91       	pop	r24
    18f4:	7f 91       	pop	r23
    18f6:	6f 91       	pop	r22
    18f8:	5f 91       	pop	r21
    18fa:	4f 91       	pop	r20
    18fc:	3f 91       	pop	r19
    18fe:	2f 91       	pop	r18
    1900:	1f 91       	pop	r17
    1902:	0f 91       	pop	r16
    1904:	ff 90       	pop	r15
    1906:	ef 90       	pop	r14
    1908:	df 90       	pop	r13
    190a:	cf 90       	pop	r12
    190c:	bf 90       	pop	r11
    190e:	af 90       	pop	r10
    1910:	9f 90       	pop	r9
    1912:	8f 90       	pop	r8
    1914:	7f 90       	pop	r7
    1916:	6f 90       	pop	r6
    1918:	5f 90       	pop	r5
    191a:	4f 90       	pop	r4
    191c:	3f 90       	pop	r3
    191e:	2f 90       	pop	r2
    1920:	1f 90       	pop	r1
    1922:	0f 90       	pop	r0
    1924:	0f be       	out	0x3f, r0	; 63
    1926:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1928:	08 95       	ret

0000192a <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    192a:	df 93       	push	r29
    192c:	cf 93       	push	r28
    192e:	00 d0       	rcall	.+0      	; 0x1930 <prvSetupTimerInterrupt+0x6>
    1930:	00 d0       	rcall	.+0      	; 0x1932 <prvSetupTimerInterrupt+0x8>
    1932:	00 d0       	rcall	.+0      	; 0x1934 <prvSetupTimerInterrupt+0xa>
    1934:	cd b7       	in	r28, 0x3d	; 61
    1936:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    1938:	80 e4       	ldi	r24, 0x40	; 64
    193a:	9f e1       	ldi	r25, 0x1F	; 31
    193c:	a0 e0       	ldi	r26, 0x00	; 0
    193e:	b0 e0       	ldi	r27, 0x00	; 0
    1940:	8b 83       	std	Y+3, r24	; 0x03
    1942:	9c 83       	std	Y+4, r25	; 0x04
    1944:	ad 83       	std	Y+5, r26	; 0x05
    1946:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    1948:	8b 81       	ldd	r24, Y+3	; 0x03
    194a:	9c 81       	ldd	r25, Y+4	; 0x04
    194c:	ad 81       	ldd	r26, Y+5	; 0x05
    194e:	be 81       	ldd	r27, Y+6	; 0x06
    1950:	68 94       	set
    1952:	15 f8       	bld	r1, 5
    1954:	b6 95       	lsr	r27
    1956:	a7 95       	ror	r26
    1958:	97 95       	ror	r25
    195a:	87 95       	ror	r24
    195c:	16 94       	lsr	r1
    195e:	d1 f7       	brne	.-12     	; 0x1954 <prvSetupTimerInterrupt+0x2a>
    1960:	8b 83       	std	Y+3, r24	; 0x03
    1962:	9c 83       	std	Y+4, r25	; 0x04
    1964:	ad 83       	std	Y+5, r26	; 0x05
    1966:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    1968:	8b 81       	ldd	r24, Y+3	; 0x03
    196a:	9c 81       	ldd	r25, Y+4	; 0x04
    196c:	ad 81       	ldd	r26, Y+5	; 0x05
    196e:	be 81       	ldd	r27, Y+6	; 0x06
    1970:	01 97       	sbiw	r24, 0x01	; 1
    1972:	a1 09       	sbc	r26, r1
    1974:	b1 09       	sbc	r27, r1
    1976:	8b 83       	std	Y+3, r24	; 0x03
    1978:	9c 83       	std	Y+4, r25	; 0x04
    197a:	ad 83       	std	Y+5, r26	; 0x05
    197c:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    197e:	8b 81       	ldd	r24, Y+3	; 0x03
    1980:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    1982:	8b 81       	ldd	r24, Y+3	; 0x03
    1984:	9c 81       	ldd	r25, Y+4	; 0x04
    1986:	ad 81       	ldd	r26, Y+5	; 0x05
    1988:	be 81       	ldd	r27, Y+6	; 0x06
    198a:	89 2f       	mov	r24, r25
    198c:	9a 2f       	mov	r25, r26
    198e:	ab 2f       	mov	r26, r27
    1990:	bb 27       	eor	r27, r27
    1992:	8b 83       	std	Y+3, r24	; 0x03
    1994:	9c 83       	std	Y+4, r25	; 0x04
    1996:	ad 83       	std	Y+5, r26	; 0x05
    1998:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    199a:	8b 81       	ldd	r24, Y+3	; 0x03
    199c:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    199e:	eb e4       	ldi	r30, 0x4B	; 75
    19a0:	f0 e0       	ldi	r31, 0x00	; 0
    19a2:	8a 81       	ldd	r24, Y+2	; 0x02
    19a4:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    19a6:	ea e4       	ldi	r30, 0x4A	; 74
    19a8:	f0 e0       	ldi	r31, 0x00	; 0
    19aa:	89 81       	ldd	r24, Y+1	; 0x01
    19ac:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    19ae:	8b e0       	ldi	r24, 0x0B	; 11
    19b0:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    19b2:	ee e4       	ldi	r30, 0x4E	; 78
    19b4:	f0 e0       	ldi	r31, 0x00	; 0
    19b6:	89 81       	ldd	r24, Y+1	; 0x01
    19b8:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    19ba:	e9 e5       	ldi	r30, 0x59	; 89
    19bc:	f0 e0       	ldi	r31, 0x00	; 0
    19be:	80 81       	ld	r24, Z
    19c0:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    19c2:	89 81       	ldd	r24, Y+1	; 0x01
    19c4:	80 61       	ori	r24, 0x10	; 16
    19c6:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    19c8:	e9 e5       	ldi	r30, 0x59	; 89
    19ca:	f0 e0       	ldi	r31, 0x00	; 0
    19cc:	89 81       	ldd	r24, Y+1	; 0x01
    19ce:	80 83       	st	Z, r24
}
    19d0:	26 96       	adiw	r28, 0x06	; 6
    19d2:	0f b6       	in	r0, 0x3f	; 63
    19d4:	f8 94       	cli
    19d6:	de bf       	out	0x3e, r29	; 62
    19d8:	0f be       	out	0x3f, r0	; 63
    19da:	cd bf       	out	0x3d, r28	; 61
    19dc:	cf 91       	pop	r28
    19de:	df 91       	pop	r29
    19e0:	08 95       	ret

000019e2 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    19e2:	0e 94 3a 0c 	call	0x1874	; 0x1874 <vPortYieldFromTick>
		asm volatile ( "reti" );
    19e6:	18 95       	reti

000019e8 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    19e8:	df 93       	push	r29
    19ea:	cf 93       	push	r28
    19ec:	cd b7       	in	r28, 0x3d	; 61
    19ee:	de b7       	in	r29, 0x3e	; 62
    19f0:	28 97       	sbiw	r28, 0x08	; 8
    19f2:	0f b6       	in	r0, 0x3f	; 63
    19f4:	f8 94       	cli
    19f6:	de bf       	out	0x3e, r29	; 62
    19f8:	0f be       	out	0x3f, r0	; 63
    19fa:	cd bf       	out	0x3d, r28	; 61
    19fc:	8f 83       	std	Y+7, r24	; 0x07
    19fe:	68 87       	std	Y+8, r22	; 0x08
	xQUEUE *pxNewQueue;
	size_t xQueueSizeInBytes;
	xQueueHandle xReturn = NULL;
    1a00:	1a 82       	std	Y+2, r1	; 0x02
    1a02:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    1a04:	8f 81       	ldd	r24, Y+7	; 0x07
    1a06:	88 23       	and	r24, r24
    1a08:	09 f4       	brne	.+2      	; 0x1a0c <xQueueCreate+0x24>
    1a0a:	8c c0       	rjmp	.+280    	; 0x1b24 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1a0c:	8f e1       	ldi	r24, 0x1F	; 31
    1a0e:	90 e0       	ldi	r25, 0x00	; 0
    1a10:	0e 94 7b 08 	call	0x10f6	; 0x10f6 <pvPortMalloc>
    1a14:	9e 83       	std	Y+6, r25	; 0x06
    1a16:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    1a18:	8d 81       	ldd	r24, Y+5	; 0x05
    1a1a:	9e 81       	ldd	r25, Y+6	; 0x06
    1a1c:	00 97       	sbiw	r24, 0x00	; 0
    1a1e:	09 f4       	brne	.+2      	; 0x1a22 <xQueueCreate+0x3a>
    1a20:	81 c0       	rjmp	.+258    	; 0x1b24 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    1a22:	8f 81       	ldd	r24, Y+7	; 0x07
    1a24:	28 2f       	mov	r18, r24
    1a26:	30 e0       	ldi	r19, 0x00	; 0
    1a28:	88 85       	ldd	r24, Y+8	; 0x08
    1a2a:	88 2f       	mov	r24, r24
    1a2c:	90 e0       	ldi	r25, 0x00	; 0
    1a2e:	ac 01       	movw	r20, r24
    1a30:	24 9f       	mul	r18, r20
    1a32:	c0 01       	movw	r24, r0
    1a34:	25 9f       	mul	r18, r21
    1a36:	90 0d       	add	r25, r0
    1a38:	34 9f       	mul	r19, r20
    1a3a:	90 0d       	add	r25, r0
    1a3c:	11 24       	eor	r1, r1
    1a3e:	01 96       	adiw	r24, 0x01	; 1
    1a40:	9c 83       	std	Y+4, r25	; 0x04
    1a42:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    1a44:	8b 81       	ldd	r24, Y+3	; 0x03
    1a46:	9c 81       	ldd	r25, Y+4	; 0x04
    1a48:	0e 94 7b 08 	call	0x10f6	; 0x10f6 <pvPortMalloc>
    1a4c:	ed 81       	ldd	r30, Y+5	; 0x05
    1a4e:	fe 81       	ldd	r31, Y+6	; 0x06
    1a50:	91 83       	std	Z+1, r25	; 0x01
    1a52:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    1a54:	ed 81       	ldd	r30, Y+5	; 0x05
    1a56:	fe 81       	ldd	r31, Y+6	; 0x06
    1a58:	80 81       	ld	r24, Z
    1a5a:	91 81       	ldd	r25, Z+1	; 0x01
    1a5c:	00 97       	sbiw	r24, 0x00	; 0
    1a5e:	09 f4       	brne	.+2      	; 0x1a62 <xQueueCreate+0x7a>
    1a60:	5d c0       	rjmp	.+186    	; 0x1b1c <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    1a62:	ed 81       	ldd	r30, Y+5	; 0x05
    1a64:	fe 81       	ldd	r31, Y+6	; 0x06
    1a66:	40 81       	ld	r20, Z
    1a68:	51 81       	ldd	r21, Z+1	; 0x01
    1a6a:	8f 81       	ldd	r24, Y+7	; 0x07
    1a6c:	28 2f       	mov	r18, r24
    1a6e:	30 e0       	ldi	r19, 0x00	; 0
    1a70:	88 85       	ldd	r24, Y+8	; 0x08
    1a72:	88 2f       	mov	r24, r24
    1a74:	90 e0       	ldi	r25, 0x00	; 0
    1a76:	bc 01       	movw	r22, r24
    1a78:	26 9f       	mul	r18, r22
    1a7a:	c0 01       	movw	r24, r0
    1a7c:	27 9f       	mul	r18, r23
    1a7e:	90 0d       	add	r25, r0
    1a80:	36 9f       	mul	r19, r22
    1a82:	90 0d       	add	r25, r0
    1a84:	11 24       	eor	r1, r1
    1a86:	84 0f       	add	r24, r20
    1a88:	95 1f       	adc	r25, r21
    1a8a:	ed 81       	ldd	r30, Y+5	; 0x05
    1a8c:	fe 81       	ldd	r31, Y+6	; 0x06
    1a8e:	93 83       	std	Z+3, r25	; 0x03
    1a90:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1a92:	ed 81       	ldd	r30, Y+5	; 0x05
    1a94:	fe 81       	ldd	r31, Y+6	; 0x06
    1a96:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    1a98:	ed 81       	ldd	r30, Y+5	; 0x05
    1a9a:	fe 81       	ldd	r31, Y+6	; 0x06
    1a9c:	80 81       	ld	r24, Z
    1a9e:	91 81       	ldd	r25, Z+1	; 0x01
    1aa0:	ed 81       	ldd	r30, Y+5	; 0x05
    1aa2:	fe 81       	ldd	r31, Y+6	; 0x06
    1aa4:	95 83       	std	Z+5, r25	; 0x05
    1aa6:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    1aa8:	ed 81       	ldd	r30, Y+5	; 0x05
    1aaa:	fe 81       	ldd	r31, Y+6	; 0x06
    1aac:	40 81       	ld	r20, Z
    1aae:	51 81       	ldd	r21, Z+1	; 0x01
    1ab0:	8f 81       	ldd	r24, Y+7	; 0x07
    1ab2:	88 2f       	mov	r24, r24
    1ab4:	90 e0       	ldi	r25, 0x00	; 0
    1ab6:	9c 01       	movw	r18, r24
    1ab8:	21 50       	subi	r18, 0x01	; 1
    1aba:	30 40       	sbci	r19, 0x00	; 0
    1abc:	88 85       	ldd	r24, Y+8	; 0x08
    1abe:	88 2f       	mov	r24, r24
    1ac0:	90 e0       	ldi	r25, 0x00	; 0
    1ac2:	bc 01       	movw	r22, r24
    1ac4:	26 9f       	mul	r18, r22
    1ac6:	c0 01       	movw	r24, r0
    1ac8:	27 9f       	mul	r18, r23
    1aca:	90 0d       	add	r25, r0
    1acc:	36 9f       	mul	r19, r22
    1ace:	90 0d       	add	r25, r0
    1ad0:	11 24       	eor	r1, r1
    1ad2:	84 0f       	add	r24, r20
    1ad4:	95 1f       	adc	r25, r21
    1ad6:	ed 81       	ldd	r30, Y+5	; 0x05
    1ad8:	fe 81       	ldd	r31, Y+6	; 0x06
    1ada:	97 83       	std	Z+7, r25	; 0x07
    1adc:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    1ade:	ed 81       	ldd	r30, Y+5	; 0x05
    1ae0:	fe 81       	ldd	r31, Y+6	; 0x06
    1ae2:	8f 81       	ldd	r24, Y+7	; 0x07
    1ae4:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1ae6:	ed 81       	ldd	r30, Y+5	; 0x05
    1ae8:	fe 81       	ldd	r31, Y+6	; 0x06
    1aea:	88 85       	ldd	r24, Y+8	; 0x08
    1aec:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    1aee:	ed 81       	ldd	r30, Y+5	; 0x05
    1af0:	fe 81       	ldd	r31, Y+6	; 0x06
    1af2:	8f ef       	ldi	r24, 0xFF	; 255
    1af4:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    1af6:	ed 81       	ldd	r30, Y+5	; 0x05
    1af8:	fe 81       	ldd	r31, Y+6	; 0x06
    1afa:	8f ef       	ldi	r24, 0xFF	; 255
    1afc:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1afe:	8d 81       	ldd	r24, Y+5	; 0x05
    1b00:	9e 81       	ldd	r25, Y+6	; 0x06
    1b02:	08 96       	adiw	r24, 0x08	; 8
    1b04:	0e 94 e7 08 	call	0x11ce	; 0x11ce <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1b08:	8d 81       	ldd	r24, Y+5	; 0x05
    1b0a:	9e 81       	ldd	r25, Y+6	; 0x06
    1b0c:	41 96       	adiw	r24, 0x11	; 17
    1b0e:	0e 94 e7 08 	call	0x11ce	; 0x11ce <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    1b12:	8d 81       	ldd	r24, Y+5	; 0x05
    1b14:	9e 81       	ldd	r25, Y+6	; 0x06
    1b16:	9a 83       	std	Y+2, r25	; 0x02
    1b18:	89 83       	std	Y+1, r24	; 0x01
    1b1a:	04 c0       	rjmp	.+8      	; 0x1b24 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    1b1c:	8d 81       	ldd	r24, Y+5	; 0x05
    1b1e:	9e 81       	ldd	r25, Y+6	; 0x06
    1b20:	0e 94 c1 08 	call	0x1182	; 0x1182 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    1b24:	89 81       	ldd	r24, Y+1	; 0x01
    1b26:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1b28:	28 96       	adiw	r28, 0x08	; 8
    1b2a:	0f b6       	in	r0, 0x3f	; 63
    1b2c:	f8 94       	cli
    1b2e:	de bf       	out	0x3e, r29	; 62
    1b30:	0f be       	out	0x3f, r0	; 63
    1b32:	cd bf       	out	0x3d, r28	; 61
    1b34:	cf 91       	pop	r28
    1b36:	df 91       	pop	r29
    1b38:	08 95       	ret

00001b3a <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if configUSE_COUNTING_SEMAPHORES == 1

xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
{
    1b3a:	df 93       	push	r29
    1b3c:	cf 93       	push	r28
    1b3e:	00 d0       	rcall	.+0      	; 0x1b40 <xQueueCreateCountingSemaphore+0x6>
    1b40:	00 d0       	rcall	.+0      	; 0x1b42 <xQueueCreateCountingSemaphore+0x8>
    1b42:	cd b7       	in	r28, 0x3d	; 61
    1b44:	de b7       	in	r29, 0x3e	; 62
    1b46:	8b 83       	std	Y+3, r24	; 0x03
    1b48:	6c 83       	std	Y+4, r22	; 0x04
	xQueueHandle pxHandle;

	pxHandle = xQueueCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH );
    1b4a:	8b 81       	ldd	r24, Y+3	; 0x03
    1b4c:	60 e0       	ldi	r22, 0x00	; 0
    1b4e:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <xQueueCreate>
    1b52:	9a 83       	std	Y+2, r25	; 0x02
    1b54:	89 83       	std	Y+1, r24	; 0x01

	if( pxHandle != NULL )
    1b56:	89 81       	ldd	r24, Y+1	; 0x01
    1b58:	9a 81       	ldd	r25, Y+2	; 0x02
    1b5a:	00 97       	sbiw	r24, 0x00	; 0
    1b5c:	21 f0       	breq	.+8      	; 0x1b66 <xQueueCreateCountingSemaphore+0x2c>
	{
		pxHandle->uxMessagesWaiting = uxInitialCount;
    1b5e:	e9 81       	ldd	r30, Y+1	; 0x01
    1b60:	fa 81       	ldd	r31, Y+2	; 0x02
    1b62:	8c 81       	ldd	r24, Y+4	; 0x04
    1b64:	82 8f       	std	Z+26, r24	; 0x1a
	{
		traceCREATE_COUNTING_SEMAPHORE_FAILED();
	}

	configASSERT( pxHandle );
	return pxHandle;
    1b66:	89 81       	ldd	r24, Y+1	; 0x01
    1b68:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1b6a:	0f 90       	pop	r0
    1b6c:	0f 90       	pop	r0
    1b6e:	0f 90       	pop	r0
    1b70:	0f 90       	pop	r0
    1b72:	cf 91       	pop	r28
    1b74:	df 91       	pop	r29
    1b76:	08 95       	ret

00001b78 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1b78:	df 93       	push	r29
    1b7a:	cf 93       	push	r28
    1b7c:	cd b7       	in	r28, 0x3d	; 61
    1b7e:	de b7       	in	r29, 0x3e	; 62
    1b80:	2c 97       	sbiw	r28, 0x0c	; 12
    1b82:	0f b6       	in	r0, 0x3f	; 63
    1b84:	f8 94       	cli
    1b86:	de bf       	out	0x3e, r29	; 62
    1b88:	0f be       	out	0x3f, r0	; 63
    1b8a:	cd bf       	out	0x3d, r28	; 61
    1b8c:	9e 83       	std	Y+6, r25	; 0x06
    1b8e:	8d 83       	std	Y+5, r24	; 0x05
    1b90:	78 87       	std	Y+8, r23	; 0x08
    1b92:	6f 83       	std	Y+7, r22	; 0x07
    1b94:	5a 87       	std	Y+10, r21	; 0x0a
    1b96:	49 87       	std	Y+9, r20	; 0x09
    1b98:	2b 87       	std	Y+11, r18	; 0x0b
	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1b9a:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1b9c:	0f b6       	in	r0, 0x3f	; 63
    1b9e:	f8 94       	cli
    1ba0:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1ba2:	ed 81       	ldd	r30, Y+5	; 0x05
    1ba4:	fe 81       	ldd	r31, Y+6	; 0x06
    1ba6:	92 8d       	ldd	r25, Z+26	; 0x1a
    1ba8:	ed 81       	ldd	r30, Y+5	; 0x05
    1baa:	fe 81       	ldd	r31, Y+6	; 0x06
    1bac:	83 8d       	ldd	r24, Z+27	; 0x1b
    1bae:	98 17       	cp	r25, r24
    1bb0:	d8 f4       	brcc	.+54     	; 0x1be8 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1bb2:	8d 81       	ldd	r24, Y+5	; 0x05
    1bb4:	9e 81       	ldd	r25, Y+6	; 0x06
    1bb6:	2f 81       	ldd	r18, Y+7	; 0x07
    1bb8:	38 85       	ldd	r19, Y+8	; 0x08
    1bba:	b9 01       	movw	r22, r18
    1bbc:	4b 85       	ldd	r20, Y+11	; 0x0b
    1bbe:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1bc2:	ed 81       	ldd	r30, Y+5	; 0x05
    1bc4:	fe 81       	ldd	r31, Y+6	; 0x06
    1bc6:	81 89       	ldd	r24, Z+17	; 0x11
    1bc8:	88 23       	and	r24, r24
    1bca:	49 f0       	breq	.+18     	; 0x1bde <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1bcc:	8d 81       	ldd	r24, Y+5	; 0x05
    1bce:	9e 81       	ldd	r25, Y+6	; 0x06
    1bd0:	41 96       	adiw	r24, 0x11	; 17
    1bd2:	0e 94 0c 16 	call	0x2c18	; 0x2c18 <xTaskRemoveFromEventList>
    1bd6:	81 30       	cpi	r24, 0x01	; 1
    1bd8:	11 f4       	brne	.+4      	; 0x1bde <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    1bda:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    1bde:	0f 90       	pop	r0
    1be0:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    1be2:	81 e0       	ldi	r24, 0x01	; 1
    1be4:	8c 87       	std	Y+12, r24	; 0x0c
    1be6:	5c c0       	rjmp	.+184    	; 0x1ca0 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1be8:	89 85       	ldd	r24, Y+9	; 0x09
    1bea:	9a 85       	ldd	r25, Y+10	; 0x0a
    1bec:	00 97       	sbiw	r24, 0x00	; 0
    1bee:	21 f4       	brne	.+8      	; 0x1bf8 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1bf0:	0f 90       	pop	r0
    1bf2:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1bf4:	1c 86       	std	Y+12, r1	; 0x0c
    1bf6:	54 c0       	rjmp	.+168    	; 0x1ca0 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    1bf8:	89 81       	ldd	r24, Y+1	; 0x01
    1bfa:	88 23       	and	r24, r24
    1bfc:	31 f4       	brne	.+12     	; 0x1c0a <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1bfe:	ce 01       	movw	r24, r28
    1c00:	02 96       	adiw	r24, 0x02	; 2
    1c02:	0e 94 74 16 	call	0x2ce8	; 0x2ce8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1c06:	81 e0       	ldi	r24, 0x01	; 1
    1c08:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    1c0a:	0f 90       	pop	r0
    1c0c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1c0e:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1c12:	0f b6       	in	r0, 0x3f	; 63
    1c14:	f8 94       	cli
    1c16:	0f 92       	push	r0
    1c18:	ed 81       	ldd	r30, Y+5	; 0x05
    1c1a:	fe 81       	ldd	r31, Y+6	; 0x06
    1c1c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c1e:	8f 3f       	cpi	r24, 0xFF	; 255
    1c20:	19 f4       	brne	.+6      	; 0x1c28 <xQueueGenericSend+0xb0>
    1c22:	ed 81       	ldd	r30, Y+5	; 0x05
    1c24:	fe 81       	ldd	r31, Y+6	; 0x06
    1c26:	15 8e       	std	Z+29, r1	; 0x1d
    1c28:	ed 81       	ldd	r30, Y+5	; 0x05
    1c2a:	fe 81       	ldd	r31, Y+6	; 0x06
    1c2c:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c2e:	8f 3f       	cpi	r24, 0xFF	; 255
    1c30:	19 f4       	brne	.+6      	; 0x1c38 <xQueueGenericSend+0xc0>
    1c32:	ed 81       	ldd	r30, Y+5	; 0x05
    1c34:	fe 81       	ldd	r31, Y+6	; 0x06
    1c36:	16 8e       	std	Z+30, r1	; 0x1e
    1c38:	0f 90       	pop	r0
    1c3a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1c3c:	ce 01       	movw	r24, r28
    1c3e:	02 96       	adiw	r24, 0x02	; 2
    1c40:	9e 01       	movw	r18, r28
    1c42:	27 5f       	subi	r18, 0xF7	; 247
    1c44:	3f 4f       	sbci	r19, 0xFF	; 255
    1c46:	b9 01       	movw	r22, r18
    1c48:	0e 94 8d 16 	call	0x2d1a	; 0x2d1a <xTaskCheckForTimeOut>
    1c4c:	88 23       	and	r24, r24
    1c4e:	09 f5       	brne	.+66     	; 0x1c92 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1c50:	8d 81       	ldd	r24, Y+5	; 0x05
    1c52:	9e 81       	ldd	r25, Y+6	; 0x06
    1c54:	0e 94 5b 11 	call	0x22b6	; 0x22b6 <prvIsQueueFull>
    1c58:	88 23       	and	r24, r24
    1c5a:	a1 f0       	breq	.+40     	; 0x1c84 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1c5c:	8d 81       	ldd	r24, Y+5	; 0x05
    1c5e:	9e 81       	ldd	r25, Y+6	; 0x06
    1c60:	08 96       	adiw	r24, 0x08	; 8
    1c62:	29 85       	ldd	r18, Y+9	; 0x09
    1c64:	3a 85       	ldd	r19, Y+10	; 0x0a
    1c66:	b9 01       	movw	r22, r18
    1c68:	0e 94 d6 15 	call	0x2bac	; 0x2bac <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1c6c:	8d 81       	ldd	r24, Y+5	; 0x05
    1c6e:	9e 81       	ldd	r25, Y+6	; 0x06
    1c70:	0e 94 d4 10 	call	0x21a8	; 0x21a8 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1c74:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <xTaskResumeAll>
    1c78:	88 23       	and	r24, r24
    1c7a:	09 f0       	breq	.+2      	; 0x1c7e <xQueueGenericSend+0x106>
    1c7c:	8f cf       	rjmp	.-226    	; 0x1b9c <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    1c7e:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <vPortYield>
    1c82:	8c cf       	rjmp	.-232    	; 0x1b9c <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1c84:	8d 81       	ldd	r24, Y+5	; 0x05
    1c86:	9e 81       	ldd	r25, Y+6	; 0x06
    1c88:	0e 94 d4 10 	call	0x21a8	; 0x21a8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1c8c:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <xTaskResumeAll>
    1c90:	85 cf       	rjmp	.-246    	; 0x1b9c <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1c92:	8d 81       	ldd	r24, Y+5	; 0x05
    1c94:	9e 81       	ldd	r25, Y+6	; 0x06
    1c96:	0e 94 d4 10 	call	0x21a8	; 0x21a8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1c9a:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1c9e:	1c 86       	std	Y+12, r1	; 0x0c
    1ca0:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    1ca2:	2c 96       	adiw	r28, 0x0c	; 12
    1ca4:	0f b6       	in	r0, 0x3f	; 63
    1ca6:	f8 94       	cli
    1ca8:	de bf       	out	0x3e, r29	; 62
    1caa:	0f be       	out	0x3f, r0	; 63
    1cac:	cd bf       	out	0x3d, r28	; 61
    1cae:	cf 91       	pop	r28
    1cb0:	df 91       	pop	r29
    1cb2:	08 95       	ret

00001cb4 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1cb4:	df 93       	push	r29
    1cb6:	cf 93       	push	r28
    1cb8:	cd b7       	in	r28, 0x3d	; 61
    1cba:	de b7       	in	r29, 0x3e	; 62
    1cbc:	29 97       	sbiw	r28, 0x09	; 9
    1cbe:	0f b6       	in	r0, 0x3f	; 63
    1cc0:	f8 94       	cli
    1cc2:	de bf       	out	0x3e, r29	; 62
    1cc4:	0f be       	out	0x3f, r0	; 63
    1cc6:	cd bf       	out	0x3d, r28	; 61
    1cc8:	9c 83       	std	Y+4, r25	; 0x04
    1cca:	8b 83       	std	Y+3, r24	; 0x03
    1ccc:	7e 83       	std	Y+6, r23	; 0x06
    1cce:	6d 83       	std	Y+5, r22	; 0x05
    1cd0:	58 87       	std	Y+8, r21	; 0x08
    1cd2:	4f 83       	std	Y+7, r20	; 0x07
    1cd4:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1cd6:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1cd8:	eb 81       	ldd	r30, Y+3	; 0x03
    1cda:	fc 81       	ldd	r31, Y+4	; 0x04
    1cdc:	92 8d       	ldd	r25, Z+26	; 0x1a
    1cde:	eb 81       	ldd	r30, Y+3	; 0x03
    1ce0:	fc 81       	ldd	r31, Y+4	; 0x04
    1ce2:	83 8d       	ldd	r24, Z+27	; 0x1b
    1ce4:	98 17       	cp	r25, r24
    1ce6:	40 f5       	brcc	.+80     	; 0x1d38 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1ce8:	8b 81       	ldd	r24, Y+3	; 0x03
    1cea:	9c 81       	ldd	r25, Y+4	; 0x04
    1cec:	2d 81       	ldd	r18, Y+5	; 0x05
    1cee:	3e 81       	ldd	r19, Y+6	; 0x06
    1cf0:	b9 01       	movw	r22, r18
    1cf2:	49 85       	ldd	r20, Y+9	; 0x09
    1cf4:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1cf8:	eb 81       	ldd	r30, Y+3	; 0x03
    1cfa:	fc 81       	ldd	r31, Y+4	; 0x04
    1cfc:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cfe:	8f 3f       	cpi	r24, 0xFF	; 255
    1d00:	89 f4       	brne	.+34     	; 0x1d24 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1d02:	eb 81       	ldd	r30, Y+3	; 0x03
    1d04:	fc 81       	ldd	r31, Y+4	; 0x04
    1d06:	81 89       	ldd	r24, Z+17	; 0x11
    1d08:	88 23       	and	r24, r24
    1d0a:	99 f0       	breq	.+38     	; 0x1d32 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1d0c:	8b 81       	ldd	r24, Y+3	; 0x03
    1d0e:	9c 81       	ldd	r25, Y+4	; 0x04
    1d10:	41 96       	adiw	r24, 0x11	; 17
    1d12:	0e 94 0c 16 	call	0x2c18	; 0x2c18 <xTaskRemoveFromEventList>
    1d16:	88 23       	and	r24, r24
    1d18:	61 f0       	breq	.+24     	; 0x1d32 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    1d1a:	ef 81       	ldd	r30, Y+7	; 0x07
    1d1c:	f8 85       	ldd	r31, Y+8	; 0x08
    1d1e:	81 e0       	ldi	r24, 0x01	; 1
    1d20:	80 83       	st	Z, r24
    1d22:	07 c0       	rjmp	.+14     	; 0x1d32 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1d24:	eb 81       	ldd	r30, Y+3	; 0x03
    1d26:	fc 81       	ldd	r31, Y+4	; 0x04
    1d28:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d2a:	8f 5f       	subi	r24, 0xFF	; 255
    1d2c:	eb 81       	ldd	r30, Y+3	; 0x03
    1d2e:	fc 81       	ldd	r31, Y+4	; 0x04
    1d30:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1d32:	81 e0       	ldi	r24, 0x01	; 1
    1d34:	8a 83       	std	Y+2, r24	; 0x02
    1d36:	01 c0       	rjmp	.+2      	; 0x1d3a <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1d38:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1d3a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1d3c:	29 96       	adiw	r28, 0x09	; 9
    1d3e:	0f b6       	in	r0, 0x3f	; 63
    1d40:	f8 94       	cli
    1d42:	de bf       	out	0x3e, r29	; 62
    1d44:	0f be       	out	0x3f, r0	; 63
    1d46:	cd bf       	out	0x3d, r28	; 61
    1d48:	cf 91       	pop	r28
    1d4a:	df 91       	pop	r29
    1d4c:	08 95       	ret

00001d4e <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1d4e:	df 93       	push	r29
    1d50:	cf 93       	push	r28
    1d52:	cd b7       	in	r28, 0x3d	; 61
    1d54:	de b7       	in	r29, 0x3e	; 62
    1d56:	2e 97       	sbiw	r28, 0x0e	; 14
    1d58:	0f b6       	in	r0, 0x3f	; 63
    1d5a:	f8 94       	cli
    1d5c:	de bf       	out	0x3e, r29	; 62
    1d5e:	0f be       	out	0x3f, r0	; 63
    1d60:	cd bf       	out	0x3d, r28	; 61
    1d62:	98 87       	std	Y+8, r25	; 0x08
    1d64:	8f 83       	std	Y+7, r24	; 0x07
    1d66:	7a 87       	std	Y+10, r23	; 0x0a
    1d68:	69 87       	std	Y+9, r22	; 0x09
    1d6a:	5c 87       	std	Y+12, r21	; 0x0c
    1d6c:	4b 87       	std	Y+11, r20	; 0x0b
    1d6e:	2d 87       	std	Y+13, r18	; 0x0d
	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1d70:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1d72:	0f b6       	in	r0, 0x3f	; 63
    1d74:	f8 94       	cli
    1d76:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1d78:	ef 81       	ldd	r30, Y+7	; 0x07
    1d7a:	f8 85       	ldd	r31, Y+8	; 0x08
    1d7c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d7e:	88 23       	and	r24, r24
    1d80:	09 f4       	brne	.+2      	; 0x1d84 <xQueueGenericReceive+0x36>
    1d82:	3f c0       	rjmp	.+126    	; 0x1e02 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1d84:	ef 81       	ldd	r30, Y+7	; 0x07
    1d86:	f8 85       	ldd	r31, Y+8	; 0x08
    1d88:	86 81       	ldd	r24, Z+6	; 0x06
    1d8a:	97 81       	ldd	r25, Z+7	; 0x07
    1d8c:	9a 83       	std	Y+2, r25	; 0x02
    1d8e:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1d90:	8f 81       	ldd	r24, Y+7	; 0x07
    1d92:	98 85       	ldd	r25, Y+8	; 0x08
    1d94:	29 85       	ldd	r18, Y+9	; 0x09
    1d96:	3a 85       	ldd	r19, Y+10	; 0x0a
    1d98:	b9 01       	movw	r22, r18
    1d9a:	0e 94 8c 10 	call	0x2118	; 0x2118 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1d9e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1da0:	88 23       	and	r24, r24
    1da2:	b1 f4       	brne	.+44     	; 0x1dd0 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1da4:	ef 81       	ldd	r30, Y+7	; 0x07
    1da6:	f8 85       	ldd	r31, Y+8	; 0x08
    1da8:	82 8d       	ldd	r24, Z+26	; 0x1a
    1daa:	81 50       	subi	r24, 0x01	; 1
    1dac:	ef 81       	ldd	r30, Y+7	; 0x07
    1dae:	f8 85       	ldd	r31, Y+8	; 0x08
    1db0:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1db2:	ef 81       	ldd	r30, Y+7	; 0x07
    1db4:	f8 85       	ldd	r31, Y+8	; 0x08
    1db6:	80 85       	ldd	r24, Z+8	; 0x08
    1db8:	88 23       	and	r24, r24
    1dba:	f1 f0       	breq	.+60     	; 0x1df8 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1dbc:	8f 81       	ldd	r24, Y+7	; 0x07
    1dbe:	98 85       	ldd	r25, Y+8	; 0x08
    1dc0:	08 96       	adiw	r24, 0x08	; 8
    1dc2:	0e 94 0c 16 	call	0x2c18	; 0x2c18 <xTaskRemoveFromEventList>
    1dc6:	81 30       	cpi	r24, 0x01	; 1
    1dc8:	b9 f4       	brne	.+46     	; 0x1df8 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    1dca:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <vPortYield>
    1dce:	14 c0       	rjmp	.+40     	; 0x1df8 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1dd0:	ef 81       	ldd	r30, Y+7	; 0x07
    1dd2:	f8 85       	ldd	r31, Y+8	; 0x08
    1dd4:	89 81       	ldd	r24, Y+1	; 0x01
    1dd6:	9a 81       	ldd	r25, Y+2	; 0x02
    1dd8:	97 83       	std	Z+7, r25	; 0x07
    1dda:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1ddc:	ef 81       	ldd	r30, Y+7	; 0x07
    1dde:	f8 85       	ldd	r31, Y+8	; 0x08
    1de0:	81 89       	ldd	r24, Z+17	; 0x11
    1de2:	88 23       	and	r24, r24
    1de4:	49 f0       	breq	.+18     	; 0x1df8 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1de6:	8f 81       	ldd	r24, Y+7	; 0x07
    1de8:	98 85       	ldd	r25, Y+8	; 0x08
    1dea:	41 96       	adiw	r24, 0x11	; 17
    1dec:	0e 94 0c 16 	call	0x2c18	; 0x2c18 <xTaskRemoveFromEventList>
    1df0:	88 23       	and	r24, r24
    1df2:	11 f0       	breq	.+4      	; 0x1df8 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1df4:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    1df8:	0f 90       	pop	r0
    1dfa:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1dfc:	81 e0       	ldi	r24, 0x01	; 1
    1dfe:	8e 87       	std	Y+14, r24	; 0x0e
    1e00:	5c c0       	rjmp	.+184    	; 0x1eba <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1e02:	8b 85       	ldd	r24, Y+11	; 0x0b
    1e04:	9c 85       	ldd	r25, Y+12	; 0x0c
    1e06:	00 97       	sbiw	r24, 0x00	; 0
    1e08:	21 f4       	brne	.+8      	; 0x1e12 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1e0a:	0f 90       	pop	r0
    1e0c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1e0e:	1e 86       	std	Y+14, r1	; 0x0e
    1e10:	54 c0       	rjmp	.+168    	; 0x1eba <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    1e12:	8b 81       	ldd	r24, Y+3	; 0x03
    1e14:	88 23       	and	r24, r24
    1e16:	31 f4       	brne	.+12     	; 0x1e24 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1e18:	ce 01       	movw	r24, r28
    1e1a:	04 96       	adiw	r24, 0x04	; 4
    1e1c:	0e 94 74 16 	call	0x2ce8	; 0x2ce8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1e20:	81 e0       	ldi	r24, 0x01	; 1
    1e22:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    1e24:	0f 90       	pop	r0
    1e26:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1e28:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1e2c:	0f b6       	in	r0, 0x3f	; 63
    1e2e:	f8 94       	cli
    1e30:	0f 92       	push	r0
    1e32:	ef 81       	ldd	r30, Y+7	; 0x07
    1e34:	f8 85       	ldd	r31, Y+8	; 0x08
    1e36:	85 8d       	ldd	r24, Z+29	; 0x1d
    1e38:	8f 3f       	cpi	r24, 0xFF	; 255
    1e3a:	19 f4       	brne	.+6      	; 0x1e42 <xQueueGenericReceive+0xf4>
    1e3c:	ef 81       	ldd	r30, Y+7	; 0x07
    1e3e:	f8 85       	ldd	r31, Y+8	; 0x08
    1e40:	15 8e       	std	Z+29, r1	; 0x1d
    1e42:	ef 81       	ldd	r30, Y+7	; 0x07
    1e44:	f8 85       	ldd	r31, Y+8	; 0x08
    1e46:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e48:	8f 3f       	cpi	r24, 0xFF	; 255
    1e4a:	19 f4       	brne	.+6      	; 0x1e52 <xQueueGenericReceive+0x104>
    1e4c:	ef 81       	ldd	r30, Y+7	; 0x07
    1e4e:	f8 85       	ldd	r31, Y+8	; 0x08
    1e50:	16 8e       	std	Z+30, r1	; 0x1e
    1e52:	0f 90       	pop	r0
    1e54:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1e56:	ce 01       	movw	r24, r28
    1e58:	04 96       	adiw	r24, 0x04	; 4
    1e5a:	9e 01       	movw	r18, r28
    1e5c:	25 5f       	subi	r18, 0xF5	; 245
    1e5e:	3f 4f       	sbci	r19, 0xFF	; 255
    1e60:	b9 01       	movw	r22, r18
    1e62:	0e 94 8d 16 	call	0x2d1a	; 0x2d1a <xTaskCheckForTimeOut>
    1e66:	88 23       	and	r24, r24
    1e68:	09 f5       	brne	.+66     	; 0x1eac <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1e6a:	8f 81       	ldd	r24, Y+7	; 0x07
    1e6c:	98 85       	ldd	r25, Y+8	; 0x08
    1e6e:	0e 94 28 11 	call	0x2250	; 0x2250 <prvIsQueueEmpty>
    1e72:	88 23       	and	r24, r24
    1e74:	a1 f0       	breq	.+40     	; 0x1e9e <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1e76:	8f 81       	ldd	r24, Y+7	; 0x07
    1e78:	98 85       	ldd	r25, Y+8	; 0x08
    1e7a:	41 96       	adiw	r24, 0x11	; 17
    1e7c:	2b 85       	ldd	r18, Y+11	; 0x0b
    1e7e:	3c 85       	ldd	r19, Y+12	; 0x0c
    1e80:	b9 01       	movw	r22, r18
    1e82:	0e 94 d6 15 	call	0x2bac	; 0x2bac <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1e86:	8f 81       	ldd	r24, Y+7	; 0x07
    1e88:	98 85       	ldd	r25, Y+8	; 0x08
    1e8a:	0e 94 d4 10 	call	0x21a8	; 0x21a8 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1e8e:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <xTaskResumeAll>
    1e92:	88 23       	and	r24, r24
    1e94:	09 f0       	breq	.+2      	; 0x1e98 <xQueueGenericReceive+0x14a>
    1e96:	6d cf       	rjmp	.-294    	; 0x1d72 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    1e98:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <vPortYield>
    1e9c:	6a cf       	rjmp	.-300    	; 0x1d72 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1e9e:	8f 81       	ldd	r24, Y+7	; 0x07
    1ea0:	98 85       	ldd	r25, Y+8	; 0x08
    1ea2:	0e 94 d4 10 	call	0x21a8	; 0x21a8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1ea6:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <xTaskResumeAll>
    1eaa:	63 cf       	rjmp	.-314    	; 0x1d72 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1eac:	8f 81       	ldd	r24, Y+7	; 0x07
    1eae:	98 85       	ldd	r25, Y+8	; 0x08
    1eb0:	0e 94 d4 10 	call	0x21a8	; 0x21a8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1eb4:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1eb8:	1e 86       	std	Y+14, r1	; 0x0e
    1eba:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    1ebc:	2e 96       	adiw	r28, 0x0e	; 14
    1ebe:	0f b6       	in	r0, 0x3f	; 63
    1ec0:	f8 94       	cli
    1ec2:	de bf       	out	0x3e, r29	; 62
    1ec4:	0f be       	out	0x3f, r0	; 63
    1ec6:	cd bf       	out	0x3d, r28	; 61
    1ec8:	cf 91       	pop	r28
    1eca:	df 91       	pop	r29
    1ecc:	08 95       	ret

00001ece <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    1ece:	df 93       	push	r29
    1ed0:	cf 93       	push	r28
    1ed2:	cd b7       	in	r28, 0x3d	; 61
    1ed4:	de b7       	in	r29, 0x3e	; 62
    1ed6:	28 97       	sbiw	r28, 0x08	; 8
    1ed8:	0f b6       	in	r0, 0x3f	; 63
    1eda:	f8 94       	cli
    1edc:	de bf       	out	0x3e, r29	; 62
    1ede:	0f be       	out	0x3f, r0	; 63
    1ee0:	cd bf       	out	0x3d, r28	; 61
    1ee2:	9c 83       	std	Y+4, r25	; 0x04
    1ee4:	8b 83       	std	Y+3, r24	; 0x03
    1ee6:	7e 83       	std	Y+6, r23	; 0x06
    1ee8:	6d 83       	std	Y+5, r22	; 0x05
    1eea:	58 87       	std	Y+8, r21	; 0x08
    1eec:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1eee:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1ef0:	eb 81       	ldd	r30, Y+3	; 0x03
    1ef2:	fc 81       	ldd	r31, Y+4	; 0x04
    1ef4:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ef6:	88 23       	and	r24, r24
    1ef8:	71 f1       	breq	.+92     	; 0x1f56 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1efa:	8b 81       	ldd	r24, Y+3	; 0x03
    1efc:	9c 81       	ldd	r25, Y+4	; 0x04
    1efe:	2d 81       	ldd	r18, Y+5	; 0x05
    1f00:	3e 81       	ldd	r19, Y+6	; 0x06
    1f02:	b9 01       	movw	r22, r18
    1f04:	0e 94 8c 10 	call	0x2118	; 0x2118 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1f08:	eb 81       	ldd	r30, Y+3	; 0x03
    1f0a:	fc 81       	ldd	r31, Y+4	; 0x04
    1f0c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f0e:	81 50       	subi	r24, 0x01	; 1
    1f10:	eb 81       	ldd	r30, Y+3	; 0x03
    1f12:	fc 81       	ldd	r31, Y+4	; 0x04
    1f14:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1f16:	eb 81       	ldd	r30, Y+3	; 0x03
    1f18:	fc 81       	ldd	r31, Y+4	; 0x04
    1f1a:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f1c:	8f 3f       	cpi	r24, 0xFF	; 255
    1f1e:	89 f4       	brne	.+34     	; 0x1f42 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1f20:	eb 81       	ldd	r30, Y+3	; 0x03
    1f22:	fc 81       	ldd	r31, Y+4	; 0x04
    1f24:	80 85       	ldd	r24, Z+8	; 0x08
    1f26:	88 23       	and	r24, r24
    1f28:	99 f0       	breq	.+38     	; 0x1f50 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1f2a:	8b 81       	ldd	r24, Y+3	; 0x03
    1f2c:	9c 81       	ldd	r25, Y+4	; 0x04
    1f2e:	08 96       	adiw	r24, 0x08	; 8
    1f30:	0e 94 0c 16 	call	0x2c18	; 0x2c18 <xTaskRemoveFromEventList>
    1f34:	88 23       	and	r24, r24
    1f36:	61 f0       	breq	.+24     	; 0x1f50 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    1f38:	ef 81       	ldd	r30, Y+7	; 0x07
    1f3a:	f8 85       	ldd	r31, Y+8	; 0x08
    1f3c:	81 e0       	ldi	r24, 0x01	; 1
    1f3e:	80 83       	st	Z, r24
    1f40:	07 c0       	rjmp	.+14     	; 0x1f50 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1f42:	eb 81       	ldd	r30, Y+3	; 0x03
    1f44:	fc 81       	ldd	r31, Y+4	; 0x04
    1f46:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f48:	8f 5f       	subi	r24, 0xFF	; 255
    1f4a:	eb 81       	ldd	r30, Y+3	; 0x03
    1f4c:	fc 81       	ldd	r31, Y+4	; 0x04
    1f4e:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1f50:	81 e0       	ldi	r24, 0x01	; 1
    1f52:	8a 83       	std	Y+2, r24	; 0x02
    1f54:	01 c0       	rjmp	.+2      	; 0x1f58 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    1f56:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1f58:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1f5a:	28 96       	adiw	r28, 0x08	; 8
    1f5c:	0f b6       	in	r0, 0x3f	; 63
    1f5e:	f8 94       	cli
    1f60:	de bf       	out	0x3e, r29	; 62
    1f62:	0f be       	out	0x3f, r0	; 63
    1f64:	cd bf       	out	0x3d, r28	; 61
    1f66:	cf 91       	pop	r28
    1f68:	df 91       	pop	r29
    1f6a:	08 95       	ret

00001f6c <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    1f6c:	df 93       	push	r29
    1f6e:	cf 93       	push	r28
    1f70:	00 d0       	rcall	.+0      	; 0x1f72 <uxQueueMessagesWaiting+0x6>
    1f72:	0f 92       	push	r0
    1f74:	cd b7       	in	r28, 0x3d	; 61
    1f76:	de b7       	in	r29, 0x3e	; 62
    1f78:	9b 83       	std	Y+3, r25	; 0x03
    1f7a:	8a 83       	std	Y+2, r24	; 0x02
	unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1f7c:	0f b6       	in	r0, 0x3f	; 63
    1f7e:	f8 94       	cli
    1f80:	0f 92       	push	r0
	uxReturn = pxQueue->uxMessagesWaiting;
    1f82:	ea 81       	ldd	r30, Y+2	; 0x02
    1f84:	fb 81       	ldd	r31, Y+3	; 0x03
    1f86:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f88:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1f8a:	0f 90       	pop	r0
    1f8c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1f8e:	89 81       	ldd	r24, Y+1	; 0x01
}
    1f90:	0f 90       	pop	r0
    1f92:	0f 90       	pop	r0
    1f94:	0f 90       	pop	r0
    1f96:	cf 91       	pop	r28
    1f98:	df 91       	pop	r29
    1f9a:	08 95       	ret

00001f9c <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    1f9c:	df 93       	push	r29
    1f9e:	cf 93       	push	r28
    1fa0:	00 d0       	rcall	.+0      	; 0x1fa2 <uxQueueMessagesWaitingFromISR+0x6>
    1fa2:	0f 92       	push	r0
    1fa4:	cd b7       	in	r28, 0x3d	; 61
    1fa6:	de b7       	in	r29, 0x3e	; 62
    1fa8:	9b 83       	std	Y+3, r25	; 0x03
    1faa:	8a 83       	std	Y+2, r24	; 0x02
	unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    1fac:	ea 81       	ldd	r30, Y+2	; 0x02
    1fae:	fb 81       	ldd	r31, Y+3	; 0x03
    1fb0:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fb2:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    1fb4:	89 81       	ldd	r24, Y+1	; 0x01
}
    1fb6:	0f 90       	pop	r0
    1fb8:	0f 90       	pop	r0
    1fba:	0f 90       	pop	r0
    1fbc:	cf 91       	pop	r28
    1fbe:	df 91       	pop	r29
    1fc0:	08 95       	ret

00001fc2 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1fc2:	df 93       	push	r29
    1fc4:	cf 93       	push	r28
    1fc6:	00 d0       	rcall	.+0      	; 0x1fc8 <vQueueDelete+0x6>
    1fc8:	cd b7       	in	r28, 0x3d	; 61
    1fca:	de b7       	in	r29, 0x3e	; 62
    1fcc:	9a 83       	std	Y+2, r25	; 0x02
    1fce:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    1fd0:	e9 81       	ldd	r30, Y+1	; 0x01
    1fd2:	fa 81       	ldd	r31, Y+2	; 0x02
    1fd4:	80 81       	ld	r24, Z
    1fd6:	91 81       	ldd	r25, Z+1	; 0x01
    1fd8:	0e 94 c1 08 	call	0x1182	; 0x1182 <vPortFree>
	vPortFree( pxQueue );
    1fdc:	89 81       	ldd	r24, Y+1	; 0x01
    1fde:	9a 81       	ldd	r25, Y+2	; 0x02
    1fe0:	0e 94 c1 08 	call	0x1182	; 0x1182 <vPortFree>
}
    1fe4:	0f 90       	pop	r0
    1fe6:	0f 90       	pop	r0
    1fe8:	cf 91       	pop	r28
    1fea:	df 91       	pop	r29
    1fec:	08 95       	ret

00001fee <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    1fee:	df 93       	push	r29
    1ff0:	cf 93       	push	r28
    1ff2:	00 d0       	rcall	.+0      	; 0x1ff4 <prvCopyDataToQueue+0x6>
    1ff4:	00 d0       	rcall	.+0      	; 0x1ff6 <prvCopyDataToQueue+0x8>
    1ff6:	0f 92       	push	r0
    1ff8:	cd b7       	in	r28, 0x3d	; 61
    1ffa:	de b7       	in	r29, 0x3e	; 62
    1ffc:	9a 83       	std	Y+2, r25	; 0x02
    1ffe:	89 83       	std	Y+1, r24	; 0x01
    2000:	7c 83       	std	Y+4, r23	; 0x04
    2002:	6b 83       	std	Y+3, r22	; 0x03
    2004:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    2006:	e9 81       	ldd	r30, Y+1	; 0x01
    2008:	fa 81       	ldd	r31, Y+2	; 0x02
    200a:	84 8d       	ldd	r24, Z+28	; 0x1c
    200c:	88 23       	and	r24, r24
    200e:	09 f4       	brne	.+2      	; 0x2012 <prvCopyDataToQueue+0x24>
    2010:	74 c0       	rjmp	.+232    	; 0x20fa <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    2012:	8d 81       	ldd	r24, Y+5	; 0x05
    2014:	88 23       	and	r24, r24
    2016:	99 f5       	brne	.+102    	; 0x207e <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    2018:	e9 81       	ldd	r30, Y+1	; 0x01
    201a:	fa 81       	ldd	r31, Y+2	; 0x02
    201c:	64 81       	ldd	r22, Z+4	; 0x04
    201e:	75 81       	ldd	r23, Z+5	; 0x05
    2020:	e9 81       	ldd	r30, Y+1	; 0x01
    2022:	fa 81       	ldd	r31, Y+2	; 0x02
    2024:	84 8d       	ldd	r24, Z+28	; 0x1c
    2026:	48 2f       	mov	r20, r24
    2028:	50 e0       	ldi	r21, 0x00	; 0
    202a:	2b 81       	ldd	r18, Y+3	; 0x03
    202c:	3c 81       	ldd	r19, Y+4	; 0x04
    202e:	cb 01       	movw	r24, r22
    2030:	b9 01       	movw	r22, r18
    2032:	0e 94 25 36 	call	0x6c4a	; 0x6c4a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    2036:	e9 81       	ldd	r30, Y+1	; 0x01
    2038:	fa 81       	ldd	r31, Y+2	; 0x02
    203a:	24 81       	ldd	r18, Z+4	; 0x04
    203c:	35 81       	ldd	r19, Z+5	; 0x05
    203e:	e9 81       	ldd	r30, Y+1	; 0x01
    2040:	fa 81       	ldd	r31, Y+2	; 0x02
    2042:	84 8d       	ldd	r24, Z+28	; 0x1c
    2044:	88 2f       	mov	r24, r24
    2046:	90 e0       	ldi	r25, 0x00	; 0
    2048:	82 0f       	add	r24, r18
    204a:	93 1f       	adc	r25, r19
    204c:	e9 81       	ldd	r30, Y+1	; 0x01
    204e:	fa 81       	ldd	r31, Y+2	; 0x02
    2050:	95 83       	std	Z+5, r25	; 0x05
    2052:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    2054:	e9 81       	ldd	r30, Y+1	; 0x01
    2056:	fa 81       	ldd	r31, Y+2	; 0x02
    2058:	24 81       	ldd	r18, Z+4	; 0x04
    205a:	35 81       	ldd	r19, Z+5	; 0x05
    205c:	e9 81       	ldd	r30, Y+1	; 0x01
    205e:	fa 81       	ldd	r31, Y+2	; 0x02
    2060:	82 81       	ldd	r24, Z+2	; 0x02
    2062:	93 81       	ldd	r25, Z+3	; 0x03
    2064:	28 17       	cp	r18, r24
    2066:	39 07       	cpc	r19, r25
    2068:	08 f4       	brcc	.+2      	; 0x206c <prvCopyDataToQueue+0x7e>
    206a:	47 c0       	rjmp	.+142    	; 0x20fa <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    206c:	e9 81       	ldd	r30, Y+1	; 0x01
    206e:	fa 81       	ldd	r31, Y+2	; 0x02
    2070:	80 81       	ld	r24, Z
    2072:	91 81       	ldd	r25, Z+1	; 0x01
    2074:	e9 81       	ldd	r30, Y+1	; 0x01
    2076:	fa 81       	ldd	r31, Y+2	; 0x02
    2078:	95 83       	std	Z+5, r25	; 0x05
    207a:	84 83       	std	Z+4, r24	; 0x04
    207c:	3e c0       	rjmp	.+124    	; 0x20fa <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    207e:	e9 81       	ldd	r30, Y+1	; 0x01
    2080:	fa 81       	ldd	r31, Y+2	; 0x02
    2082:	66 81       	ldd	r22, Z+6	; 0x06
    2084:	77 81       	ldd	r23, Z+7	; 0x07
    2086:	e9 81       	ldd	r30, Y+1	; 0x01
    2088:	fa 81       	ldd	r31, Y+2	; 0x02
    208a:	84 8d       	ldd	r24, Z+28	; 0x1c
    208c:	48 2f       	mov	r20, r24
    208e:	50 e0       	ldi	r21, 0x00	; 0
    2090:	2b 81       	ldd	r18, Y+3	; 0x03
    2092:	3c 81       	ldd	r19, Y+4	; 0x04
    2094:	cb 01       	movw	r24, r22
    2096:	b9 01       	movw	r22, r18
    2098:	0e 94 25 36 	call	0x6c4a	; 0x6c4a <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    209c:	e9 81       	ldd	r30, Y+1	; 0x01
    209e:	fa 81       	ldd	r31, Y+2	; 0x02
    20a0:	26 81       	ldd	r18, Z+6	; 0x06
    20a2:	37 81       	ldd	r19, Z+7	; 0x07
    20a4:	e9 81       	ldd	r30, Y+1	; 0x01
    20a6:	fa 81       	ldd	r31, Y+2	; 0x02
    20a8:	84 8d       	ldd	r24, Z+28	; 0x1c
    20aa:	88 2f       	mov	r24, r24
    20ac:	90 e0       	ldi	r25, 0x00	; 0
    20ae:	90 95       	com	r25
    20b0:	81 95       	neg	r24
    20b2:	9f 4f       	sbci	r25, 0xFF	; 255
    20b4:	82 0f       	add	r24, r18
    20b6:	93 1f       	adc	r25, r19
    20b8:	e9 81       	ldd	r30, Y+1	; 0x01
    20ba:	fa 81       	ldd	r31, Y+2	; 0x02
    20bc:	97 83       	std	Z+7, r25	; 0x07
    20be:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    20c0:	e9 81       	ldd	r30, Y+1	; 0x01
    20c2:	fa 81       	ldd	r31, Y+2	; 0x02
    20c4:	26 81       	ldd	r18, Z+6	; 0x06
    20c6:	37 81       	ldd	r19, Z+7	; 0x07
    20c8:	e9 81       	ldd	r30, Y+1	; 0x01
    20ca:	fa 81       	ldd	r31, Y+2	; 0x02
    20cc:	80 81       	ld	r24, Z
    20ce:	91 81       	ldd	r25, Z+1	; 0x01
    20d0:	28 17       	cp	r18, r24
    20d2:	39 07       	cpc	r19, r25
    20d4:	90 f4       	brcc	.+36     	; 0x20fa <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    20d6:	e9 81       	ldd	r30, Y+1	; 0x01
    20d8:	fa 81       	ldd	r31, Y+2	; 0x02
    20da:	22 81       	ldd	r18, Z+2	; 0x02
    20dc:	33 81       	ldd	r19, Z+3	; 0x03
    20de:	e9 81       	ldd	r30, Y+1	; 0x01
    20e0:	fa 81       	ldd	r31, Y+2	; 0x02
    20e2:	84 8d       	ldd	r24, Z+28	; 0x1c
    20e4:	88 2f       	mov	r24, r24
    20e6:	90 e0       	ldi	r25, 0x00	; 0
    20e8:	90 95       	com	r25
    20ea:	81 95       	neg	r24
    20ec:	9f 4f       	sbci	r25, 0xFF	; 255
    20ee:	82 0f       	add	r24, r18
    20f0:	93 1f       	adc	r25, r19
    20f2:	e9 81       	ldd	r30, Y+1	; 0x01
    20f4:	fa 81       	ldd	r31, Y+2	; 0x02
    20f6:	97 83       	std	Z+7, r25	; 0x07
    20f8:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    20fa:	e9 81       	ldd	r30, Y+1	; 0x01
    20fc:	fa 81       	ldd	r31, Y+2	; 0x02
    20fe:	82 8d       	ldd	r24, Z+26	; 0x1a
    2100:	8f 5f       	subi	r24, 0xFF	; 255
    2102:	e9 81       	ldd	r30, Y+1	; 0x01
    2104:	fa 81       	ldd	r31, Y+2	; 0x02
    2106:	82 8f       	std	Z+26, r24	; 0x1a
}
    2108:	0f 90       	pop	r0
    210a:	0f 90       	pop	r0
    210c:	0f 90       	pop	r0
    210e:	0f 90       	pop	r0
    2110:	0f 90       	pop	r0
    2112:	cf 91       	pop	r28
    2114:	df 91       	pop	r29
    2116:	08 95       	ret

00002118 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    2118:	df 93       	push	r29
    211a:	cf 93       	push	r28
    211c:	00 d0       	rcall	.+0      	; 0x211e <prvCopyDataFromQueue+0x6>
    211e:	00 d0       	rcall	.+0      	; 0x2120 <prvCopyDataFromQueue+0x8>
    2120:	cd b7       	in	r28, 0x3d	; 61
    2122:	de b7       	in	r29, 0x3e	; 62
    2124:	9a 83       	std	Y+2, r25	; 0x02
    2126:	89 83       	std	Y+1, r24	; 0x01
    2128:	7c 83       	std	Y+4, r23	; 0x04
    212a:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    212c:	e9 81       	ldd	r30, Y+1	; 0x01
    212e:	fa 81       	ldd	r31, Y+2	; 0x02
    2130:	80 81       	ld	r24, Z
    2132:	91 81       	ldd	r25, Z+1	; 0x01
    2134:	00 97       	sbiw	r24, 0x00	; 0
    2136:	89 f1       	breq	.+98     	; 0x219a <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    2138:	e9 81       	ldd	r30, Y+1	; 0x01
    213a:	fa 81       	ldd	r31, Y+2	; 0x02
    213c:	26 81       	ldd	r18, Z+6	; 0x06
    213e:	37 81       	ldd	r19, Z+7	; 0x07
    2140:	e9 81       	ldd	r30, Y+1	; 0x01
    2142:	fa 81       	ldd	r31, Y+2	; 0x02
    2144:	84 8d       	ldd	r24, Z+28	; 0x1c
    2146:	88 2f       	mov	r24, r24
    2148:	90 e0       	ldi	r25, 0x00	; 0
    214a:	82 0f       	add	r24, r18
    214c:	93 1f       	adc	r25, r19
    214e:	e9 81       	ldd	r30, Y+1	; 0x01
    2150:	fa 81       	ldd	r31, Y+2	; 0x02
    2152:	97 83       	std	Z+7, r25	; 0x07
    2154:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    2156:	e9 81       	ldd	r30, Y+1	; 0x01
    2158:	fa 81       	ldd	r31, Y+2	; 0x02
    215a:	26 81       	ldd	r18, Z+6	; 0x06
    215c:	37 81       	ldd	r19, Z+7	; 0x07
    215e:	e9 81       	ldd	r30, Y+1	; 0x01
    2160:	fa 81       	ldd	r31, Y+2	; 0x02
    2162:	82 81       	ldd	r24, Z+2	; 0x02
    2164:	93 81       	ldd	r25, Z+3	; 0x03
    2166:	28 17       	cp	r18, r24
    2168:	39 07       	cpc	r19, r25
    216a:	40 f0       	brcs	.+16     	; 0x217c <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    216c:	e9 81       	ldd	r30, Y+1	; 0x01
    216e:	fa 81       	ldd	r31, Y+2	; 0x02
    2170:	80 81       	ld	r24, Z
    2172:	91 81       	ldd	r25, Z+1	; 0x01
    2174:	e9 81       	ldd	r30, Y+1	; 0x01
    2176:	fa 81       	ldd	r31, Y+2	; 0x02
    2178:	97 83       	std	Z+7, r25	; 0x07
    217a:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    217c:	e9 81       	ldd	r30, Y+1	; 0x01
    217e:	fa 81       	ldd	r31, Y+2	; 0x02
    2180:	46 81       	ldd	r20, Z+6	; 0x06
    2182:	57 81       	ldd	r21, Z+7	; 0x07
    2184:	e9 81       	ldd	r30, Y+1	; 0x01
    2186:	fa 81       	ldd	r31, Y+2	; 0x02
    2188:	84 8d       	ldd	r24, Z+28	; 0x1c
    218a:	28 2f       	mov	r18, r24
    218c:	30 e0       	ldi	r19, 0x00	; 0
    218e:	8b 81       	ldd	r24, Y+3	; 0x03
    2190:	9c 81       	ldd	r25, Y+4	; 0x04
    2192:	ba 01       	movw	r22, r20
    2194:	a9 01       	movw	r20, r18
    2196:	0e 94 25 36 	call	0x6c4a	; 0x6c4a <memcpy>
	}
}
    219a:	0f 90       	pop	r0
    219c:	0f 90       	pop	r0
    219e:	0f 90       	pop	r0
    21a0:	0f 90       	pop	r0
    21a2:	cf 91       	pop	r28
    21a4:	df 91       	pop	r29
    21a6:	08 95       	ret

000021a8 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    21a8:	df 93       	push	r29
    21aa:	cf 93       	push	r28
    21ac:	00 d0       	rcall	.+0      	; 0x21ae <prvUnlockQueue+0x6>
    21ae:	cd b7       	in	r28, 0x3d	; 61
    21b0:	de b7       	in	r29, 0x3e	; 62
    21b2:	9a 83       	std	Y+2, r25	; 0x02
    21b4:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    21b6:	0f b6       	in	r0, 0x3f	; 63
    21b8:	f8 94       	cli
    21ba:	0f 92       	push	r0
    21bc:	15 c0       	rjmp	.+42     	; 0x21e8 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    21be:	e9 81       	ldd	r30, Y+1	; 0x01
    21c0:	fa 81       	ldd	r31, Y+2	; 0x02
    21c2:	81 89       	ldd	r24, Z+17	; 0x11
    21c4:	88 23       	and	r24, r24
    21c6:	a9 f0       	breq	.+42     	; 0x21f2 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    21c8:	89 81       	ldd	r24, Y+1	; 0x01
    21ca:	9a 81       	ldd	r25, Y+2	; 0x02
    21cc:	41 96       	adiw	r24, 0x11	; 17
    21ce:	0e 94 0c 16 	call	0x2c18	; 0x2c18 <xTaskRemoveFromEventList>
    21d2:	88 23       	and	r24, r24
    21d4:	11 f0       	breq	.+4      	; 0x21da <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    21d6:	0e 94 ea 16 	call	0x2dd4	; 0x2dd4 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    21da:	e9 81       	ldd	r30, Y+1	; 0x01
    21dc:	fa 81       	ldd	r31, Y+2	; 0x02
    21de:	86 8d       	ldd	r24, Z+30	; 0x1e
    21e0:	81 50       	subi	r24, 0x01	; 1
    21e2:	e9 81       	ldd	r30, Y+1	; 0x01
    21e4:	fa 81       	ldd	r31, Y+2	; 0x02
    21e6:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    21e8:	e9 81       	ldd	r30, Y+1	; 0x01
    21ea:	fa 81       	ldd	r31, Y+2	; 0x02
    21ec:	86 8d       	ldd	r24, Z+30	; 0x1e
    21ee:	18 16       	cp	r1, r24
    21f0:	34 f3       	brlt	.-52     	; 0x21be <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    21f2:	e9 81       	ldd	r30, Y+1	; 0x01
    21f4:	fa 81       	ldd	r31, Y+2	; 0x02
    21f6:	8f ef       	ldi	r24, 0xFF	; 255
    21f8:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    21fa:	0f 90       	pop	r0
    21fc:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    21fe:	0f b6       	in	r0, 0x3f	; 63
    2200:	f8 94       	cli
    2202:	0f 92       	push	r0
    2204:	15 c0       	rjmp	.+42     	; 0x2230 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2206:	e9 81       	ldd	r30, Y+1	; 0x01
    2208:	fa 81       	ldd	r31, Y+2	; 0x02
    220a:	80 85       	ldd	r24, Z+8	; 0x08
    220c:	88 23       	and	r24, r24
    220e:	a9 f0       	breq	.+42     	; 0x223a <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2210:	89 81       	ldd	r24, Y+1	; 0x01
    2212:	9a 81       	ldd	r25, Y+2	; 0x02
    2214:	08 96       	adiw	r24, 0x08	; 8
    2216:	0e 94 0c 16 	call	0x2c18	; 0x2c18 <xTaskRemoveFromEventList>
    221a:	88 23       	and	r24, r24
    221c:	11 f0       	breq	.+4      	; 0x2222 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    221e:	0e 94 ea 16 	call	0x2dd4	; 0x2dd4 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    2222:	e9 81       	ldd	r30, Y+1	; 0x01
    2224:	fa 81       	ldd	r31, Y+2	; 0x02
    2226:	85 8d       	ldd	r24, Z+29	; 0x1d
    2228:	81 50       	subi	r24, 0x01	; 1
    222a:	e9 81       	ldd	r30, Y+1	; 0x01
    222c:	fa 81       	ldd	r31, Y+2	; 0x02
    222e:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2230:	e9 81       	ldd	r30, Y+1	; 0x01
    2232:	fa 81       	ldd	r31, Y+2	; 0x02
    2234:	85 8d       	ldd	r24, Z+29	; 0x1d
    2236:	18 16       	cp	r1, r24
    2238:	34 f3       	brlt	.-52     	; 0x2206 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    223a:	e9 81       	ldd	r30, Y+1	; 0x01
    223c:	fa 81       	ldd	r31, Y+2	; 0x02
    223e:	8f ef       	ldi	r24, 0xFF	; 255
    2240:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    2242:	0f 90       	pop	r0
    2244:	0f be       	out	0x3f, r0	; 63
}
    2246:	0f 90       	pop	r0
    2248:	0f 90       	pop	r0
    224a:	cf 91       	pop	r28
    224c:	df 91       	pop	r29
    224e:	08 95       	ret

00002250 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    2250:	df 93       	push	r29
    2252:	cf 93       	push	r28
    2254:	00 d0       	rcall	.+0      	; 0x2256 <prvIsQueueEmpty+0x6>
    2256:	0f 92       	push	r0
    2258:	cd b7       	in	r28, 0x3d	; 61
    225a:	de b7       	in	r29, 0x3e	; 62
    225c:	9b 83       	std	Y+3, r25	; 0x03
    225e:	8a 83       	std	Y+2, r24	; 0x02
	signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2260:	0f b6       	in	r0, 0x3f	; 63
    2262:	f8 94       	cli
    2264:	0f 92       	push	r0
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    2266:	ea 81       	ldd	r30, Y+2	; 0x02
    2268:	fb 81       	ldd	r31, Y+3	; 0x03
    226a:	82 8d       	ldd	r24, Z+26	; 0x1a
    226c:	19 82       	std	Y+1, r1	; 0x01
    226e:	88 23       	and	r24, r24
    2270:	11 f4       	brne	.+4      	; 0x2276 <prvIsQueueEmpty+0x26>
    2272:	81 e0       	ldi	r24, 0x01	; 1
    2274:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    2276:	0f 90       	pop	r0
    2278:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    227a:	89 81       	ldd	r24, Y+1	; 0x01
}
    227c:	0f 90       	pop	r0
    227e:	0f 90       	pop	r0
    2280:	0f 90       	pop	r0
    2282:	cf 91       	pop	r28
    2284:	df 91       	pop	r29
    2286:	08 95       	ret

00002288 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    2288:	df 93       	push	r29
    228a:	cf 93       	push	r28
    228c:	00 d0       	rcall	.+0      	; 0x228e <xQueueIsQueueEmptyFromISR+0x6>
    228e:	0f 92       	push	r0
    2290:	cd b7       	in	r28, 0x3d	; 61
    2292:	de b7       	in	r29, 0x3e	; 62
    2294:	9b 83       	std	Y+3, r25	; 0x03
    2296:	8a 83       	std	Y+2, r24	; 0x02
	signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    2298:	ea 81       	ldd	r30, Y+2	; 0x02
    229a:	fb 81       	ldd	r31, Y+3	; 0x03
    229c:	82 8d       	ldd	r24, Z+26	; 0x1a
    229e:	19 82       	std	Y+1, r1	; 0x01
    22a0:	88 23       	and	r24, r24
    22a2:	11 f4       	brne	.+4      	; 0x22a8 <xQueueIsQueueEmptyFromISR+0x20>
    22a4:	81 e0       	ldi	r24, 0x01	; 1
    22a6:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    22a8:	89 81       	ldd	r24, Y+1	; 0x01
}
    22aa:	0f 90       	pop	r0
    22ac:	0f 90       	pop	r0
    22ae:	0f 90       	pop	r0
    22b0:	cf 91       	pop	r28
    22b2:	df 91       	pop	r29
    22b4:	08 95       	ret

000022b6 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    22b6:	df 93       	push	r29
    22b8:	cf 93       	push	r28
    22ba:	00 d0       	rcall	.+0      	; 0x22bc <prvIsQueueFull+0x6>
    22bc:	0f 92       	push	r0
    22be:	cd b7       	in	r28, 0x3d	; 61
    22c0:	de b7       	in	r29, 0x3e	; 62
    22c2:	9b 83       	std	Y+3, r25	; 0x03
    22c4:	8a 83       	std	Y+2, r24	; 0x02
	signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    22c6:	0f b6       	in	r0, 0x3f	; 63
    22c8:	f8 94       	cli
    22ca:	0f 92       	push	r0
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    22cc:	ea 81       	ldd	r30, Y+2	; 0x02
    22ce:	fb 81       	ldd	r31, Y+3	; 0x03
    22d0:	92 8d       	ldd	r25, Z+26	; 0x1a
    22d2:	ea 81       	ldd	r30, Y+2	; 0x02
    22d4:	fb 81       	ldd	r31, Y+3	; 0x03
    22d6:	83 8d       	ldd	r24, Z+27	; 0x1b
    22d8:	19 82       	std	Y+1, r1	; 0x01
    22da:	98 17       	cp	r25, r24
    22dc:	11 f4       	brne	.+4      	; 0x22e2 <prvIsQueueFull+0x2c>
    22de:	81 e0       	ldi	r24, 0x01	; 1
    22e0:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    22e2:	0f 90       	pop	r0
    22e4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    22e6:	89 81       	ldd	r24, Y+1	; 0x01
}
    22e8:	0f 90       	pop	r0
    22ea:	0f 90       	pop	r0
    22ec:	0f 90       	pop	r0
    22ee:	cf 91       	pop	r28
    22f0:	df 91       	pop	r29
    22f2:	08 95       	ret

000022f4 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    22f4:	df 93       	push	r29
    22f6:	cf 93       	push	r28
    22f8:	00 d0       	rcall	.+0      	; 0x22fa <xQueueIsQueueFullFromISR+0x6>
    22fa:	0f 92       	push	r0
    22fc:	cd b7       	in	r28, 0x3d	; 61
    22fe:	de b7       	in	r29, 0x3e	; 62
    2300:	9b 83       	std	Y+3, r25	; 0x03
    2302:	8a 83       	std	Y+2, r24	; 0x02
	signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    2304:	ea 81       	ldd	r30, Y+2	; 0x02
    2306:	fb 81       	ldd	r31, Y+3	; 0x03
    2308:	92 8d       	ldd	r25, Z+26	; 0x1a
    230a:	ea 81       	ldd	r30, Y+2	; 0x02
    230c:	fb 81       	ldd	r31, Y+3	; 0x03
    230e:	83 8d       	ldd	r24, Z+27	; 0x1b
    2310:	19 82       	std	Y+1, r1	; 0x01
    2312:	98 17       	cp	r25, r24
    2314:	11 f4       	brne	.+4      	; 0x231a <xQueueIsQueueFullFromISR+0x26>
    2316:	81 e0       	ldi	r24, 0x01	; 1
    2318:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    231a:	89 81       	ldd	r24, Y+1	; 0x01
}
    231c:	0f 90       	pop	r0
    231e:	0f 90       	pop	r0
    2320:	0f 90       	pop	r0
    2322:	cf 91       	pop	r28
    2324:	df 91       	pop	r29
    2326:	08 95       	ret

00002328 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    2328:	af 92       	push	r10
    232a:	bf 92       	push	r11
    232c:	cf 92       	push	r12
    232e:	df 92       	push	r13
    2330:	ef 92       	push	r14
    2332:	ff 92       	push	r15
    2334:	0f 93       	push	r16
    2336:	1f 93       	push	r17
    2338:	df 93       	push	r29
    233a:	cf 93       	push	r28
    233c:	cd b7       	in	r28, 0x3d	; 61
    233e:	de b7       	in	r29, 0x3e	; 62
    2340:	64 97       	sbiw	r28, 0x14	; 20
    2342:	0f b6       	in	r0, 0x3f	; 63
    2344:	f8 94       	cli
    2346:	de bf       	out	0x3e, r29	; 62
    2348:	0f be       	out	0x3f, r0	; 63
    234a:	cd bf       	out	0x3d, r28	; 61
    234c:	9f 83       	std	Y+7, r25	; 0x07
    234e:	8e 83       	std	Y+6, r24	; 0x06
    2350:	79 87       	std	Y+9, r23	; 0x09
    2352:	68 87       	std	Y+8, r22	; 0x08
    2354:	5b 87       	std	Y+11, r21	; 0x0b
    2356:	4a 87       	std	Y+10, r20	; 0x0a
    2358:	3d 87       	std	Y+13, r19	; 0x0d
    235a:	2c 87       	std	Y+12, r18	; 0x0c
    235c:	0e 87       	std	Y+14, r16	; 0x0e
    235e:	f8 8a       	std	Y+16, r15	; 0x10
    2360:	ef 86       	std	Y+15, r14	; 0x0f
    2362:	da 8a       	std	Y+18, r13	; 0x12
    2364:	c9 8a       	std	Y+17, r12	; 0x11
    2366:	bc 8a       	std	Y+20, r11	; 0x14
    2368:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    236a:	8a 85       	ldd	r24, Y+10	; 0x0a
    236c:	9b 85       	ldd	r25, Y+11	; 0x0b
    236e:	29 89       	ldd	r18, Y+17	; 0x11
    2370:	3a 89       	ldd	r19, Y+18	; 0x12
    2372:	b9 01       	movw	r22, r18
    2374:	0e 94 19 18 	call	0x3032	; 0x3032 <prvAllocateTCBAndStack>
    2378:	9c 83       	std	Y+4, r25	; 0x04
    237a:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    237c:	8b 81       	ldd	r24, Y+3	; 0x03
    237e:	9c 81       	ldd	r25, Y+4	; 0x04
    2380:	00 97       	sbiw	r24, 0x00	; 0
    2382:	09 f4       	brne	.+2      	; 0x2386 <xTaskGenericCreate+0x5e>
    2384:	99 c0       	rjmp	.+306    	; 0x24b8 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    2386:	eb 81       	ldd	r30, Y+3	; 0x03
    2388:	fc 81       	ldd	r31, Y+4	; 0x04
    238a:	27 89       	ldd	r18, Z+23	; 0x17
    238c:	30 8d       	ldd	r19, Z+24	; 0x18
    238e:	8a 85       	ldd	r24, Y+10	; 0x0a
    2390:	9b 85       	ldd	r25, Y+11	; 0x0b
    2392:	01 97       	sbiw	r24, 0x01	; 1
    2394:	82 0f       	add	r24, r18
    2396:	93 1f       	adc	r25, r19
    2398:	9a 83       	std	Y+2, r25	; 0x02
    239a:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    239c:	8b 81       	ldd	r24, Y+3	; 0x03
    239e:	9c 81       	ldd	r25, Y+4	; 0x04
    23a0:	28 85       	ldd	r18, Y+8	; 0x08
    23a2:	39 85       	ldd	r19, Y+9	; 0x09
    23a4:	eb 89       	ldd	r30, Y+19	; 0x13
    23a6:	fc 89       	ldd	r31, Y+20	; 0x14
    23a8:	aa 85       	ldd	r26, Y+10	; 0x0a
    23aa:	bb 85       	ldd	r27, Y+11	; 0x0b
    23ac:	b9 01       	movw	r22, r18
    23ae:	4e 85       	ldd	r20, Y+14	; 0x0e
    23b0:	9f 01       	movw	r18, r30
    23b2:	8d 01       	movw	r16, r26
    23b4:	0e 94 fe 16 	call	0x2dfc	; 0x2dfc <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    23b8:	89 81       	ldd	r24, Y+1	; 0x01
    23ba:	9a 81       	ldd	r25, Y+2	; 0x02
    23bc:	2e 81       	ldd	r18, Y+6	; 0x06
    23be:	3f 81       	ldd	r19, Y+7	; 0x07
    23c0:	4c 85       	ldd	r20, Y+12	; 0x0c
    23c2:	5d 85       	ldd	r21, Y+13	; 0x0d
    23c4:	b9 01       	movw	r22, r18
    23c6:	0e 94 22 0a 	call	0x1444	; 0x1444 <pxPortInitialiseStack>
    23ca:	eb 81       	ldd	r30, Y+3	; 0x03
    23cc:	fc 81       	ldd	r31, Y+4	; 0x04
    23ce:	91 83       	std	Z+1, r25	; 0x01
    23d0:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    23d2:	8f 85       	ldd	r24, Y+15	; 0x0f
    23d4:	98 89       	ldd	r25, Y+16	; 0x10
    23d6:	00 97       	sbiw	r24, 0x00	; 0
    23d8:	31 f0       	breq	.+12     	; 0x23e6 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    23da:	ef 85       	ldd	r30, Y+15	; 0x0f
    23dc:	f8 89       	ldd	r31, Y+16	; 0x10
    23de:	8b 81       	ldd	r24, Y+3	; 0x03
    23e0:	9c 81       	ldd	r25, Y+4	; 0x04
    23e2:	91 83       	std	Z+1, r25	; 0x01
    23e4:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    23e6:	0f b6       	in	r0, 0x3f	; 63
    23e8:	f8 94       	cli
    23ea:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    23ec:	80 91 f7 06 	lds	r24, 0x06F7
    23f0:	8f 5f       	subi	r24, 0xFF	; 255
    23f2:	80 93 f7 06 	sts	0x06F7, r24
			if( pxCurrentTCB == NULL )
    23f6:	80 91 f4 06 	lds	r24, 0x06F4
    23fa:	90 91 f5 06 	lds	r25, 0x06F5
    23fe:	00 97       	sbiw	r24, 0x00	; 0
    2400:	69 f4       	brne	.+26     	; 0x241c <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    2402:	8b 81       	ldd	r24, Y+3	; 0x03
    2404:	9c 81       	ldd	r25, Y+4	; 0x04
    2406:	90 93 f5 06 	sts	0x06F5, r25
    240a:	80 93 f4 06 	sts	0x06F4, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    240e:	80 91 f7 06 	lds	r24, 0x06F7
    2412:	81 30       	cpi	r24, 0x01	; 1
    2414:	a9 f4       	brne	.+42     	; 0x2440 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    2416:	0e 94 55 17 	call	0x2eaa	; 0x2eaa <prvInitialiseTaskLists>
    241a:	12 c0       	rjmp	.+36     	; 0x2440 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    241c:	80 91 fc 06 	lds	r24, 0x06FC
    2420:	88 23       	and	r24, r24
    2422:	71 f4       	brne	.+28     	; 0x2440 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    2424:	e0 91 f4 06 	lds	r30, 0x06F4
    2428:	f0 91 f5 06 	lds	r31, 0x06F5
    242c:	96 89       	ldd	r25, Z+22	; 0x16
    242e:	8e 85       	ldd	r24, Y+14	; 0x0e
    2430:	89 17       	cp	r24, r25
    2432:	30 f0       	brcs	.+12     	; 0x2440 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    2434:	8b 81       	ldd	r24, Y+3	; 0x03
    2436:	9c 81       	ldd	r25, Y+4	; 0x04
    2438:	90 93 f5 06 	sts	0x06F5, r25
    243c:	80 93 f4 06 	sts	0x06F4, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    2440:	eb 81       	ldd	r30, Y+3	; 0x03
    2442:	fc 81       	ldd	r31, Y+4	; 0x04
    2444:	96 89       	ldd	r25, Z+22	; 0x16
    2446:	80 91 fa 06 	lds	r24, 0x06FA
    244a:	89 17       	cp	r24, r25
    244c:	28 f4       	brcc	.+10     	; 0x2458 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    244e:	eb 81       	ldd	r30, Y+3	; 0x03
    2450:	fc 81       	ldd	r31, Y+4	; 0x04
    2452:	86 89       	ldd	r24, Z+22	; 0x16
    2454:	80 93 fa 06 	sts	0x06FA, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    2458:	80 91 01 07 	lds	r24, 0x0701
    245c:	8f 5f       	subi	r24, 0xFF	; 255
    245e:	80 93 01 07 	sts	0x0701, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    2462:	eb 81       	ldd	r30, Y+3	; 0x03
    2464:	fc 81       	ldd	r31, Y+4	; 0x04
    2466:	96 89       	ldd	r25, Z+22	; 0x16
    2468:	80 91 fb 06 	lds	r24, 0x06FB
    246c:	89 17       	cp	r24, r25
    246e:	28 f4       	brcc	.+10     	; 0x247a <xTaskGenericCreate+0x152>
    2470:	eb 81       	ldd	r30, Y+3	; 0x03
    2472:	fc 81       	ldd	r31, Y+4	; 0x04
    2474:	86 89       	ldd	r24, Z+22	; 0x16
    2476:	80 93 fb 06 	sts	0x06FB, r24
    247a:	eb 81       	ldd	r30, Y+3	; 0x03
    247c:	fc 81       	ldd	r31, Y+4	; 0x04
    247e:	86 89       	ldd	r24, Z+22	; 0x16
    2480:	28 2f       	mov	r18, r24
    2482:	30 e0       	ldi	r19, 0x00	; 0
    2484:	c9 01       	movw	r24, r18
    2486:	88 0f       	add	r24, r24
    2488:	99 1f       	adc	r25, r25
    248a:	88 0f       	add	r24, r24
    248c:	99 1f       	adc	r25, r25
    248e:	88 0f       	add	r24, r24
    2490:	99 1f       	adc	r25, r25
    2492:	82 0f       	add	r24, r18
    2494:	93 1f       	adc	r25, r19
    2496:	ac 01       	movw	r20, r24
    2498:	4e 5f       	subi	r20, 0xFE	; 254
    249a:	58 4f       	sbci	r21, 0xF8	; 248
    249c:	8b 81       	ldd	r24, Y+3	; 0x03
    249e:	9c 81       	ldd	r25, Y+4	; 0x04
    24a0:	9c 01       	movw	r18, r24
    24a2:	2e 5f       	subi	r18, 0xFE	; 254
    24a4:	3f 4f       	sbci	r19, 0xFF	; 255
    24a6:	ca 01       	movw	r24, r20
    24a8:	b9 01       	movw	r22, r18
    24aa:	0e 94 21 09 	call	0x1242	; 0x1242 <vListInsertEnd>

			xReturn = pdPASS;
    24ae:	81 e0       	ldi	r24, 0x01	; 1
    24b0:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    24b2:	0f 90       	pop	r0
    24b4:	0f be       	out	0x3f, r0	; 63
    24b6:	02 c0       	rjmp	.+4      	; 0x24bc <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    24b8:	8f ef       	ldi	r24, 0xFF	; 255
    24ba:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    24bc:	8d 81       	ldd	r24, Y+5	; 0x05
    24be:	81 30       	cpi	r24, 0x01	; 1
    24c0:	71 f4       	brne	.+28     	; 0x24de <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    24c2:	80 91 fc 06 	lds	r24, 0x06FC
    24c6:	88 23       	and	r24, r24
    24c8:	51 f0       	breq	.+20     	; 0x24de <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    24ca:	e0 91 f4 06 	lds	r30, 0x06F4
    24ce:	f0 91 f5 06 	lds	r31, 0x06F5
    24d2:	96 89       	ldd	r25, Z+22	; 0x16
    24d4:	8e 85       	ldd	r24, Y+14	; 0x0e
    24d6:	98 17       	cp	r25, r24
    24d8:	10 f4       	brcc	.+4      	; 0x24de <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    24da:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <vPortYield>
			}
		}
	}

	return xReturn;
    24de:	8d 81       	ldd	r24, Y+5	; 0x05
}
    24e0:	64 96       	adiw	r28, 0x14	; 20
    24e2:	0f b6       	in	r0, 0x3f	; 63
    24e4:	f8 94       	cli
    24e6:	de bf       	out	0x3e, r29	; 62
    24e8:	0f be       	out	0x3f, r0	; 63
    24ea:	cd bf       	out	0x3d, r28	; 61
    24ec:	cf 91       	pop	r28
    24ee:	df 91       	pop	r29
    24f0:	1f 91       	pop	r17
    24f2:	0f 91       	pop	r16
    24f4:	ff 90       	pop	r15
    24f6:	ef 90       	pop	r14
    24f8:	df 90       	pop	r13
    24fa:	cf 90       	pop	r12
    24fc:	bf 90       	pop	r11
    24fe:	af 90       	pop	r10
    2500:	08 95       	ret

00002502 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    2502:	df 93       	push	r29
    2504:	cf 93       	push	r28
    2506:	00 d0       	rcall	.+0      	; 0x2508 <vTaskDelete+0x6>
    2508:	00 d0       	rcall	.+0      	; 0x250a <vTaskDelete+0x8>
    250a:	00 d0       	rcall	.+0      	; 0x250c <vTaskDelete+0xa>
    250c:	cd b7       	in	r28, 0x3d	; 61
    250e:	de b7       	in	r29, 0x3e	; 62
    2510:	9c 83       	std	Y+4, r25	; 0x04
    2512:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    2514:	0f b6       	in	r0, 0x3f	; 63
    2516:	f8 94       	cli
    2518:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    251a:	20 91 f4 06 	lds	r18, 0x06F4
    251e:	30 91 f5 06 	lds	r19, 0x06F5
    2522:	8b 81       	ldd	r24, Y+3	; 0x03
    2524:	9c 81       	ldd	r25, Y+4	; 0x04
    2526:	82 17       	cp	r24, r18
    2528:	93 07       	cpc	r25, r19
    252a:	11 f4       	brne	.+4      	; 0x2530 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    252c:	1c 82       	std	Y+4, r1	; 0x04
    252e:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    2530:	8b 81       	ldd	r24, Y+3	; 0x03
    2532:	9c 81       	ldd	r25, Y+4	; 0x04
    2534:	00 97       	sbiw	r24, 0x00	; 0
    2536:	39 f4       	brne	.+14     	; 0x2546 <vTaskDelete+0x44>
    2538:	80 91 f4 06 	lds	r24, 0x06F4
    253c:	90 91 f5 06 	lds	r25, 0x06F5
    2540:	9e 83       	std	Y+6, r25	; 0x06
    2542:	8d 83       	std	Y+5, r24	; 0x05
    2544:	04 c0       	rjmp	.+8      	; 0x254e <vTaskDelete+0x4c>
    2546:	8b 81       	ldd	r24, Y+3	; 0x03
    2548:	9c 81       	ldd	r25, Y+4	; 0x04
    254a:	9e 83       	std	Y+6, r25	; 0x06
    254c:	8d 83       	std	Y+5, r24	; 0x05
    254e:	8d 81       	ldd	r24, Y+5	; 0x05
    2550:	9e 81       	ldd	r25, Y+6	; 0x06
    2552:	9a 83       	std	Y+2, r25	; 0x02
    2554:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    2556:	89 81       	ldd	r24, Y+1	; 0x01
    2558:	9a 81       	ldd	r25, Y+2	; 0x02
    255a:	02 96       	adiw	r24, 0x02	; 2
    255c:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    2560:	e9 81       	ldd	r30, Y+1	; 0x01
    2562:	fa 81       	ldd	r31, Y+2	; 0x02
    2564:	84 89       	ldd	r24, Z+20	; 0x14
    2566:	95 89       	ldd	r25, Z+21	; 0x15
    2568:	00 97       	sbiw	r24, 0x00	; 0
    256a:	29 f0       	breq	.+10     	; 0x2576 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    256c:	89 81       	ldd	r24, Y+1	; 0x01
    256e:	9a 81       	ldd	r25, Y+2	; 0x02
    2570:	0c 96       	adiw	r24, 0x0c	; 12
    2572:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    2576:	89 81       	ldd	r24, Y+1	; 0x01
    2578:	9a 81       	ldd	r25, Y+2	; 0x02
    257a:	9c 01       	movw	r18, r24
    257c:	2e 5f       	subi	r18, 0xFE	; 254
    257e:	3f 4f       	sbci	r19, 0xFF	; 255
    2580:	8e e4       	ldi	r24, 0x4E	; 78
    2582:	97 e0       	ldi	r25, 0x07	; 7
    2584:	b9 01       	movw	r22, r18
    2586:	0e 94 21 09 	call	0x1242	; 0x1242 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    258a:	80 91 f6 06 	lds	r24, 0x06F6
    258e:	8f 5f       	subi	r24, 0xFF	; 255
    2590:	80 93 f6 06 	sts	0x06F6, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    2594:	80 91 01 07 	lds	r24, 0x0701
    2598:	8f 5f       	subi	r24, 0xFF	; 255
    259a:	80 93 01 07 	sts	0x0701, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    259e:	0f 90       	pop	r0
    25a0:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    25a2:	80 91 fc 06 	lds	r24, 0x06FC
    25a6:	88 23       	and	r24, r24
    25a8:	31 f0       	breq	.+12     	; 0x25b6 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    25aa:	8b 81       	ldd	r24, Y+3	; 0x03
    25ac:	9c 81       	ldd	r25, Y+4	; 0x04
    25ae:	00 97       	sbiw	r24, 0x00	; 0
    25b0:	11 f4       	brne	.+4      	; 0x25b6 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    25b2:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <vPortYield>
			}
		}
	}
    25b6:	26 96       	adiw	r28, 0x06	; 6
    25b8:	0f b6       	in	r0, 0x3f	; 63
    25ba:	f8 94       	cli
    25bc:	de bf       	out	0x3e, r29	; 62
    25be:	0f be       	out	0x3f, r0	; 63
    25c0:	cd bf       	out	0x3d, r28	; 61
    25c2:	cf 91       	pop	r28
    25c4:	df 91       	pop	r29
    25c6:	08 95       	ret

000025c8 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    25c8:	df 93       	push	r29
    25ca:	cf 93       	push	r28
    25cc:	cd b7       	in	r28, 0x3d	; 61
    25ce:	de b7       	in	r29, 0x3e	; 62
    25d0:	28 97       	sbiw	r28, 0x08	; 8
    25d2:	0f b6       	in	r0, 0x3f	; 63
    25d4:	f8 94       	cli
    25d6:	de bf       	out	0x3e, r29	; 62
    25d8:	0f be       	out	0x3f, r0	; 63
    25da:	cd bf       	out	0x3d, r28	; 61
    25dc:	9e 83       	std	Y+6, r25	; 0x06
    25de:	8d 83       	std	Y+5, r24	; 0x05
    25e0:	78 87       	std	Y+8, r23	; 0x08
    25e2:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    25e4:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    25e6:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    25ea:	ed 81       	ldd	r30, Y+5	; 0x05
    25ec:	fe 81       	ldd	r31, Y+6	; 0x06
    25ee:	20 81       	ld	r18, Z
    25f0:	31 81       	ldd	r19, Z+1	; 0x01
    25f2:	8f 81       	ldd	r24, Y+7	; 0x07
    25f4:	98 85       	ldd	r25, Y+8	; 0x08
    25f6:	82 0f       	add	r24, r18
    25f8:	93 1f       	adc	r25, r19
    25fa:	9c 83       	std	Y+4, r25	; 0x04
    25fc:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    25fe:	ed 81       	ldd	r30, Y+5	; 0x05
    2600:	fe 81       	ldd	r31, Y+6	; 0x06
    2602:	20 81       	ld	r18, Z
    2604:	31 81       	ldd	r19, Z+1	; 0x01
    2606:	80 91 f8 06 	lds	r24, 0x06F8
    260a:	90 91 f9 06 	lds	r25, 0x06F9
    260e:	82 17       	cp	r24, r18
    2610:	93 07       	cpc	r25, r19
    2612:	a8 f4       	brcc	.+42     	; 0x263e <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    2614:	ed 81       	ldd	r30, Y+5	; 0x05
    2616:	fe 81       	ldd	r31, Y+6	; 0x06
    2618:	20 81       	ld	r18, Z
    261a:	31 81       	ldd	r19, Z+1	; 0x01
    261c:	8b 81       	ldd	r24, Y+3	; 0x03
    261e:	9c 81       	ldd	r25, Y+4	; 0x04
    2620:	82 17       	cp	r24, r18
    2622:	93 07       	cpc	r25, r19
    2624:	00 f5       	brcc	.+64     	; 0x2666 <vTaskDelayUntil+0x9e>
    2626:	20 91 f8 06 	lds	r18, 0x06F8
    262a:	30 91 f9 06 	lds	r19, 0x06F9
    262e:	8b 81       	ldd	r24, Y+3	; 0x03
    2630:	9c 81       	ldd	r25, Y+4	; 0x04
    2632:	28 17       	cp	r18, r24
    2634:	39 07       	cpc	r19, r25
    2636:	b8 f4       	brcc	.+46     	; 0x2666 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2638:	81 e0       	ldi	r24, 0x01	; 1
    263a:	89 83       	std	Y+1, r24	; 0x01
    263c:	14 c0       	rjmp	.+40     	; 0x2666 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    263e:	ed 81       	ldd	r30, Y+5	; 0x05
    2640:	fe 81       	ldd	r31, Y+6	; 0x06
    2642:	20 81       	ld	r18, Z
    2644:	31 81       	ldd	r19, Z+1	; 0x01
    2646:	8b 81       	ldd	r24, Y+3	; 0x03
    2648:	9c 81       	ldd	r25, Y+4	; 0x04
    264a:	82 17       	cp	r24, r18
    264c:	93 07       	cpc	r25, r19
    264e:	48 f0       	brcs	.+18     	; 0x2662 <vTaskDelayUntil+0x9a>
    2650:	20 91 f8 06 	lds	r18, 0x06F8
    2654:	30 91 f9 06 	lds	r19, 0x06F9
    2658:	8b 81       	ldd	r24, Y+3	; 0x03
    265a:	9c 81       	ldd	r25, Y+4	; 0x04
    265c:	28 17       	cp	r18, r24
    265e:	39 07       	cpc	r19, r25
    2660:	10 f4       	brcc	.+4      	; 0x2666 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2662:	81 e0       	ldi	r24, 0x01	; 1
    2664:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2666:	ed 81       	ldd	r30, Y+5	; 0x05
    2668:	fe 81       	ldd	r31, Y+6	; 0x06
    266a:	8b 81       	ldd	r24, Y+3	; 0x03
    266c:	9c 81       	ldd	r25, Y+4	; 0x04
    266e:	91 83       	std	Z+1, r25	; 0x01
    2670:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    2672:	89 81       	ldd	r24, Y+1	; 0x01
    2674:	88 23       	and	r24, r24
    2676:	59 f0       	breq	.+22     	; 0x268e <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2678:	80 91 f4 06 	lds	r24, 0x06F4
    267c:	90 91 f5 06 	lds	r25, 0x06F5
    2680:	02 96       	adiw	r24, 0x02	; 2
    2682:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2686:	8b 81       	ldd	r24, Y+3	; 0x03
    2688:	9c 81       	ldd	r25, Y+4	; 0x04
    268a:	0e 94 d0 17 	call	0x2fa0	; 0x2fa0 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    268e:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <xTaskResumeAll>
    2692:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2694:	8a 81       	ldd	r24, Y+2	; 0x02
    2696:	88 23       	and	r24, r24
    2698:	11 f4       	brne	.+4      	; 0x269e <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    269a:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <vPortYield>
		}
	}
    269e:	28 96       	adiw	r28, 0x08	; 8
    26a0:	0f b6       	in	r0, 0x3f	; 63
    26a2:	f8 94       	cli
    26a4:	de bf       	out	0x3e, r29	; 62
    26a6:	0f be       	out	0x3f, r0	; 63
    26a8:	cd bf       	out	0x3d, r28	; 61
    26aa:	cf 91       	pop	r28
    26ac:	df 91       	pop	r29
    26ae:	08 95       	ret

000026b0 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    26b0:	df 93       	push	r29
    26b2:	cf 93       	push	r28
    26b4:	00 d0       	rcall	.+0      	; 0x26b6 <vTaskDelay+0x6>
    26b6:	00 d0       	rcall	.+0      	; 0x26b8 <vTaskDelay+0x8>
    26b8:	0f 92       	push	r0
    26ba:	cd b7       	in	r28, 0x3d	; 61
    26bc:	de b7       	in	r29, 0x3e	; 62
    26be:	9d 83       	std	Y+5, r25	; 0x05
    26c0:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    26c2:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    26c4:	8c 81       	ldd	r24, Y+4	; 0x04
    26c6:	9d 81       	ldd	r25, Y+5	; 0x05
    26c8:	00 97       	sbiw	r24, 0x00	; 0
    26ca:	d1 f0       	breq	.+52     	; 0x2700 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    26cc:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    26d0:	20 91 f8 06 	lds	r18, 0x06F8
    26d4:	30 91 f9 06 	lds	r19, 0x06F9
    26d8:	8c 81       	ldd	r24, Y+4	; 0x04
    26da:	9d 81       	ldd	r25, Y+5	; 0x05
    26dc:	82 0f       	add	r24, r18
    26de:	93 1f       	adc	r25, r19
    26e0:	9b 83       	std	Y+3, r25	; 0x03
    26e2:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    26e4:	80 91 f4 06 	lds	r24, 0x06F4
    26e8:	90 91 f5 06 	lds	r25, 0x06F5
    26ec:	02 96       	adiw	r24, 0x02	; 2
    26ee:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    26f2:	8a 81       	ldd	r24, Y+2	; 0x02
    26f4:	9b 81       	ldd	r25, Y+3	; 0x03
    26f6:	0e 94 d0 17 	call	0x2fa0	; 0x2fa0 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    26fa:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <xTaskResumeAll>
    26fe:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2700:	89 81       	ldd	r24, Y+1	; 0x01
    2702:	88 23       	and	r24, r24
    2704:	11 f4       	brne	.+4      	; 0x270a <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    2706:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <vPortYield>
		}
	}
    270a:	0f 90       	pop	r0
    270c:	0f 90       	pop	r0
    270e:	0f 90       	pop	r0
    2710:	0f 90       	pop	r0
    2712:	0f 90       	pop	r0
    2714:	cf 91       	pop	r28
    2716:	df 91       	pop	r29
    2718:	08 95       	ret

0000271a <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    271a:	af 92       	push	r10
    271c:	bf 92       	push	r11
    271e:	cf 92       	push	r12
    2720:	df 92       	push	r13
    2722:	ef 92       	push	r14
    2724:	ff 92       	push	r15
    2726:	0f 93       	push	r16
    2728:	df 93       	push	r29
    272a:	cf 93       	push	r28
    272c:	0f 92       	push	r0
    272e:	cd b7       	in	r28, 0x3d	; 61
    2730:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    2732:	20 e6       	ldi	r18, 0x60	; 96
    2734:	30 e0       	ldi	r19, 0x00	; 0
    2736:	84 ef       	ldi	r24, 0xF4	; 244
    2738:	96 e1       	ldi	r25, 0x16	; 22
    273a:	b9 01       	movw	r22, r18
    273c:	44 e6       	ldi	r20, 0x64	; 100
    273e:	50 e0       	ldi	r21, 0x00	; 0
    2740:	20 e0       	ldi	r18, 0x00	; 0
    2742:	30 e0       	ldi	r19, 0x00	; 0
    2744:	00 e0       	ldi	r16, 0x00	; 0
    2746:	ee 24       	eor	r14, r14
    2748:	ff 24       	eor	r15, r15
    274a:	cc 24       	eor	r12, r12
    274c:	dd 24       	eor	r13, r13
    274e:	aa 24       	eor	r10, r10
    2750:	bb 24       	eor	r11, r11
    2752:	0e 94 94 11 	call	0x2328	; 0x2328 <xTaskGenericCreate>
    2756:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    2758:	89 81       	ldd	r24, Y+1	; 0x01
    275a:	81 30       	cpi	r24, 0x01	; 1
    275c:	51 f4       	brne	.+20     	; 0x2772 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    275e:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    2760:	81 e0       	ldi	r24, 0x01	; 1
    2762:	80 93 fc 06 	sts	0x06FC, r24
		xTickCount = ( portTickType ) 0U;
    2766:	10 92 f9 06 	sts	0x06F9, r1
    276a:	10 92 f8 06 	sts	0x06F8, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    276e:	0e 94 a5 0b 	call	0x174a	; 0x174a <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    2772:	0f 90       	pop	r0
    2774:	cf 91       	pop	r28
    2776:	df 91       	pop	r29
    2778:	0f 91       	pop	r16
    277a:	ff 90       	pop	r15
    277c:	ef 90       	pop	r14
    277e:	df 90       	pop	r13
    2780:	cf 90       	pop	r12
    2782:	bf 90       	pop	r11
    2784:	af 90       	pop	r10
    2786:	08 95       	ret

00002788 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    2788:	df 93       	push	r29
    278a:	cf 93       	push	r28
    278c:	cd b7       	in	r28, 0x3d	; 61
    278e:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    2790:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    2792:	10 92 fc 06 	sts	0x06FC, r1
	vPortEndScheduler();
    2796:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <vPortEndScheduler>
}
    279a:	cf 91       	pop	r28
    279c:	df 91       	pop	r29
    279e:	08 95       	ret

000027a0 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    27a0:	df 93       	push	r29
    27a2:	cf 93       	push	r28
    27a4:	cd b7       	in	r28, 0x3d	; 61
    27a6:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    27a8:	80 91 fd 06 	lds	r24, 0x06FD
    27ac:	8f 5f       	subi	r24, 0xFF	; 255
    27ae:	80 93 fd 06 	sts	0x06FD, r24
}
    27b2:	cf 91       	pop	r28
    27b4:	df 91       	pop	r29
    27b6:	08 95       	ret

000027b8 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    27b8:	df 93       	push	r29
    27ba:	cf 93       	push	r28
    27bc:	00 d0       	rcall	.+0      	; 0x27be <xTaskResumeAll+0x6>
    27be:	00 d0       	rcall	.+0      	; 0x27c0 <xTaskResumeAll+0x8>
    27c0:	cd b7       	in	r28, 0x3d	; 61
    27c2:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    27c4:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    27c6:	0f b6       	in	r0, 0x3f	; 63
    27c8:	f8 94       	cli
    27ca:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    27cc:	80 91 fd 06 	lds	r24, 0x06FD
    27d0:	81 50       	subi	r24, 0x01	; 1
    27d2:	80 93 fd 06 	sts	0x06FD, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    27d6:	80 91 fd 06 	lds	r24, 0x06FD
    27da:	88 23       	and	r24, r24
    27dc:	09 f0       	breq	.+2      	; 0x27e0 <xTaskResumeAll+0x28>
    27de:	6c c0       	rjmp	.+216    	; 0x28b8 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    27e0:	80 91 f7 06 	lds	r24, 0x06F7
    27e4:	88 23       	and	r24, r24
    27e6:	09 f4       	brne	.+2      	; 0x27ea <xTaskResumeAll+0x32>
    27e8:	67 c0       	rjmp	.+206    	; 0x28b8 <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    27ea:	19 82       	std	Y+1, r1	; 0x01
    27ec:	41 c0       	rjmp	.+130    	; 0x2870 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    27ee:	e0 91 4a 07 	lds	r30, 0x074A
    27f2:	f0 91 4b 07 	lds	r31, 0x074B
    27f6:	86 81       	ldd	r24, Z+6	; 0x06
    27f8:	97 81       	ldd	r25, Z+7	; 0x07
    27fa:	9c 83       	std	Y+4, r25	; 0x04
    27fc:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    27fe:	8b 81       	ldd	r24, Y+3	; 0x03
    2800:	9c 81       	ldd	r25, Y+4	; 0x04
    2802:	0c 96       	adiw	r24, 0x0c	; 12
    2804:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    2808:	8b 81       	ldd	r24, Y+3	; 0x03
    280a:	9c 81       	ldd	r25, Y+4	; 0x04
    280c:	02 96       	adiw	r24, 0x02	; 2
    280e:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2812:	eb 81       	ldd	r30, Y+3	; 0x03
    2814:	fc 81       	ldd	r31, Y+4	; 0x04
    2816:	96 89       	ldd	r25, Z+22	; 0x16
    2818:	80 91 fb 06 	lds	r24, 0x06FB
    281c:	89 17       	cp	r24, r25
    281e:	28 f4       	brcc	.+10     	; 0x282a <xTaskResumeAll+0x72>
    2820:	eb 81       	ldd	r30, Y+3	; 0x03
    2822:	fc 81       	ldd	r31, Y+4	; 0x04
    2824:	86 89       	ldd	r24, Z+22	; 0x16
    2826:	80 93 fb 06 	sts	0x06FB, r24
    282a:	eb 81       	ldd	r30, Y+3	; 0x03
    282c:	fc 81       	ldd	r31, Y+4	; 0x04
    282e:	86 89       	ldd	r24, Z+22	; 0x16
    2830:	28 2f       	mov	r18, r24
    2832:	30 e0       	ldi	r19, 0x00	; 0
    2834:	c9 01       	movw	r24, r18
    2836:	88 0f       	add	r24, r24
    2838:	99 1f       	adc	r25, r25
    283a:	88 0f       	add	r24, r24
    283c:	99 1f       	adc	r25, r25
    283e:	88 0f       	add	r24, r24
    2840:	99 1f       	adc	r25, r25
    2842:	82 0f       	add	r24, r18
    2844:	93 1f       	adc	r25, r19
    2846:	8e 5f       	subi	r24, 0xFE	; 254
    2848:	98 4f       	sbci	r25, 0xF8	; 248
    284a:	2b 81       	ldd	r18, Y+3	; 0x03
    284c:	3c 81       	ldd	r19, Y+4	; 0x04
    284e:	2e 5f       	subi	r18, 0xFE	; 254
    2850:	3f 4f       	sbci	r19, 0xFF	; 255
    2852:	b9 01       	movw	r22, r18
    2854:	0e 94 21 09 	call	0x1242	; 0x1242 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2858:	eb 81       	ldd	r30, Y+3	; 0x03
    285a:	fc 81       	ldd	r31, Y+4	; 0x04
    285c:	96 89       	ldd	r25, Z+22	; 0x16
    285e:	e0 91 f4 06 	lds	r30, 0x06F4
    2862:	f0 91 f5 06 	lds	r31, 0x06F5
    2866:	86 89       	ldd	r24, Z+22	; 0x16
    2868:	98 17       	cp	r25, r24
    286a:	10 f0       	brcs	.+4      	; 0x2870 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    286c:	81 e0       	ldi	r24, 0x01	; 1
    286e:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2870:	80 91 45 07 	lds	r24, 0x0745
    2874:	88 23       	and	r24, r24
    2876:	09 f0       	breq	.+2      	; 0x287a <xTaskResumeAll+0xc2>
    2878:	ba cf       	rjmp	.-140    	; 0x27ee <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    287a:	80 91 fe 06 	lds	r24, 0x06FE
    287e:	88 23       	and	r24, r24
    2880:	71 f0       	breq	.+28     	; 0x289e <xTaskResumeAll+0xe6>
    2882:	07 c0       	rjmp	.+14     	; 0x2892 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    2884:	0e 94 9b 14 	call	0x2936	; 0x2936 <vTaskIncrementTick>
						--uxMissedTicks;
    2888:	80 91 fe 06 	lds	r24, 0x06FE
    288c:	81 50       	subi	r24, 0x01	; 1
    288e:	80 93 fe 06 	sts	0x06FE, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2892:	80 91 fe 06 	lds	r24, 0x06FE
    2896:	88 23       	and	r24, r24
    2898:	a9 f7       	brne	.-22     	; 0x2884 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    289a:	81 e0       	ldi	r24, 0x01	; 1
    289c:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    289e:	89 81       	ldd	r24, Y+1	; 0x01
    28a0:	81 30       	cpi	r24, 0x01	; 1
    28a2:	21 f0       	breq	.+8      	; 0x28ac <xTaskResumeAll+0xf4>
    28a4:	80 91 ff 06 	lds	r24, 0x06FF
    28a8:	81 30       	cpi	r24, 0x01	; 1
    28aa:	31 f4       	brne	.+12     	; 0x28b8 <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    28ac:	81 e0       	ldi	r24, 0x01	; 1
    28ae:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    28b0:	10 92 ff 06 	sts	0x06FF, r1
					portYIELD_WITHIN_API();
    28b4:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    28b8:	0f 90       	pop	r0
    28ba:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    28bc:	8a 81       	ldd	r24, Y+2	; 0x02
}
    28be:	0f 90       	pop	r0
    28c0:	0f 90       	pop	r0
    28c2:	0f 90       	pop	r0
    28c4:	0f 90       	pop	r0
    28c6:	cf 91       	pop	r28
    28c8:	df 91       	pop	r29
    28ca:	08 95       	ret

000028cc <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    28cc:	df 93       	push	r29
    28ce:	cf 93       	push	r28
    28d0:	00 d0       	rcall	.+0      	; 0x28d2 <xTaskGetTickCount+0x6>
    28d2:	cd b7       	in	r28, 0x3d	; 61
    28d4:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    28d6:	0f b6       	in	r0, 0x3f	; 63
    28d8:	f8 94       	cli
    28da:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    28dc:	80 91 f8 06 	lds	r24, 0x06F8
    28e0:	90 91 f9 06 	lds	r25, 0x06F9
    28e4:	9a 83       	std	Y+2, r25	; 0x02
    28e6:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    28e8:	0f 90       	pop	r0
    28ea:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    28ec:	89 81       	ldd	r24, Y+1	; 0x01
    28ee:	9a 81       	ldd	r25, Y+2	; 0x02
}
    28f0:	0f 90       	pop	r0
    28f2:	0f 90       	pop	r0
    28f4:	cf 91       	pop	r28
    28f6:	df 91       	pop	r29
    28f8:	08 95       	ret

000028fa <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    28fa:	df 93       	push	r29
    28fc:	cf 93       	push	r28
    28fe:	00 d0       	rcall	.+0      	; 0x2900 <xTaskGetTickCountFromISR+0x6>
    2900:	0f 92       	push	r0
    2902:	cd b7       	in	r28, 0x3d	; 61
    2904:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2906:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    2908:	80 91 f8 06 	lds	r24, 0x06F8
    290c:	90 91 f9 06 	lds	r25, 0x06F9
    2910:	9b 83       	std	Y+3, r25	; 0x03
    2912:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2914:	8a 81       	ldd	r24, Y+2	; 0x02
    2916:	9b 81       	ldd	r25, Y+3	; 0x03
}
    2918:	0f 90       	pop	r0
    291a:	0f 90       	pop	r0
    291c:	0f 90       	pop	r0
    291e:	cf 91       	pop	r28
    2920:	df 91       	pop	r29
    2922:	08 95       	ret

00002924 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    2924:	df 93       	push	r29
    2926:	cf 93       	push	r28
    2928:	cd b7       	in	r28, 0x3d	; 61
    292a:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    292c:	80 91 f7 06 	lds	r24, 0x06F7
}
    2930:	cf 91       	pop	r28
    2932:	df 91       	pop	r29
    2934:	08 95       	ret

00002936 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    2936:	df 93       	push	r29
    2938:	cf 93       	push	r28
    293a:	00 d0       	rcall	.+0      	; 0x293c <vTaskIncrementTick+0x6>
    293c:	00 d0       	rcall	.+0      	; 0x293e <vTaskIncrementTick+0x8>
    293e:	00 d0       	rcall	.+0      	; 0x2940 <vTaskIncrementTick+0xa>
    2940:	cd b7       	in	r28, 0x3d	; 61
    2942:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2944:	80 91 fd 06 	lds	r24, 0x06FD
    2948:	88 23       	and	r24, r24
    294a:	09 f0       	breq	.+2      	; 0x294e <vTaskIncrementTick+0x18>
    294c:	bb c0       	rjmp	.+374    	; 0x2ac4 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    294e:	80 91 f8 06 	lds	r24, 0x06F8
    2952:	90 91 f9 06 	lds	r25, 0x06F9
    2956:	01 96       	adiw	r24, 0x01	; 1
    2958:	90 93 f9 06 	sts	0x06F9, r25
    295c:	80 93 f8 06 	sts	0x06F8, r24
		if( xTickCount == ( portTickType ) 0U )
    2960:	80 91 f8 06 	lds	r24, 0x06F8
    2964:	90 91 f9 06 	lds	r25, 0x06F9
    2968:	00 97       	sbiw	r24, 0x00	; 0
    296a:	d1 f5       	brne	.+116    	; 0x29e0 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    296c:	80 91 41 07 	lds	r24, 0x0741
    2970:	90 91 42 07 	lds	r25, 0x0742
    2974:	9c 83       	std	Y+4, r25	; 0x04
    2976:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    2978:	80 91 43 07 	lds	r24, 0x0743
    297c:	90 91 44 07 	lds	r25, 0x0744
    2980:	90 93 42 07 	sts	0x0742, r25
    2984:	80 93 41 07 	sts	0x0741, r24
			pxOverflowDelayedTaskList = pxTemp;
    2988:	8b 81       	ldd	r24, Y+3	; 0x03
    298a:	9c 81       	ldd	r25, Y+4	; 0x04
    298c:	90 93 44 07 	sts	0x0744, r25
    2990:	80 93 43 07 	sts	0x0743, r24
			xNumOfOverflows++;
    2994:	80 91 00 07 	lds	r24, 0x0700
    2998:	8f 5f       	subi	r24, 0xFF	; 255
    299a:	80 93 00 07 	sts	0x0700, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    299e:	e0 91 41 07 	lds	r30, 0x0741
    29a2:	f0 91 42 07 	lds	r31, 0x0742
    29a6:	80 81       	ld	r24, Z
    29a8:	88 23       	and	r24, r24
    29aa:	39 f4       	brne	.+14     	; 0x29ba <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    29ac:	8f ef       	ldi	r24, 0xFF	; 255
    29ae:	9f ef       	ldi	r25, 0xFF	; 255
    29b0:	90 93 c1 00 	sts	0x00C1, r25
    29b4:	80 93 c0 00 	sts	0x00C0, r24
    29b8:	13 c0       	rjmp	.+38     	; 0x29e0 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    29ba:	e0 91 41 07 	lds	r30, 0x0741
    29be:	f0 91 42 07 	lds	r31, 0x0742
    29c2:	05 80       	ldd	r0, Z+5	; 0x05
    29c4:	f6 81       	ldd	r31, Z+6	; 0x06
    29c6:	e0 2d       	mov	r30, r0
    29c8:	86 81       	ldd	r24, Z+6	; 0x06
    29ca:	97 81       	ldd	r25, Z+7	; 0x07
    29cc:	9e 83       	std	Y+6, r25	; 0x06
    29ce:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    29d0:	ed 81       	ldd	r30, Y+5	; 0x05
    29d2:	fe 81       	ldd	r31, Y+6	; 0x06
    29d4:	82 81       	ldd	r24, Z+2	; 0x02
    29d6:	93 81       	ldd	r25, Z+3	; 0x03
    29d8:	90 93 c1 00 	sts	0x00C1, r25
    29dc:	80 93 c0 00 	sts	0x00C0, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    29e0:	20 91 f8 06 	lds	r18, 0x06F8
    29e4:	30 91 f9 06 	lds	r19, 0x06F9
    29e8:	80 91 c0 00 	lds	r24, 0x00C0
    29ec:	90 91 c1 00 	lds	r25, 0x00C1
    29f0:	28 17       	cp	r18, r24
    29f2:	39 07       	cpc	r19, r25
    29f4:	08 f4       	brcc	.+2      	; 0x29f8 <vTaskIncrementTick+0xc2>
    29f6:	6b c0       	rjmp	.+214    	; 0x2ace <vTaskIncrementTick+0x198>
    29f8:	e0 91 41 07 	lds	r30, 0x0741
    29fc:	f0 91 42 07 	lds	r31, 0x0742
    2a00:	80 81       	ld	r24, Z
    2a02:	88 23       	and	r24, r24
    2a04:	39 f4       	brne	.+14     	; 0x2a14 <vTaskIncrementTick+0xde>
    2a06:	8f ef       	ldi	r24, 0xFF	; 255
    2a08:	9f ef       	ldi	r25, 0xFF	; 255
    2a0a:	90 93 c1 00 	sts	0x00C1, r25
    2a0e:	80 93 c0 00 	sts	0x00C0, r24
    2a12:	5d c0       	rjmp	.+186    	; 0x2ace <vTaskIncrementTick+0x198>
    2a14:	e0 91 41 07 	lds	r30, 0x0741
    2a18:	f0 91 42 07 	lds	r31, 0x0742
    2a1c:	05 80       	ldd	r0, Z+5	; 0x05
    2a1e:	f6 81       	ldd	r31, Z+6	; 0x06
    2a20:	e0 2d       	mov	r30, r0
    2a22:	86 81       	ldd	r24, Z+6	; 0x06
    2a24:	97 81       	ldd	r25, Z+7	; 0x07
    2a26:	9e 83       	std	Y+6, r25	; 0x06
    2a28:	8d 83       	std	Y+5, r24	; 0x05
    2a2a:	ed 81       	ldd	r30, Y+5	; 0x05
    2a2c:	fe 81       	ldd	r31, Y+6	; 0x06
    2a2e:	82 81       	ldd	r24, Z+2	; 0x02
    2a30:	93 81       	ldd	r25, Z+3	; 0x03
    2a32:	9a 83       	std	Y+2, r25	; 0x02
    2a34:	89 83       	std	Y+1, r24	; 0x01
    2a36:	20 91 f8 06 	lds	r18, 0x06F8
    2a3a:	30 91 f9 06 	lds	r19, 0x06F9
    2a3e:	89 81       	ldd	r24, Y+1	; 0x01
    2a40:	9a 81       	ldd	r25, Y+2	; 0x02
    2a42:	28 17       	cp	r18, r24
    2a44:	39 07       	cpc	r19, r25
    2a46:	38 f4       	brcc	.+14     	; 0x2a56 <vTaskIncrementTick+0x120>
    2a48:	89 81       	ldd	r24, Y+1	; 0x01
    2a4a:	9a 81       	ldd	r25, Y+2	; 0x02
    2a4c:	90 93 c1 00 	sts	0x00C1, r25
    2a50:	80 93 c0 00 	sts	0x00C0, r24
    2a54:	3c c0       	rjmp	.+120    	; 0x2ace <vTaskIncrementTick+0x198>
    2a56:	8d 81       	ldd	r24, Y+5	; 0x05
    2a58:	9e 81       	ldd	r25, Y+6	; 0x06
    2a5a:	02 96       	adiw	r24, 0x02	; 2
    2a5c:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>
    2a60:	ed 81       	ldd	r30, Y+5	; 0x05
    2a62:	fe 81       	ldd	r31, Y+6	; 0x06
    2a64:	84 89       	ldd	r24, Z+20	; 0x14
    2a66:	95 89       	ldd	r25, Z+21	; 0x15
    2a68:	00 97       	sbiw	r24, 0x00	; 0
    2a6a:	29 f0       	breq	.+10     	; 0x2a76 <vTaskIncrementTick+0x140>
    2a6c:	8d 81       	ldd	r24, Y+5	; 0x05
    2a6e:	9e 81       	ldd	r25, Y+6	; 0x06
    2a70:	0c 96       	adiw	r24, 0x0c	; 12
    2a72:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>
    2a76:	ed 81       	ldd	r30, Y+5	; 0x05
    2a78:	fe 81       	ldd	r31, Y+6	; 0x06
    2a7a:	96 89       	ldd	r25, Z+22	; 0x16
    2a7c:	80 91 fb 06 	lds	r24, 0x06FB
    2a80:	89 17       	cp	r24, r25
    2a82:	28 f4       	brcc	.+10     	; 0x2a8e <vTaskIncrementTick+0x158>
    2a84:	ed 81       	ldd	r30, Y+5	; 0x05
    2a86:	fe 81       	ldd	r31, Y+6	; 0x06
    2a88:	86 89       	ldd	r24, Z+22	; 0x16
    2a8a:	80 93 fb 06 	sts	0x06FB, r24
    2a8e:	ed 81       	ldd	r30, Y+5	; 0x05
    2a90:	fe 81       	ldd	r31, Y+6	; 0x06
    2a92:	86 89       	ldd	r24, Z+22	; 0x16
    2a94:	28 2f       	mov	r18, r24
    2a96:	30 e0       	ldi	r19, 0x00	; 0
    2a98:	c9 01       	movw	r24, r18
    2a9a:	88 0f       	add	r24, r24
    2a9c:	99 1f       	adc	r25, r25
    2a9e:	88 0f       	add	r24, r24
    2aa0:	99 1f       	adc	r25, r25
    2aa2:	88 0f       	add	r24, r24
    2aa4:	99 1f       	adc	r25, r25
    2aa6:	82 0f       	add	r24, r18
    2aa8:	93 1f       	adc	r25, r19
    2aaa:	ac 01       	movw	r20, r24
    2aac:	4e 5f       	subi	r20, 0xFE	; 254
    2aae:	58 4f       	sbci	r21, 0xF8	; 248
    2ab0:	8d 81       	ldd	r24, Y+5	; 0x05
    2ab2:	9e 81       	ldd	r25, Y+6	; 0x06
    2ab4:	9c 01       	movw	r18, r24
    2ab6:	2e 5f       	subi	r18, 0xFE	; 254
    2ab8:	3f 4f       	sbci	r19, 0xFF	; 255
    2aba:	ca 01       	movw	r24, r20
    2abc:	b9 01       	movw	r22, r18
    2abe:	0e 94 21 09 	call	0x1242	; 0x1242 <vListInsertEnd>
    2ac2:	9a cf       	rjmp	.-204    	; 0x29f8 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    2ac4:	80 91 fe 06 	lds	r24, 0x06FE
    2ac8:	8f 5f       	subi	r24, 0xFF	; 255
    2aca:	80 93 fe 06 	sts	0x06FE, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2ace:	26 96       	adiw	r28, 0x06	; 6
    2ad0:	0f b6       	in	r0, 0x3f	; 63
    2ad2:	f8 94       	cli
    2ad4:	de bf       	out	0x3e, r29	; 62
    2ad6:	0f be       	out	0x3f, r0	; 63
    2ad8:	cd bf       	out	0x3d, r28	; 61
    2ada:	cf 91       	pop	r28
    2adc:	df 91       	pop	r29
    2ade:	08 95       	ret

00002ae0 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    2ae0:	df 93       	push	r29
    2ae2:	cf 93       	push	r28
    2ae4:	00 d0       	rcall	.+0      	; 0x2ae6 <vTaskSwitchContext+0x6>
    2ae6:	cd b7       	in	r28, 0x3d	; 61
    2ae8:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2aea:	80 91 fd 06 	lds	r24, 0x06FD
    2aee:	88 23       	and	r24, r24
    2af0:	49 f0       	breq	.+18     	; 0x2b04 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2af2:	81 e0       	ldi	r24, 0x01	; 1
    2af4:	80 93 ff 06 	sts	0x06FF, r24
    2af8:	54 c0       	rjmp	.+168    	; 0x2ba2 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2afa:	80 91 fb 06 	lds	r24, 0x06FB
    2afe:	81 50       	subi	r24, 0x01	; 1
    2b00:	80 93 fb 06 	sts	0x06FB, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2b04:	80 91 fb 06 	lds	r24, 0x06FB
    2b08:	28 2f       	mov	r18, r24
    2b0a:	30 e0       	ldi	r19, 0x00	; 0
    2b0c:	c9 01       	movw	r24, r18
    2b0e:	88 0f       	add	r24, r24
    2b10:	99 1f       	adc	r25, r25
    2b12:	88 0f       	add	r24, r24
    2b14:	99 1f       	adc	r25, r25
    2b16:	88 0f       	add	r24, r24
    2b18:	99 1f       	adc	r25, r25
    2b1a:	82 0f       	add	r24, r18
    2b1c:	93 1f       	adc	r25, r19
    2b1e:	fc 01       	movw	r30, r24
    2b20:	ee 5f       	subi	r30, 0xFE	; 254
    2b22:	f8 4f       	sbci	r31, 0xF8	; 248
    2b24:	80 81       	ld	r24, Z
    2b26:	88 23       	and	r24, r24
    2b28:	41 f3       	breq	.-48     	; 0x2afa <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2b2a:	80 91 fb 06 	lds	r24, 0x06FB
    2b2e:	28 2f       	mov	r18, r24
    2b30:	30 e0       	ldi	r19, 0x00	; 0
    2b32:	c9 01       	movw	r24, r18
    2b34:	88 0f       	add	r24, r24
    2b36:	99 1f       	adc	r25, r25
    2b38:	88 0f       	add	r24, r24
    2b3a:	99 1f       	adc	r25, r25
    2b3c:	88 0f       	add	r24, r24
    2b3e:	99 1f       	adc	r25, r25
    2b40:	82 0f       	add	r24, r18
    2b42:	93 1f       	adc	r25, r19
    2b44:	8e 5f       	subi	r24, 0xFE	; 254
    2b46:	98 4f       	sbci	r25, 0xF8	; 248
    2b48:	9a 83       	std	Y+2, r25	; 0x02
    2b4a:	89 83       	std	Y+1, r24	; 0x01
    2b4c:	e9 81       	ldd	r30, Y+1	; 0x01
    2b4e:	fa 81       	ldd	r31, Y+2	; 0x02
    2b50:	01 80       	ldd	r0, Z+1	; 0x01
    2b52:	f2 81       	ldd	r31, Z+2	; 0x02
    2b54:	e0 2d       	mov	r30, r0
    2b56:	82 81       	ldd	r24, Z+2	; 0x02
    2b58:	93 81       	ldd	r25, Z+3	; 0x03
    2b5a:	e9 81       	ldd	r30, Y+1	; 0x01
    2b5c:	fa 81       	ldd	r31, Y+2	; 0x02
    2b5e:	92 83       	std	Z+2, r25	; 0x02
    2b60:	81 83       	std	Z+1, r24	; 0x01
    2b62:	e9 81       	ldd	r30, Y+1	; 0x01
    2b64:	fa 81       	ldd	r31, Y+2	; 0x02
    2b66:	21 81       	ldd	r18, Z+1	; 0x01
    2b68:	32 81       	ldd	r19, Z+2	; 0x02
    2b6a:	89 81       	ldd	r24, Y+1	; 0x01
    2b6c:	9a 81       	ldd	r25, Y+2	; 0x02
    2b6e:	03 96       	adiw	r24, 0x03	; 3
    2b70:	28 17       	cp	r18, r24
    2b72:	39 07       	cpc	r19, r25
    2b74:	59 f4       	brne	.+22     	; 0x2b8c <vTaskSwitchContext+0xac>
    2b76:	e9 81       	ldd	r30, Y+1	; 0x01
    2b78:	fa 81       	ldd	r31, Y+2	; 0x02
    2b7a:	01 80       	ldd	r0, Z+1	; 0x01
    2b7c:	f2 81       	ldd	r31, Z+2	; 0x02
    2b7e:	e0 2d       	mov	r30, r0
    2b80:	82 81       	ldd	r24, Z+2	; 0x02
    2b82:	93 81       	ldd	r25, Z+3	; 0x03
    2b84:	e9 81       	ldd	r30, Y+1	; 0x01
    2b86:	fa 81       	ldd	r31, Y+2	; 0x02
    2b88:	92 83       	std	Z+2, r25	; 0x02
    2b8a:	81 83       	std	Z+1, r24	; 0x01
    2b8c:	e9 81       	ldd	r30, Y+1	; 0x01
    2b8e:	fa 81       	ldd	r31, Y+2	; 0x02
    2b90:	01 80       	ldd	r0, Z+1	; 0x01
    2b92:	f2 81       	ldd	r31, Z+2	; 0x02
    2b94:	e0 2d       	mov	r30, r0
    2b96:	86 81       	ldd	r24, Z+6	; 0x06
    2b98:	97 81       	ldd	r25, Z+7	; 0x07
    2b9a:	90 93 f5 06 	sts	0x06F5, r25
    2b9e:	80 93 f4 06 	sts	0x06F4, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    2ba2:	0f 90       	pop	r0
    2ba4:	0f 90       	pop	r0
    2ba6:	cf 91       	pop	r28
    2ba8:	df 91       	pop	r29
    2baa:	08 95       	ret

00002bac <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2bac:	df 93       	push	r29
    2bae:	cf 93       	push	r28
    2bb0:	00 d0       	rcall	.+0      	; 0x2bb2 <vTaskPlaceOnEventList+0x6>
    2bb2:	00 d0       	rcall	.+0      	; 0x2bb4 <vTaskPlaceOnEventList+0x8>
    2bb4:	00 d0       	rcall	.+0      	; 0x2bb6 <vTaskPlaceOnEventList+0xa>
    2bb6:	cd b7       	in	r28, 0x3d	; 61
    2bb8:	de b7       	in	r29, 0x3e	; 62
    2bba:	9c 83       	std	Y+4, r25	; 0x04
    2bbc:	8b 83       	std	Y+3, r24	; 0x03
    2bbe:	7e 83       	std	Y+6, r23	; 0x06
    2bc0:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2bc2:	4b 81       	ldd	r20, Y+3	; 0x03
    2bc4:	5c 81       	ldd	r21, Y+4	; 0x04
    2bc6:	80 91 f4 06 	lds	r24, 0x06F4
    2bca:	90 91 f5 06 	lds	r25, 0x06F5
    2bce:	9c 01       	movw	r18, r24
    2bd0:	24 5f       	subi	r18, 0xF4	; 244
    2bd2:	3f 4f       	sbci	r19, 0xFF	; 255
    2bd4:	ca 01       	movw	r24, r20
    2bd6:	b9 01       	movw	r22, r18
    2bd8:	0e 94 6d 09 	call	0x12da	; 0x12da <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2bdc:	80 91 f4 06 	lds	r24, 0x06F4
    2be0:	90 91 f5 06 	lds	r25, 0x06F5
    2be4:	02 96       	adiw	r24, 0x02	; 2
    2be6:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2bea:	20 91 f8 06 	lds	r18, 0x06F8
    2bee:	30 91 f9 06 	lds	r19, 0x06F9
    2bf2:	8d 81       	ldd	r24, Y+5	; 0x05
    2bf4:	9e 81       	ldd	r25, Y+6	; 0x06
    2bf6:	82 0f       	add	r24, r18
    2bf8:	93 1f       	adc	r25, r19
    2bfa:	9a 83       	std	Y+2, r25	; 0x02
    2bfc:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2bfe:	89 81       	ldd	r24, Y+1	; 0x01
    2c00:	9a 81       	ldd	r25, Y+2	; 0x02
    2c02:	0e 94 d0 17 	call	0x2fa0	; 0x2fa0 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2c06:	26 96       	adiw	r28, 0x06	; 6
    2c08:	0f b6       	in	r0, 0x3f	; 63
    2c0a:	f8 94       	cli
    2c0c:	de bf       	out	0x3e, r29	; 62
    2c0e:	0f be       	out	0x3f, r0	; 63
    2c10:	cd bf       	out	0x3d, r28	; 61
    2c12:	cf 91       	pop	r28
    2c14:	df 91       	pop	r29
    2c16:	08 95       	ret

00002c18 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2c18:	df 93       	push	r29
    2c1a:	cf 93       	push	r28
    2c1c:	00 d0       	rcall	.+0      	; 0x2c1e <xTaskRemoveFromEventList+0x6>
    2c1e:	00 d0       	rcall	.+0      	; 0x2c20 <xTaskRemoveFromEventList+0x8>
    2c20:	0f 92       	push	r0
    2c22:	cd b7       	in	r28, 0x3d	; 61
    2c24:	de b7       	in	r29, 0x3e	; 62
    2c26:	9d 83       	std	Y+5, r25	; 0x05
    2c28:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2c2a:	ec 81       	ldd	r30, Y+4	; 0x04
    2c2c:	fd 81       	ldd	r31, Y+5	; 0x05
    2c2e:	05 80       	ldd	r0, Z+5	; 0x05
    2c30:	f6 81       	ldd	r31, Z+6	; 0x06
    2c32:	e0 2d       	mov	r30, r0
    2c34:	86 81       	ldd	r24, Z+6	; 0x06
    2c36:	97 81       	ldd	r25, Z+7	; 0x07
    2c38:	9b 83       	std	Y+3, r25	; 0x03
    2c3a:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2c3c:	8a 81       	ldd	r24, Y+2	; 0x02
    2c3e:	9b 81       	ldd	r25, Y+3	; 0x03
    2c40:	0c 96       	adiw	r24, 0x0c	; 12
    2c42:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2c46:	80 91 fd 06 	lds	r24, 0x06FD
    2c4a:	88 23       	and	r24, r24
    2c4c:	61 f5       	brne	.+88     	; 0x2ca6 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2c4e:	8a 81       	ldd	r24, Y+2	; 0x02
    2c50:	9b 81       	ldd	r25, Y+3	; 0x03
    2c52:	02 96       	adiw	r24, 0x02	; 2
    2c54:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2c58:	ea 81       	ldd	r30, Y+2	; 0x02
    2c5a:	fb 81       	ldd	r31, Y+3	; 0x03
    2c5c:	96 89       	ldd	r25, Z+22	; 0x16
    2c5e:	80 91 fb 06 	lds	r24, 0x06FB
    2c62:	89 17       	cp	r24, r25
    2c64:	28 f4       	brcc	.+10     	; 0x2c70 <xTaskRemoveFromEventList+0x58>
    2c66:	ea 81       	ldd	r30, Y+2	; 0x02
    2c68:	fb 81       	ldd	r31, Y+3	; 0x03
    2c6a:	86 89       	ldd	r24, Z+22	; 0x16
    2c6c:	80 93 fb 06 	sts	0x06FB, r24
    2c70:	ea 81       	ldd	r30, Y+2	; 0x02
    2c72:	fb 81       	ldd	r31, Y+3	; 0x03
    2c74:	86 89       	ldd	r24, Z+22	; 0x16
    2c76:	28 2f       	mov	r18, r24
    2c78:	30 e0       	ldi	r19, 0x00	; 0
    2c7a:	c9 01       	movw	r24, r18
    2c7c:	88 0f       	add	r24, r24
    2c7e:	99 1f       	adc	r25, r25
    2c80:	88 0f       	add	r24, r24
    2c82:	99 1f       	adc	r25, r25
    2c84:	88 0f       	add	r24, r24
    2c86:	99 1f       	adc	r25, r25
    2c88:	82 0f       	add	r24, r18
    2c8a:	93 1f       	adc	r25, r19
    2c8c:	ac 01       	movw	r20, r24
    2c8e:	4e 5f       	subi	r20, 0xFE	; 254
    2c90:	58 4f       	sbci	r21, 0xF8	; 248
    2c92:	8a 81       	ldd	r24, Y+2	; 0x02
    2c94:	9b 81       	ldd	r25, Y+3	; 0x03
    2c96:	9c 01       	movw	r18, r24
    2c98:	2e 5f       	subi	r18, 0xFE	; 254
    2c9a:	3f 4f       	sbci	r19, 0xFF	; 255
    2c9c:	ca 01       	movw	r24, r20
    2c9e:	b9 01       	movw	r22, r18
    2ca0:	0e 94 21 09 	call	0x1242	; 0x1242 <vListInsertEnd>
    2ca4:	0a c0       	rjmp	.+20     	; 0x2cba <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2ca6:	8a 81       	ldd	r24, Y+2	; 0x02
    2ca8:	9b 81       	ldd	r25, Y+3	; 0x03
    2caa:	9c 01       	movw	r18, r24
    2cac:	24 5f       	subi	r18, 0xF4	; 244
    2cae:	3f 4f       	sbci	r19, 0xFF	; 255
    2cb0:	85 e4       	ldi	r24, 0x45	; 69
    2cb2:	97 e0       	ldi	r25, 0x07	; 7
    2cb4:	b9 01       	movw	r22, r18
    2cb6:	0e 94 21 09 	call	0x1242	; 0x1242 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2cba:	ea 81       	ldd	r30, Y+2	; 0x02
    2cbc:	fb 81       	ldd	r31, Y+3	; 0x03
    2cbe:	96 89       	ldd	r25, Z+22	; 0x16
    2cc0:	e0 91 f4 06 	lds	r30, 0x06F4
    2cc4:	f0 91 f5 06 	lds	r31, 0x06F5
    2cc8:	86 89       	ldd	r24, Z+22	; 0x16
    2cca:	98 17       	cp	r25, r24
    2ccc:	18 f0       	brcs	.+6      	; 0x2cd4 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    2cce:	81 e0       	ldi	r24, 0x01	; 1
    2cd0:	89 83       	std	Y+1, r24	; 0x01
    2cd2:	01 c0       	rjmp	.+2      	; 0x2cd6 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    2cd4:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2cd6:	89 81       	ldd	r24, Y+1	; 0x01
}
    2cd8:	0f 90       	pop	r0
    2cda:	0f 90       	pop	r0
    2cdc:	0f 90       	pop	r0
    2cde:	0f 90       	pop	r0
    2ce0:	0f 90       	pop	r0
    2ce2:	cf 91       	pop	r28
    2ce4:	df 91       	pop	r29
    2ce6:	08 95       	ret

00002ce8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    2ce8:	df 93       	push	r29
    2cea:	cf 93       	push	r28
    2cec:	00 d0       	rcall	.+0      	; 0x2cee <vTaskSetTimeOutState+0x6>
    2cee:	cd b7       	in	r28, 0x3d	; 61
    2cf0:	de b7       	in	r29, 0x3e	; 62
    2cf2:	9a 83       	std	Y+2, r25	; 0x02
    2cf4:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2cf6:	80 91 00 07 	lds	r24, 0x0700
    2cfa:	e9 81       	ldd	r30, Y+1	; 0x01
    2cfc:	fa 81       	ldd	r31, Y+2	; 0x02
    2cfe:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    2d00:	80 91 f8 06 	lds	r24, 0x06F8
    2d04:	90 91 f9 06 	lds	r25, 0x06F9
    2d08:	e9 81       	ldd	r30, Y+1	; 0x01
    2d0a:	fa 81       	ldd	r31, Y+2	; 0x02
    2d0c:	92 83       	std	Z+2, r25	; 0x02
    2d0e:	81 83       	std	Z+1, r24	; 0x01
}
    2d10:	0f 90       	pop	r0
    2d12:	0f 90       	pop	r0
    2d14:	cf 91       	pop	r28
    2d16:	df 91       	pop	r29
    2d18:	08 95       	ret

00002d1a <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2d1a:	df 93       	push	r29
    2d1c:	cf 93       	push	r28
    2d1e:	00 d0       	rcall	.+0      	; 0x2d20 <xTaskCheckForTimeOut+0x6>
    2d20:	00 d0       	rcall	.+0      	; 0x2d22 <xTaskCheckForTimeOut+0x8>
    2d22:	0f 92       	push	r0
    2d24:	cd b7       	in	r28, 0x3d	; 61
    2d26:	de b7       	in	r29, 0x3e	; 62
    2d28:	9b 83       	std	Y+3, r25	; 0x03
    2d2a:	8a 83       	std	Y+2, r24	; 0x02
    2d2c:	7d 83       	std	Y+5, r23	; 0x05
    2d2e:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2d30:	0f b6       	in	r0, 0x3f	; 63
    2d32:	f8 94       	cli
    2d34:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2d36:	ea 81       	ldd	r30, Y+2	; 0x02
    2d38:	fb 81       	ldd	r31, Y+3	; 0x03
    2d3a:	90 81       	ld	r25, Z
    2d3c:	80 91 00 07 	lds	r24, 0x0700
    2d40:	98 17       	cp	r25, r24
    2d42:	71 f0       	breq	.+28     	; 0x2d60 <xTaskCheckForTimeOut+0x46>
    2d44:	ea 81       	ldd	r30, Y+2	; 0x02
    2d46:	fb 81       	ldd	r31, Y+3	; 0x03
    2d48:	21 81       	ldd	r18, Z+1	; 0x01
    2d4a:	32 81       	ldd	r19, Z+2	; 0x02
    2d4c:	80 91 f8 06 	lds	r24, 0x06F8
    2d50:	90 91 f9 06 	lds	r25, 0x06F9
    2d54:	82 17       	cp	r24, r18
    2d56:	93 07       	cpc	r25, r19
    2d58:	18 f0       	brcs	.+6      	; 0x2d60 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2d5a:	81 e0       	ldi	r24, 0x01	; 1
    2d5c:	89 83       	std	Y+1, r24	; 0x01
    2d5e:	2f c0       	rjmp	.+94     	; 0x2dbe <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2d60:	20 91 f8 06 	lds	r18, 0x06F8
    2d64:	30 91 f9 06 	lds	r19, 0x06F9
    2d68:	ea 81       	ldd	r30, Y+2	; 0x02
    2d6a:	fb 81       	ldd	r31, Y+3	; 0x03
    2d6c:	81 81       	ldd	r24, Z+1	; 0x01
    2d6e:	92 81       	ldd	r25, Z+2	; 0x02
    2d70:	28 1b       	sub	r18, r24
    2d72:	39 0b       	sbc	r19, r25
    2d74:	ec 81       	ldd	r30, Y+4	; 0x04
    2d76:	fd 81       	ldd	r31, Y+5	; 0x05
    2d78:	80 81       	ld	r24, Z
    2d7a:	91 81       	ldd	r25, Z+1	; 0x01
    2d7c:	28 17       	cp	r18, r24
    2d7e:	39 07       	cpc	r19, r25
    2d80:	e0 f4       	brcc	.+56     	; 0x2dba <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2d82:	ec 81       	ldd	r30, Y+4	; 0x04
    2d84:	fd 81       	ldd	r31, Y+5	; 0x05
    2d86:	40 81       	ld	r20, Z
    2d88:	51 81       	ldd	r21, Z+1	; 0x01
    2d8a:	ea 81       	ldd	r30, Y+2	; 0x02
    2d8c:	fb 81       	ldd	r31, Y+3	; 0x03
    2d8e:	21 81       	ldd	r18, Z+1	; 0x01
    2d90:	32 81       	ldd	r19, Z+2	; 0x02
    2d92:	80 91 f8 06 	lds	r24, 0x06F8
    2d96:	90 91 f9 06 	lds	r25, 0x06F9
    2d9a:	b9 01       	movw	r22, r18
    2d9c:	68 1b       	sub	r22, r24
    2d9e:	79 0b       	sbc	r23, r25
    2da0:	cb 01       	movw	r24, r22
    2da2:	84 0f       	add	r24, r20
    2da4:	95 1f       	adc	r25, r21
    2da6:	ec 81       	ldd	r30, Y+4	; 0x04
    2da8:	fd 81       	ldd	r31, Y+5	; 0x05
    2daa:	91 83       	std	Z+1, r25	; 0x01
    2dac:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    2dae:	8a 81       	ldd	r24, Y+2	; 0x02
    2db0:	9b 81       	ldd	r25, Y+3	; 0x03
    2db2:	0e 94 74 16 	call	0x2ce8	; 0x2ce8 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2db6:	19 82       	std	Y+1, r1	; 0x01
    2db8:	02 c0       	rjmp	.+4      	; 0x2dbe <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    2dba:	81 e0       	ldi	r24, 0x01	; 1
    2dbc:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2dbe:	0f 90       	pop	r0
    2dc0:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2dc2:	89 81       	ldd	r24, Y+1	; 0x01
}
    2dc4:	0f 90       	pop	r0
    2dc6:	0f 90       	pop	r0
    2dc8:	0f 90       	pop	r0
    2dca:	0f 90       	pop	r0
    2dcc:	0f 90       	pop	r0
    2dce:	cf 91       	pop	r28
    2dd0:	df 91       	pop	r29
    2dd2:	08 95       	ret

00002dd4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    2dd4:	df 93       	push	r29
    2dd6:	cf 93       	push	r28
    2dd8:	cd b7       	in	r28, 0x3d	; 61
    2dda:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    2ddc:	81 e0       	ldi	r24, 0x01	; 1
    2dde:	80 93 ff 06 	sts	0x06FF, r24
}
    2de2:	cf 91       	pop	r28
    2de4:	df 91       	pop	r29
    2de6:	08 95       	ret

00002de8 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    2de8:	df 93       	push	r29
    2dea:	cf 93       	push	r28
    2dec:	00 d0       	rcall	.+0      	; 0x2dee <prvIdleTask+0x6>
    2dee:	cd b7       	in	r28, 0x3d	; 61
    2df0:	de b7       	in	r29, 0x3e	; 62
    2df2:	9a 83       	std	Y+2, r25	; 0x02
    2df4:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    2df6:	0e 94 92 17 	call	0x2f24	; 0x2f24 <prvCheckTasksWaitingTermination>
    2dfa:	fd cf       	rjmp	.-6      	; 0x2df6 <prvIdleTask+0xe>

00002dfc <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    2dfc:	0f 93       	push	r16
    2dfe:	1f 93       	push	r17
    2e00:	df 93       	push	r29
    2e02:	cf 93       	push	r28
    2e04:	cd b7       	in	r28, 0x3d	; 61
    2e06:	de b7       	in	r29, 0x3e	; 62
    2e08:	29 97       	sbiw	r28, 0x09	; 9
    2e0a:	0f b6       	in	r0, 0x3f	; 63
    2e0c:	f8 94       	cli
    2e0e:	de bf       	out	0x3e, r29	; 62
    2e10:	0f be       	out	0x3f, r0	; 63
    2e12:	cd bf       	out	0x3d, r28	; 61
    2e14:	9a 83       	std	Y+2, r25	; 0x02
    2e16:	89 83       	std	Y+1, r24	; 0x01
    2e18:	7c 83       	std	Y+4, r23	; 0x04
    2e1a:	6b 83       	std	Y+3, r22	; 0x03
    2e1c:	4d 83       	std	Y+5, r20	; 0x05
    2e1e:	3f 83       	std	Y+7, r19	; 0x07
    2e20:	2e 83       	std	Y+6, r18	; 0x06
    2e22:	19 87       	std	Y+9, r17	; 0x09
    2e24:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    2e26:	89 81       	ldd	r24, Y+1	; 0x01
    2e28:	9a 81       	ldd	r25, Y+2	; 0x02
    2e2a:	49 96       	adiw	r24, 0x19	; 25
    2e2c:	2b 81       	ldd	r18, Y+3	; 0x03
    2e2e:	3c 81       	ldd	r19, Y+4	; 0x04
    2e30:	b9 01       	movw	r22, r18
    2e32:	48 e0       	ldi	r20, 0x08	; 8
    2e34:	50 e0       	ldi	r21, 0x00	; 0
    2e36:	0e 94 35 36 	call	0x6c6a	; 0x6c6a <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    2e3a:	e9 81       	ldd	r30, Y+1	; 0x01
    2e3c:	fa 81       	ldd	r31, Y+2	; 0x02
    2e3e:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    2e40:	8d 81       	ldd	r24, Y+5	; 0x05
    2e42:	85 30       	cpi	r24, 0x05	; 5
    2e44:	10 f0       	brcs	.+4      	; 0x2e4a <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    2e46:	84 e0       	ldi	r24, 0x04	; 4
    2e48:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    2e4a:	e9 81       	ldd	r30, Y+1	; 0x01
    2e4c:	fa 81       	ldd	r31, Y+2	; 0x02
    2e4e:	8d 81       	ldd	r24, Y+5	; 0x05
    2e50:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    2e52:	89 81       	ldd	r24, Y+1	; 0x01
    2e54:	9a 81       	ldd	r25, Y+2	; 0x02
    2e56:	02 96       	adiw	r24, 0x02	; 2
    2e58:	0e 94 11 09 	call	0x1222	; 0x1222 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    2e5c:	89 81       	ldd	r24, Y+1	; 0x01
    2e5e:	9a 81       	ldd	r25, Y+2	; 0x02
    2e60:	0c 96       	adiw	r24, 0x0c	; 12
    2e62:	0e 94 11 09 	call	0x1222	; 0x1222 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    2e66:	e9 81       	ldd	r30, Y+1	; 0x01
    2e68:	fa 81       	ldd	r31, Y+2	; 0x02
    2e6a:	89 81       	ldd	r24, Y+1	; 0x01
    2e6c:	9a 81       	ldd	r25, Y+2	; 0x02
    2e6e:	91 87       	std	Z+9, r25	; 0x09
    2e70:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2e72:	8d 81       	ldd	r24, Y+5	; 0x05
    2e74:	28 2f       	mov	r18, r24
    2e76:	30 e0       	ldi	r19, 0x00	; 0
    2e78:	85 e0       	ldi	r24, 0x05	; 5
    2e7a:	90 e0       	ldi	r25, 0x00	; 0
    2e7c:	82 1b       	sub	r24, r18
    2e7e:	93 0b       	sbc	r25, r19
    2e80:	e9 81       	ldd	r30, Y+1	; 0x01
    2e82:	fa 81       	ldd	r31, Y+2	; 0x02
    2e84:	95 87       	std	Z+13, r25	; 0x0d
    2e86:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2e88:	e9 81       	ldd	r30, Y+1	; 0x01
    2e8a:	fa 81       	ldd	r31, Y+2	; 0x02
    2e8c:	89 81       	ldd	r24, Y+1	; 0x01
    2e8e:	9a 81       	ldd	r25, Y+2	; 0x02
    2e90:	93 8b       	std	Z+19, r25	; 0x13
    2e92:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    2e94:	29 96       	adiw	r28, 0x09	; 9
    2e96:	0f b6       	in	r0, 0x3f	; 63
    2e98:	f8 94       	cli
    2e9a:	de bf       	out	0x3e, r29	; 62
    2e9c:	0f be       	out	0x3f, r0	; 63
    2e9e:	cd bf       	out	0x3d, r28	; 61
    2ea0:	cf 91       	pop	r28
    2ea2:	df 91       	pop	r29
    2ea4:	1f 91       	pop	r17
    2ea6:	0f 91       	pop	r16
    2ea8:	08 95       	ret

00002eaa <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    2eaa:	df 93       	push	r29
    2eac:	cf 93       	push	r28
    2eae:	0f 92       	push	r0
    2eb0:	cd b7       	in	r28, 0x3d	; 61
    2eb2:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2eb4:	19 82       	std	Y+1, r1	; 0x01
    2eb6:	13 c0       	rjmp	.+38     	; 0x2ede <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    2eb8:	89 81       	ldd	r24, Y+1	; 0x01
    2eba:	28 2f       	mov	r18, r24
    2ebc:	30 e0       	ldi	r19, 0x00	; 0
    2ebe:	c9 01       	movw	r24, r18
    2ec0:	88 0f       	add	r24, r24
    2ec2:	99 1f       	adc	r25, r25
    2ec4:	88 0f       	add	r24, r24
    2ec6:	99 1f       	adc	r25, r25
    2ec8:	88 0f       	add	r24, r24
    2eca:	99 1f       	adc	r25, r25
    2ecc:	82 0f       	add	r24, r18
    2ece:	93 1f       	adc	r25, r19
    2ed0:	8e 5f       	subi	r24, 0xFE	; 254
    2ed2:	98 4f       	sbci	r25, 0xF8	; 248
    2ed4:	0e 94 e7 08 	call	0x11ce	; 0x11ce <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2ed8:	89 81       	ldd	r24, Y+1	; 0x01
    2eda:	8f 5f       	subi	r24, 0xFF	; 255
    2edc:	89 83       	std	Y+1, r24	; 0x01
    2ede:	89 81       	ldd	r24, Y+1	; 0x01
    2ee0:	85 30       	cpi	r24, 0x05	; 5
    2ee2:	50 f3       	brcs	.-44     	; 0x2eb8 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    2ee4:	8f e2       	ldi	r24, 0x2F	; 47
    2ee6:	97 e0       	ldi	r25, 0x07	; 7
    2ee8:	0e 94 e7 08 	call	0x11ce	; 0x11ce <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    2eec:	88 e3       	ldi	r24, 0x38	; 56
    2eee:	97 e0       	ldi	r25, 0x07	; 7
    2ef0:	0e 94 e7 08 	call	0x11ce	; 0x11ce <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    2ef4:	85 e4       	ldi	r24, 0x45	; 69
    2ef6:	97 e0       	ldi	r25, 0x07	; 7
    2ef8:	0e 94 e7 08 	call	0x11ce	; 0x11ce <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    2efc:	8e e4       	ldi	r24, 0x4E	; 78
    2efe:	97 e0       	ldi	r25, 0x07	; 7
    2f00:	0e 94 e7 08 	call	0x11ce	; 0x11ce <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    2f04:	8f e2       	ldi	r24, 0x2F	; 47
    2f06:	97 e0       	ldi	r25, 0x07	; 7
    2f08:	90 93 42 07 	sts	0x0742, r25
    2f0c:	80 93 41 07 	sts	0x0741, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2f10:	88 e3       	ldi	r24, 0x38	; 56
    2f12:	97 e0       	ldi	r25, 0x07	; 7
    2f14:	90 93 44 07 	sts	0x0744, r25
    2f18:	80 93 43 07 	sts	0x0743, r24
}
    2f1c:	0f 90       	pop	r0
    2f1e:	cf 91       	pop	r28
    2f20:	df 91       	pop	r29
    2f22:	08 95       	ret

00002f24 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    2f24:	df 93       	push	r29
    2f26:	cf 93       	push	r28
    2f28:	00 d0       	rcall	.+0      	; 0x2f2a <prvCheckTasksWaitingTermination+0x6>
    2f2a:	0f 92       	push	r0
    2f2c:	cd b7       	in	r28, 0x3d	; 61
    2f2e:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    2f30:	80 91 f6 06 	lds	r24, 0x06F6
    2f34:	88 23       	and	r24, r24
    2f36:	71 f1       	breq	.+92     	; 0x2f94 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    2f38:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    2f3c:	80 91 4e 07 	lds	r24, 0x074E
    2f40:	1b 82       	std	Y+3, r1	; 0x03
    2f42:	88 23       	and	r24, r24
    2f44:	11 f4       	brne	.+4      	; 0x2f4a <prvCheckTasksWaitingTermination+0x26>
    2f46:	81 e0       	ldi	r24, 0x01	; 1
    2f48:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    2f4a:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    2f4e:	8b 81       	ldd	r24, Y+3	; 0x03
    2f50:	88 23       	and	r24, r24
    2f52:	01 f5       	brne	.+64     	; 0x2f94 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    2f54:	0f b6       	in	r0, 0x3f	; 63
    2f56:	f8 94       	cli
    2f58:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    2f5a:	e0 91 53 07 	lds	r30, 0x0753
    2f5e:	f0 91 54 07 	lds	r31, 0x0754
    2f62:	86 81       	ldd	r24, Z+6	; 0x06
    2f64:	97 81       	ldd	r25, Z+7	; 0x07
    2f66:	9a 83       	std	Y+2, r25	; 0x02
    2f68:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    2f6a:	89 81       	ldd	r24, Y+1	; 0x01
    2f6c:	9a 81       	ldd	r25, Y+2	; 0x02
    2f6e:	02 96       	adiw	r24, 0x02	; 2
    2f70:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vListRemove>
					--uxCurrentNumberOfTasks;
    2f74:	80 91 f7 06 	lds	r24, 0x06F7
    2f78:	81 50       	subi	r24, 0x01	; 1
    2f7a:	80 93 f7 06 	sts	0x06F7, r24
					--uxTasksDeleted;
    2f7e:	80 91 f6 06 	lds	r24, 0x06F6
    2f82:	81 50       	subi	r24, 0x01	; 1
    2f84:	80 93 f6 06 	sts	0x06F6, r24
				}
				taskEXIT_CRITICAL();
    2f88:	0f 90       	pop	r0
    2f8a:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    2f8c:	89 81       	ldd	r24, Y+1	; 0x01
    2f8e:	9a 81       	ldd	r25, Y+2	; 0x02
    2f90:	0e 94 69 18 	call	0x30d2	; 0x30d2 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    2f94:	0f 90       	pop	r0
    2f96:	0f 90       	pop	r0
    2f98:	0f 90       	pop	r0
    2f9a:	cf 91       	pop	r28
    2f9c:	df 91       	pop	r29
    2f9e:	08 95       	ret

00002fa0 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    2fa0:	df 93       	push	r29
    2fa2:	cf 93       	push	r28
    2fa4:	00 d0       	rcall	.+0      	; 0x2fa6 <prvAddCurrentTaskToDelayedList+0x6>
    2fa6:	cd b7       	in	r28, 0x3d	; 61
    2fa8:	de b7       	in	r29, 0x3e	; 62
    2faa:	9a 83       	std	Y+2, r25	; 0x02
    2fac:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2fae:	e0 91 f4 06 	lds	r30, 0x06F4
    2fb2:	f0 91 f5 06 	lds	r31, 0x06F5
    2fb6:	89 81       	ldd	r24, Y+1	; 0x01
    2fb8:	9a 81       	ldd	r25, Y+2	; 0x02
    2fba:	93 83       	std	Z+3, r25	; 0x03
    2fbc:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    2fbe:	20 91 f8 06 	lds	r18, 0x06F8
    2fc2:	30 91 f9 06 	lds	r19, 0x06F9
    2fc6:	89 81       	ldd	r24, Y+1	; 0x01
    2fc8:	9a 81       	ldd	r25, Y+2	; 0x02
    2fca:	82 17       	cp	r24, r18
    2fcc:	93 07       	cpc	r25, r19
    2fce:	70 f4       	brcc	.+28     	; 0x2fec <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2fd0:	80 91 43 07 	lds	r24, 0x0743
    2fd4:	90 91 44 07 	lds	r25, 0x0744
    2fd8:	20 91 f4 06 	lds	r18, 0x06F4
    2fdc:	30 91 f5 06 	lds	r19, 0x06F5
    2fe0:	2e 5f       	subi	r18, 0xFE	; 254
    2fe2:	3f 4f       	sbci	r19, 0xFF	; 255
    2fe4:	b9 01       	movw	r22, r18
    2fe6:	0e 94 6d 09 	call	0x12da	; 0x12da <vListInsert>
    2fea:	1e c0       	rjmp	.+60     	; 0x3028 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2fec:	40 91 41 07 	lds	r20, 0x0741
    2ff0:	50 91 42 07 	lds	r21, 0x0742
    2ff4:	80 91 f4 06 	lds	r24, 0x06F4
    2ff8:	90 91 f5 06 	lds	r25, 0x06F5
    2ffc:	9c 01       	movw	r18, r24
    2ffe:	2e 5f       	subi	r18, 0xFE	; 254
    3000:	3f 4f       	sbci	r19, 0xFF	; 255
    3002:	ca 01       	movw	r24, r20
    3004:	b9 01       	movw	r22, r18
    3006:	0e 94 6d 09 	call	0x12da	; 0x12da <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    300a:	20 91 c0 00 	lds	r18, 0x00C0
    300e:	30 91 c1 00 	lds	r19, 0x00C1
    3012:	89 81       	ldd	r24, Y+1	; 0x01
    3014:	9a 81       	ldd	r25, Y+2	; 0x02
    3016:	82 17       	cp	r24, r18
    3018:	93 07       	cpc	r25, r19
    301a:	30 f4       	brcc	.+12     	; 0x3028 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    301c:	89 81       	ldd	r24, Y+1	; 0x01
    301e:	9a 81       	ldd	r25, Y+2	; 0x02
    3020:	90 93 c1 00 	sts	0x00C1, r25
    3024:	80 93 c0 00 	sts	0x00C0, r24
		}
	}
}
    3028:	0f 90       	pop	r0
    302a:	0f 90       	pop	r0
    302c:	cf 91       	pop	r28
    302e:	df 91       	pop	r29
    3030:	08 95       	ret

00003032 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    3032:	df 93       	push	r29
    3034:	cf 93       	push	r28
    3036:	cd b7       	in	r28, 0x3d	; 61
    3038:	de b7       	in	r29, 0x3e	; 62
    303a:	28 97       	sbiw	r28, 0x08	; 8
    303c:	0f b6       	in	r0, 0x3f	; 63
    303e:	f8 94       	cli
    3040:	de bf       	out	0x3e, r29	; 62
    3042:	0f be       	out	0x3f, r0	; 63
    3044:	cd bf       	out	0x3d, r28	; 61
    3046:	9c 83       	std	Y+4, r25	; 0x04
    3048:	8b 83       	std	Y+3, r24	; 0x03
    304a:	7e 83       	std	Y+6, r23	; 0x06
    304c:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    304e:	81 e2       	ldi	r24, 0x21	; 33
    3050:	90 e0       	ldi	r25, 0x00	; 0
    3052:	0e 94 7b 08 	call	0x10f6	; 0x10f6 <pvPortMalloc>
    3056:	9a 83       	std	Y+2, r25	; 0x02
    3058:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    305a:	89 81       	ldd	r24, Y+1	; 0x01
    305c:	9a 81       	ldd	r25, Y+2	; 0x02
    305e:	00 97       	sbiw	r24, 0x00	; 0
    3060:	69 f1       	breq	.+90     	; 0x30bc <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    3062:	8d 81       	ldd	r24, Y+5	; 0x05
    3064:	9e 81       	ldd	r25, Y+6	; 0x06
    3066:	00 97       	sbiw	r24, 0x00	; 0
    3068:	39 f4       	brne	.+14     	; 0x3078 <prvAllocateTCBAndStack+0x46>
    306a:	8b 81       	ldd	r24, Y+3	; 0x03
    306c:	9c 81       	ldd	r25, Y+4	; 0x04
    306e:	0e 94 7b 08 	call	0x10f6	; 0x10f6 <pvPortMalloc>
    3072:	98 87       	std	Y+8, r25	; 0x08
    3074:	8f 83       	std	Y+7, r24	; 0x07
    3076:	04 c0       	rjmp	.+8      	; 0x3080 <prvAllocateTCBAndStack+0x4e>
    3078:	8d 81       	ldd	r24, Y+5	; 0x05
    307a:	9e 81       	ldd	r25, Y+6	; 0x06
    307c:	98 87       	std	Y+8, r25	; 0x08
    307e:	8f 83       	std	Y+7, r24	; 0x07
    3080:	e9 81       	ldd	r30, Y+1	; 0x01
    3082:	fa 81       	ldd	r31, Y+2	; 0x02
    3084:	8f 81       	ldd	r24, Y+7	; 0x07
    3086:	98 85       	ldd	r25, Y+8	; 0x08
    3088:	90 8f       	std	Z+24, r25	; 0x18
    308a:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    308c:	e9 81       	ldd	r30, Y+1	; 0x01
    308e:	fa 81       	ldd	r31, Y+2	; 0x02
    3090:	87 89       	ldd	r24, Z+23	; 0x17
    3092:	90 8d       	ldd	r25, Z+24	; 0x18
    3094:	00 97       	sbiw	r24, 0x00	; 0
    3096:	39 f4       	brne	.+14     	; 0x30a6 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    3098:	89 81       	ldd	r24, Y+1	; 0x01
    309a:	9a 81       	ldd	r25, Y+2	; 0x02
    309c:	0e 94 c1 08 	call	0x1182	; 0x1182 <vPortFree>
			pxNewTCB = NULL;
    30a0:	1a 82       	std	Y+2, r1	; 0x02
    30a2:	19 82       	std	Y+1, r1	; 0x01
    30a4:	0b c0       	rjmp	.+22     	; 0x30bc <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    30a6:	e9 81       	ldd	r30, Y+1	; 0x01
    30a8:	fa 81       	ldd	r31, Y+2	; 0x02
    30aa:	87 89       	ldd	r24, Z+23	; 0x17
    30ac:	90 8d       	ldd	r25, Z+24	; 0x18
    30ae:	2b 81       	ldd	r18, Y+3	; 0x03
    30b0:	3c 81       	ldd	r19, Y+4	; 0x04
    30b2:	65 ea       	ldi	r22, 0xA5	; 165
    30b4:	70 e0       	ldi	r23, 0x00	; 0
    30b6:	a9 01       	movw	r20, r18
    30b8:	0e 94 2e 36 	call	0x6c5c	; 0x6c5c <memset>
		}
	}

	return pxNewTCB;
    30bc:	89 81       	ldd	r24, Y+1	; 0x01
    30be:	9a 81       	ldd	r25, Y+2	; 0x02
}
    30c0:	28 96       	adiw	r28, 0x08	; 8
    30c2:	0f b6       	in	r0, 0x3f	; 63
    30c4:	f8 94       	cli
    30c6:	de bf       	out	0x3e, r29	; 62
    30c8:	0f be       	out	0x3f, r0	; 63
    30ca:	cd bf       	out	0x3d, r28	; 61
    30cc:	cf 91       	pop	r28
    30ce:	df 91       	pop	r29
    30d0:	08 95       	ret

000030d2 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    30d2:	df 93       	push	r29
    30d4:	cf 93       	push	r28
    30d6:	00 d0       	rcall	.+0      	; 0x30d8 <prvDeleteTCB+0x6>
    30d8:	cd b7       	in	r28, 0x3d	; 61
    30da:	de b7       	in	r29, 0x3e	; 62
    30dc:	9a 83       	std	Y+2, r25	; 0x02
    30de:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    30e0:	e9 81       	ldd	r30, Y+1	; 0x01
    30e2:	fa 81       	ldd	r31, Y+2	; 0x02
    30e4:	87 89       	ldd	r24, Z+23	; 0x17
    30e6:	90 8d       	ldd	r25, Z+24	; 0x18
    30e8:	0e 94 c1 08 	call	0x1182	; 0x1182 <vPortFree>
		vPortFree( pxTCB );
    30ec:	89 81       	ldd	r24, Y+1	; 0x01
    30ee:	9a 81       	ldd	r25, Y+2	; 0x02
    30f0:	0e 94 c1 08 	call	0x1182	; 0x1182 <vPortFree>
	}
    30f4:	0f 90       	pop	r0
    30f6:	0f 90       	pop	r0
    30f8:	cf 91       	pop	r28
    30fa:	df 91       	pop	r29
    30fc:	08 95       	ret

000030fe <DC_u8Rotate>:
#include "MOTORS_Private.h"
#include "MOTORS_config.h"
#include "../../1-MCAL/1-DIO/DIO_interface.h"

u8 DC_u8Rotate(DC_MOTOR* Copy_DCMotor,u8 Copy_u8Direction)
{
    30fe:	df 93       	push	r29
    3100:	cf 93       	push	r28
    3102:	00 d0       	rcall	.+0      	; 0x3104 <DC_u8Rotate+0x6>
    3104:	00 d0       	rcall	.+0      	; 0x3106 <DC_u8Rotate+0x8>
    3106:	00 d0       	rcall	.+0      	; 0x3108 <DC_u8Rotate+0xa>
    3108:	cd b7       	in	r28, 0x3d	; 61
    310a:	de b7       	in	r29, 0x3e	; 62
    310c:	9b 83       	std	Y+3, r25	; 0x03
    310e:	8a 83       	std	Y+2, r24	; 0x02
    3110:	6c 83       	std	Y+4, r22	; 0x04
	u8 Local_u8ErorState=OK;
    3112:	19 82       	std	Y+1, r1	; 0x01
	if(Copy_DCMotor==NULL)
    3114:	8a 81       	ldd	r24, Y+2	; 0x02
    3116:	9b 81       	ldd	r25, Y+3	; 0x03
    3118:	00 97       	sbiw	r24, 0x00	; 0
    311a:	19 f4       	brne	.+6      	; 0x3122 <DC_u8Rotate+0x24>
	{
		Local_u8ErorState=NULL_POINTER;
    311c:	82 e0       	ldi	r24, 0x02	; 2
    311e:	89 83       	std	Y+1, r24	; 0x01
    3120:	3c c0       	rjmp	.+120    	; 0x319a <DC_u8Rotate+0x9c>
	}
	else
	{
		switch(Copy_u8Direction)
    3122:	8c 81       	ldd	r24, Y+4	; 0x04
    3124:	28 2f       	mov	r18, r24
    3126:	30 e0       	ldi	r19, 0x00	; 0
    3128:	3e 83       	std	Y+6, r19	; 0x06
    312a:	2d 83       	std	Y+5, r18	; 0x05
    312c:	8d 81       	ldd	r24, Y+5	; 0x05
    312e:	9e 81       	ldd	r25, Y+6	; 0x06
    3130:	81 30       	cpi	r24, 0x01	; 1
    3132:	91 05       	cpc	r25, r1
    3134:	31 f0       	breq	.+12     	; 0x3142 <DC_u8Rotate+0x44>
    3136:	2d 81       	ldd	r18, Y+5	; 0x05
    3138:	3e 81       	ldd	r19, Y+6	; 0x06
    313a:	22 30       	cpi	r18, 0x02	; 2
    313c:	31 05       	cpc	r19, r1
    313e:	b1 f0       	breq	.+44     	; 0x316c <DC_u8Rotate+0x6e>
    3140:	2a c0       	rjmp	.+84     	; 0x3196 <DC_u8Rotate+0x98>
		{
		case CW: DIO_u8SetPinValue(Copy_DCMotor->DC_Port,Copy_DCMotor->DC_Pin1,DIO_u8Pin_HIGH);
    3142:	ea 81       	ldd	r30, Y+2	; 0x02
    3144:	fb 81       	ldd	r31, Y+3	; 0x03
    3146:	80 81       	ld	r24, Z
    3148:	ea 81       	ldd	r30, Y+2	; 0x02
    314a:	fb 81       	ldd	r31, Y+3	; 0x03
    314c:	91 81       	ldd	r25, Z+1	; 0x01
    314e:	69 2f       	mov	r22, r25
    3150:	41 e0       	ldi	r20, 0x01	; 1
    3152:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				 DIO_u8SetPinValue(Copy_DCMotor->DC_Port,Copy_DCMotor->DC_Pin2,DIO_u8Pin_LOW); break;
    3156:	ea 81       	ldd	r30, Y+2	; 0x02
    3158:	fb 81       	ldd	r31, Y+3	; 0x03
    315a:	80 81       	ld	r24, Z
    315c:	ea 81       	ldd	r30, Y+2	; 0x02
    315e:	fb 81       	ldd	r31, Y+3	; 0x03
    3160:	92 81       	ldd	r25, Z+2	; 0x02
    3162:	69 2f       	mov	r22, r25
    3164:	40 e0       	ldi	r20, 0x00	; 0
    3166:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
    316a:	17 c0       	rjmp	.+46     	; 0x319a <DC_u8Rotate+0x9c>
		case CCW: DIO_u8SetPinValue(Copy_DCMotor->DC_Port,Copy_DCMotor->DC_Pin1,DIO_u8Pin_LOW);
    316c:	ea 81       	ldd	r30, Y+2	; 0x02
    316e:	fb 81       	ldd	r31, Y+3	; 0x03
    3170:	80 81       	ld	r24, Z
    3172:	ea 81       	ldd	r30, Y+2	; 0x02
    3174:	fb 81       	ldd	r31, Y+3	; 0x03
    3176:	91 81       	ldd	r25, Z+1	; 0x01
    3178:	69 2f       	mov	r22, r25
    317a:	40 e0       	ldi	r20, 0x00	; 0
    317c:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				 DIO_u8SetPinValue(Copy_DCMotor->DC_Port,Copy_DCMotor->DC_Pin2,DIO_u8Pin_HIGH); break;
    3180:	ea 81       	ldd	r30, Y+2	; 0x02
    3182:	fb 81       	ldd	r31, Y+3	; 0x03
    3184:	80 81       	ld	r24, Z
    3186:	ea 81       	ldd	r30, Y+2	; 0x02
    3188:	fb 81       	ldd	r31, Y+3	; 0x03
    318a:	92 81       	ldd	r25, Z+2	; 0x02
    318c:	69 2f       	mov	r22, r25
    318e:	41 e0       	ldi	r20, 0x01	; 1
    3190:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
    3194:	02 c0       	rjmp	.+4      	; 0x319a <DC_u8Rotate+0x9c>
		default: Local_u8ErorState=WORNG_DIRECTION; break;
    3196:	85 e0       	ldi	r24, 0x05	; 5
    3198:	89 83       	std	Y+1, r24	; 0x01
		}
	}

	return Local_u8ErorState;
    319a:	89 81       	ldd	r24, Y+1	; 0x01
}
    319c:	26 96       	adiw	r28, 0x06	; 6
    319e:	0f b6       	in	r0, 0x3f	; 63
    31a0:	f8 94       	cli
    31a2:	de bf       	out	0x3e, r29	; 62
    31a4:	0f be       	out	0x3f, r0	; 63
    31a6:	cd bf       	out	0x3d, r28	; 61
    31a8:	cf 91       	pop	r28
    31aa:	df 91       	pop	r29
    31ac:	08 95       	ret

000031ae <DC_u8Stop>:
u8 DC_u8Stop(DC_MOTOR* Copy_DCMotor)
{
    31ae:	df 93       	push	r29
    31b0:	cf 93       	push	r28
    31b2:	00 d0       	rcall	.+0      	; 0x31b4 <DC_u8Stop+0x6>
    31b4:	0f 92       	push	r0
    31b6:	cd b7       	in	r28, 0x3d	; 61
    31b8:	de b7       	in	r29, 0x3e	; 62
    31ba:	9b 83       	std	Y+3, r25	; 0x03
    31bc:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_u8ErorState=OK;
    31be:	19 82       	std	Y+1, r1	; 0x01
	if(Copy_DCMotor==NULL)
    31c0:	8a 81       	ldd	r24, Y+2	; 0x02
    31c2:	9b 81       	ldd	r25, Y+3	; 0x03
    31c4:	00 97       	sbiw	r24, 0x00	; 0
    31c6:	19 f4       	brne	.+6      	; 0x31ce <DC_u8Stop+0x20>
	{
		Local_u8ErorState=NULL_POINTER;
    31c8:	82 e0       	ldi	r24, 0x02	; 2
    31ca:	89 83       	std	Y+1, r24	; 0x01
    31cc:	14 c0       	rjmp	.+40     	; 0x31f6 <DC_u8Stop+0x48>
	}
	else
	{
		DIO_u8SetPinValue(Copy_DCMotor->DC_Port,Copy_DCMotor->DC_Pin1,DIO_u8Pin_LOW);
    31ce:	ea 81       	ldd	r30, Y+2	; 0x02
    31d0:	fb 81       	ldd	r31, Y+3	; 0x03
    31d2:	80 81       	ld	r24, Z
    31d4:	ea 81       	ldd	r30, Y+2	; 0x02
    31d6:	fb 81       	ldd	r31, Y+3	; 0x03
    31d8:	91 81       	ldd	r25, Z+1	; 0x01
    31da:	69 2f       	mov	r22, r25
    31dc:	40 e0       	ldi	r20, 0x00	; 0
    31de:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
		DIO_u8SetPinValue(Copy_DCMotor->DC_Port,Copy_DCMotor->DC_Pin2,DIO_u8Pin_LOW);
    31e2:	ea 81       	ldd	r30, Y+2	; 0x02
    31e4:	fb 81       	ldd	r31, Y+3	; 0x03
    31e6:	80 81       	ld	r24, Z
    31e8:	ea 81       	ldd	r30, Y+2	; 0x02
    31ea:	fb 81       	ldd	r31, Y+3	; 0x03
    31ec:	92 81       	ldd	r25, Z+2	; 0x02
    31ee:	69 2f       	mov	r22, r25
    31f0:	40 e0       	ldi	r20, 0x00	; 0
    31f2:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
	}

	return Local_u8ErorState;
    31f6:	89 81       	ldd	r24, Y+1	; 0x01
}
    31f8:	0f 90       	pop	r0
    31fa:	0f 90       	pop	r0
    31fc:	0f 90       	pop	r0
    31fe:	cf 91       	pop	r28
    3200:	df 91       	pop	r29
    3202:	08 95       	ret

00003204 <STEPPER_u8Rotate>:
u8 STEPPER_u8Rotate(STEPPER_MOTOR* Copy_STEPPERMOTOR,u16 Copy_u16Angle,u8 Copy_u8Direction)
{
    3204:	0f 93       	push	r16
    3206:	1f 93       	push	r17
    3208:	df 93       	push	r29
    320a:	cf 93       	push	r28
    320c:	cd b7       	in	r28, 0x3d	; 61
    320e:	de b7       	in	r29, 0x3e	; 62
    3210:	c2 5f       	subi	r28, 0xF2	; 242
    3212:	d0 40       	sbci	r29, 0x00	; 0
    3214:	0f b6       	in	r0, 0x3f	; 63
    3216:	f8 94       	cli
    3218:	de bf       	out	0x3e, r29	; 62
    321a:	0f be       	out	0x3f, r0	; 63
    321c:	cd bf       	out	0x3d, r28	; 61
    321e:	fe 01       	movw	r30, r28
    3220:	e6 51       	subi	r30, 0x16	; 22
    3222:	ff 4f       	sbci	r31, 0xFF	; 255
    3224:	91 83       	std	Z+1, r25	; 0x01
    3226:	80 83       	st	Z, r24
    3228:	fe 01       	movw	r30, r28
    322a:	e4 51       	subi	r30, 0x14	; 20
    322c:	ff 4f       	sbci	r31, 0xFF	; 255
    322e:	71 83       	std	Z+1, r23	; 0x01
    3230:	60 83       	st	Z, r22
    3232:	fe 01       	movw	r30, r28
    3234:	e2 51       	subi	r30, 0x12	; 18
    3236:	ff 4f       	sbci	r31, 0xFF	; 255
    3238:	40 83       	st	Z, r20
	u8 Local_u8ErorState=OK;
    323a:	fe 01       	movw	r30, r28
    323c:	e7 51       	subi	r30, 0x17	; 23
    323e:	ff 4f       	sbci	r31, 0xFF	; 255
    3240:	10 82       	st	Z, r1
	u32 Local_u32IterationsNum=0;
    3242:	fe 01       	movw	r30, r28
    3244:	eb 51       	subi	r30, 0x1B	; 27
    3246:	ff 4f       	sbci	r31, 0xFF	; 255
    3248:	10 82       	st	Z, r1
    324a:	11 82       	std	Z+1, r1	; 0x01
    324c:	12 82       	std	Z+2, r1	; 0x02
    324e:	13 82       	std	Z+3, r1	; 0x03
	u32 Local_u32Counter=0;
    3250:	fe 01       	movw	r30, r28
    3252:	ef 51       	subi	r30, 0x1F	; 31
    3254:	ff 4f       	sbci	r31, 0xFF	; 255
    3256:	10 82       	st	Z, r1
    3258:	11 82       	std	Z+1, r1	; 0x01
    325a:	12 82       	std	Z+2, r1	; 0x02
    325c:	13 82       	std	Z+3, r1	; 0x03
	if(Copy_STEPPERMOTOR==NULL)
    325e:	fe 01       	movw	r30, r28
    3260:	e6 51       	subi	r30, 0x16	; 22
    3262:	ff 4f       	sbci	r31, 0xFF	; 255
    3264:	80 81       	ld	r24, Z
    3266:	91 81       	ldd	r25, Z+1	; 0x01
    3268:	00 97       	sbiw	r24, 0x00	; 0
    326a:	39 f4       	brne	.+14     	; 0x327a <STEPPER_u8Rotate+0x76>
	{
		Local_u8ErorState=NULL_POINTER;
    326c:	fe 01       	movw	r30, r28
    326e:	e7 51       	subi	r30, 0x17	; 23
    3270:	ff 4f       	sbci	r31, 0xFF	; 255
    3272:	82 e0       	ldi	r24, 0x02	; 2
    3274:	80 83       	st	Z, r24
    3276:	0c 94 93 28 	jmp	0x5126	; 0x5126 <STEPPER_u8Rotate+0x1f22>
	}
	else
	{
		if(Copy_u16Angle==CONT_ROTATION)
    327a:	fe 01       	movw	r30, r28
    327c:	e4 51       	subi	r30, 0x14	; 20
    327e:	ff 4f       	sbci	r31, 0xFF	; 255
    3280:	80 81       	ld	r24, Z
    3282:	91 81       	ldd	r25, Z+1	; 0x01
    3284:	00 97       	sbiw	r24, 0x00	; 0
    3286:	11 f0       	breq	.+4      	; 0x328c <STEPPER_u8Rotate+0x88>
    3288:	0c 94 49 21 	jmp	0x4292	; 0x4292 <STEPPER_u8Rotate+0x108e>
		{
			switch(Copy_u8Direction)
    328c:	fe 01       	movw	r30, r28
    328e:	e2 51       	subi	r30, 0x12	; 18
    3290:	ff 4f       	sbci	r31, 0xFF	; 255
    3292:	80 81       	ld	r24, Z
    3294:	28 2f       	mov	r18, r24
    3296:	30 e0       	ldi	r19, 0x00	; 0
    3298:	cf 50       	subi	r28, 0x0F	; 15
    329a:	df 4f       	sbci	r29, 0xFF	; 255
    329c:	39 83       	std	Y+1, r19	; 0x01
    329e:	28 83       	st	Y, r18
    32a0:	c1 5f       	subi	r28, 0xF1	; 241
    32a2:	d0 40       	sbci	r29, 0x00	; 0
    32a4:	cf 50       	subi	r28, 0x0F	; 15
    32a6:	df 4f       	sbci	r29, 0xFF	; 255
    32a8:	88 81       	ld	r24, Y
    32aa:	99 81       	ldd	r25, Y+1	; 0x01
    32ac:	c1 5f       	subi	r28, 0xF1	; 241
    32ae:	d0 40       	sbci	r29, 0x00	; 0
    32b0:	81 30       	cpi	r24, 0x01	; 1
    32b2:	91 05       	cpc	r25, r1
    32b4:	09 f4       	brne	.+2      	; 0x32b8 <STEPPER_u8Rotate+0xb4>
    32b6:	f9 c3       	rjmp	.+2034   	; 0x3aaa <STEPPER_u8Rotate+0x8a6>
    32b8:	cf 50       	subi	r28, 0x0F	; 15
    32ba:	df 4f       	sbci	r29, 0xFF	; 255
    32bc:	e8 81       	ld	r30, Y
    32be:	f9 81       	ldd	r31, Y+1	; 0x01
    32c0:	c1 5f       	subi	r28, 0xF1	; 241
    32c2:	d0 40       	sbci	r29, 0x00	; 0
    32c4:	e2 30       	cpi	r30, 0x02	; 2
    32c6:	f1 05       	cpc	r31, r1
    32c8:	11 f0       	breq	.+4      	; 0x32ce <STEPPER_u8Rotate+0xca>
    32ca:	0c 94 43 21 	jmp	0x4286	; 0x4286 <STEPPER_u8Rotate+0x1082>
			{
			case CCW: while(1)
			{
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN1,DIO_u8Pin_LOW);
    32ce:	fe 01       	movw	r30, r28
    32d0:	e6 51       	subi	r30, 0x16	; 22
    32d2:	ff 4f       	sbci	r31, 0xFF	; 255
    32d4:	01 90       	ld	r0, Z+
    32d6:	f0 81       	ld	r31, Z
    32d8:	e0 2d       	mov	r30, r0
    32da:	80 81       	ld	r24, Z
    32dc:	fe 01       	movw	r30, r28
    32de:	e6 51       	subi	r30, 0x16	; 22
    32e0:	ff 4f       	sbci	r31, 0xFF	; 255
    32e2:	01 90       	ld	r0, Z+
    32e4:	f0 81       	ld	r31, Z
    32e6:	e0 2d       	mov	r30, r0
    32e8:	91 81       	ldd	r25, Z+1	; 0x01
    32ea:	69 2f       	mov	r22, r25
    32ec:	40 e0       	ldi	r20, 0x00	; 0
    32ee:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN2,DIO_u8Pin_HIGH);
    32f2:	fe 01       	movw	r30, r28
    32f4:	e6 51       	subi	r30, 0x16	; 22
    32f6:	ff 4f       	sbci	r31, 0xFF	; 255
    32f8:	01 90       	ld	r0, Z+
    32fa:	f0 81       	ld	r31, Z
    32fc:	e0 2d       	mov	r30, r0
    32fe:	80 81       	ld	r24, Z
    3300:	fe 01       	movw	r30, r28
    3302:	e6 51       	subi	r30, 0x16	; 22
    3304:	ff 4f       	sbci	r31, 0xFF	; 255
    3306:	01 90       	ld	r0, Z+
    3308:	f0 81       	ld	r31, Z
    330a:	e0 2d       	mov	r30, r0
    330c:	92 81       	ldd	r25, Z+2	; 0x02
    330e:	69 2f       	mov	r22, r25
    3310:	41 e0       	ldi	r20, 0x01	; 1
    3312:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN3,DIO_u8Pin_HIGH);
    3316:	fe 01       	movw	r30, r28
    3318:	e6 51       	subi	r30, 0x16	; 22
    331a:	ff 4f       	sbci	r31, 0xFF	; 255
    331c:	01 90       	ld	r0, Z+
    331e:	f0 81       	ld	r31, Z
    3320:	e0 2d       	mov	r30, r0
    3322:	80 81       	ld	r24, Z
    3324:	fe 01       	movw	r30, r28
    3326:	e6 51       	subi	r30, 0x16	; 22
    3328:	ff 4f       	sbci	r31, 0xFF	; 255
    332a:	01 90       	ld	r0, Z+
    332c:	f0 81       	ld	r31, Z
    332e:	e0 2d       	mov	r30, r0
    3330:	93 81       	ldd	r25, Z+3	; 0x03
    3332:	69 2f       	mov	r22, r25
    3334:	41 e0       	ldi	r20, 0x01	; 1
    3336:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN4,DIO_u8Pin_HIGH);
    333a:	fe 01       	movw	r30, r28
    333c:	e6 51       	subi	r30, 0x16	; 22
    333e:	ff 4f       	sbci	r31, 0xFF	; 255
    3340:	01 90       	ld	r0, Z+
    3342:	f0 81       	ld	r31, Z
    3344:	e0 2d       	mov	r30, r0
    3346:	80 81       	ld	r24, Z
    3348:	fe 01       	movw	r30, r28
    334a:	e6 51       	subi	r30, 0x16	; 22
    334c:	ff 4f       	sbci	r31, 0xFF	; 255
    334e:	01 90       	ld	r0, Z+
    3350:	f0 81       	ld	r31, Z
    3352:	e0 2d       	mov	r30, r0
    3354:	94 81       	ldd	r25, Z+4	; 0x04
    3356:	69 2f       	mov	r22, r25
    3358:	41 e0       	ldi	r20, 0x01	; 1
    335a:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
    335e:	fe 01       	movw	r30, r28
    3360:	e3 52       	subi	r30, 0x23	; 35
    3362:	ff 4f       	sbci	r31, 0xFF	; 255
    3364:	80 e0       	ldi	r24, 0x00	; 0
    3366:	90 e0       	ldi	r25, 0x00	; 0
    3368:	a0 e0       	ldi	r26, 0x00	; 0
    336a:	b0 e4       	ldi	r27, 0x40	; 64
    336c:	80 83       	st	Z, r24
    336e:	91 83       	std	Z+1, r25	; 0x01
    3370:	a2 83       	std	Z+2, r26	; 0x02
    3372:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3374:	8e 01       	movw	r16, r28
    3376:	07 52       	subi	r16, 0x27	; 39
    3378:	1f 4f       	sbci	r17, 0xFF	; 255
    337a:	fe 01       	movw	r30, r28
    337c:	e3 52       	subi	r30, 0x23	; 35
    337e:	ff 4f       	sbci	r31, 0xFF	; 255
    3380:	60 81       	ld	r22, Z
    3382:	71 81       	ldd	r23, Z+1	; 0x01
    3384:	82 81       	ldd	r24, Z+2	; 0x02
    3386:	93 81       	ldd	r25, Z+3	; 0x03
    3388:	20 e0       	ldi	r18, 0x00	; 0
    338a:	30 e0       	ldi	r19, 0x00	; 0
    338c:	4a ef       	ldi	r20, 0xFA	; 250
    338e:	54 e4       	ldi	r21, 0x44	; 68
    3390:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3394:	dc 01       	movw	r26, r24
    3396:	cb 01       	movw	r24, r22
    3398:	f8 01       	movw	r30, r16
    339a:	80 83       	st	Z, r24
    339c:	91 83       	std	Z+1, r25	; 0x01
    339e:	a2 83       	std	Z+2, r26	; 0x02
    33a0:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    33a2:	fe 01       	movw	r30, r28
    33a4:	e7 52       	subi	r30, 0x27	; 39
    33a6:	ff 4f       	sbci	r31, 0xFF	; 255
    33a8:	60 81       	ld	r22, Z
    33aa:	71 81       	ldd	r23, Z+1	; 0x01
    33ac:	82 81       	ldd	r24, Z+2	; 0x02
    33ae:	93 81       	ldd	r25, Z+3	; 0x03
    33b0:	20 e0       	ldi	r18, 0x00	; 0
    33b2:	30 e0       	ldi	r19, 0x00	; 0
    33b4:	40 e8       	ldi	r20, 0x80	; 128
    33b6:	5f e3       	ldi	r21, 0x3F	; 63
    33b8:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    33bc:	88 23       	and	r24, r24
    33be:	44 f4       	brge	.+16     	; 0x33d0 <STEPPER_u8Rotate+0x1cc>
		__ticks = 1;
    33c0:	fe 01       	movw	r30, r28
    33c2:	e9 52       	subi	r30, 0x29	; 41
    33c4:	ff 4f       	sbci	r31, 0xFF	; 255
    33c6:	81 e0       	ldi	r24, 0x01	; 1
    33c8:	90 e0       	ldi	r25, 0x00	; 0
    33ca:	91 83       	std	Z+1, r25	; 0x01
    33cc:	80 83       	st	Z, r24
    33ce:	64 c0       	rjmp	.+200    	; 0x3498 <STEPPER_u8Rotate+0x294>
	else if (__tmp > 65535)
    33d0:	fe 01       	movw	r30, r28
    33d2:	e7 52       	subi	r30, 0x27	; 39
    33d4:	ff 4f       	sbci	r31, 0xFF	; 255
    33d6:	60 81       	ld	r22, Z
    33d8:	71 81       	ldd	r23, Z+1	; 0x01
    33da:	82 81       	ldd	r24, Z+2	; 0x02
    33dc:	93 81       	ldd	r25, Z+3	; 0x03
    33de:	20 e0       	ldi	r18, 0x00	; 0
    33e0:	3f ef       	ldi	r19, 0xFF	; 255
    33e2:	4f e7       	ldi	r20, 0x7F	; 127
    33e4:	57 e4       	ldi	r21, 0x47	; 71
    33e6:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    33ea:	18 16       	cp	r1, r24
    33ec:	0c f0       	brlt	.+2      	; 0x33f0 <STEPPER_u8Rotate+0x1ec>
    33ee:	43 c0       	rjmp	.+134    	; 0x3476 <STEPPER_u8Rotate+0x272>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    33f0:	fe 01       	movw	r30, r28
    33f2:	e3 52       	subi	r30, 0x23	; 35
    33f4:	ff 4f       	sbci	r31, 0xFF	; 255
    33f6:	60 81       	ld	r22, Z
    33f8:	71 81       	ldd	r23, Z+1	; 0x01
    33fa:	82 81       	ldd	r24, Z+2	; 0x02
    33fc:	93 81       	ldd	r25, Z+3	; 0x03
    33fe:	20 e0       	ldi	r18, 0x00	; 0
    3400:	30 e0       	ldi	r19, 0x00	; 0
    3402:	40 e2       	ldi	r20, 0x20	; 32
    3404:	51 e4       	ldi	r21, 0x41	; 65
    3406:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    340a:	dc 01       	movw	r26, r24
    340c:	cb 01       	movw	r24, r22
    340e:	8e 01       	movw	r16, r28
    3410:	09 52       	subi	r16, 0x29	; 41
    3412:	1f 4f       	sbci	r17, 0xFF	; 255
    3414:	bc 01       	movw	r22, r24
    3416:	cd 01       	movw	r24, r26
    3418:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    341c:	dc 01       	movw	r26, r24
    341e:	cb 01       	movw	r24, r22
    3420:	f8 01       	movw	r30, r16
    3422:	91 83       	std	Z+1, r25	; 0x01
    3424:	80 83       	st	Z, r24
    3426:	1f c0       	rjmp	.+62     	; 0x3466 <STEPPER_u8Rotate+0x262>
    3428:	fe 01       	movw	r30, r28
    342a:	eb 52       	subi	r30, 0x2B	; 43
    342c:	ff 4f       	sbci	r31, 0xFF	; 255
    342e:	88 ec       	ldi	r24, 0xC8	; 200
    3430:	90 e0       	ldi	r25, 0x00	; 0
    3432:	91 83       	std	Z+1, r25	; 0x01
    3434:	80 83       	st	Z, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3436:	fe 01       	movw	r30, r28
    3438:	eb 52       	subi	r30, 0x2B	; 43
    343a:	ff 4f       	sbci	r31, 0xFF	; 255
    343c:	80 81       	ld	r24, Z
    343e:	91 81       	ldd	r25, Z+1	; 0x01
    3440:	01 97       	sbiw	r24, 0x01	; 1
    3442:	f1 f7       	brne	.-4      	; 0x3440 <STEPPER_u8Rotate+0x23c>
    3444:	fe 01       	movw	r30, r28
    3446:	eb 52       	subi	r30, 0x2B	; 43
    3448:	ff 4f       	sbci	r31, 0xFF	; 255
    344a:	91 83       	std	Z+1, r25	; 0x01
    344c:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    344e:	de 01       	movw	r26, r28
    3450:	a9 52       	subi	r26, 0x29	; 41
    3452:	bf 4f       	sbci	r27, 0xFF	; 255
    3454:	fe 01       	movw	r30, r28
    3456:	e9 52       	subi	r30, 0x29	; 41
    3458:	ff 4f       	sbci	r31, 0xFF	; 255
    345a:	80 81       	ld	r24, Z
    345c:	91 81       	ldd	r25, Z+1	; 0x01
    345e:	01 97       	sbiw	r24, 0x01	; 1
    3460:	11 96       	adiw	r26, 0x01	; 1
    3462:	9c 93       	st	X, r25
    3464:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3466:	fe 01       	movw	r30, r28
    3468:	e9 52       	subi	r30, 0x29	; 41
    346a:	ff 4f       	sbci	r31, 0xFF	; 255
    346c:	80 81       	ld	r24, Z
    346e:	91 81       	ldd	r25, Z+1	; 0x01
    3470:	00 97       	sbiw	r24, 0x00	; 0
    3472:	d1 f6       	brne	.-76     	; 0x3428 <STEPPER_u8Rotate+0x224>
    3474:	27 c0       	rjmp	.+78     	; 0x34c4 <STEPPER_u8Rotate+0x2c0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3476:	8e 01       	movw	r16, r28
    3478:	09 52       	subi	r16, 0x29	; 41
    347a:	1f 4f       	sbci	r17, 0xFF	; 255
    347c:	fe 01       	movw	r30, r28
    347e:	e7 52       	subi	r30, 0x27	; 39
    3480:	ff 4f       	sbci	r31, 0xFF	; 255
    3482:	60 81       	ld	r22, Z
    3484:	71 81       	ldd	r23, Z+1	; 0x01
    3486:	82 81       	ldd	r24, Z+2	; 0x02
    3488:	93 81       	ldd	r25, Z+3	; 0x03
    348a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    348e:	dc 01       	movw	r26, r24
    3490:	cb 01       	movw	r24, r22
    3492:	f8 01       	movw	r30, r16
    3494:	91 83       	std	Z+1, r25	; 0x01
    3496:	80 83       	st	Z, r24
    3498:	de 01       	movw	r26, r28
    349a:	ad 52       	subi	r26, 0x2D	; 45
    349c:	bf 4f       	sbci	r27, 0xFF	; 255
    349e:	fe 01       	movw	r30, r28
    34a0:	e9 52       	subi	r30, 0x29	; 41
    34a2:	ff 4f       	sbci	r31, 0xFF	; 255
    34a4:	80 81       	ld	r24, Z
    34a6:	91 81       	ldd	r25, Z+1	; 0x01
    34a8:	8d 93       	st	X+, r24
    34aa:	9c 93       	st	X, r25
    34ac:	fe 01       	movw	r30, r28
    34ae:	ed 52       	subi	r30, 0x2D	; 45
    34b0:	ff 4f       	sbci	r31, 0xFF	; 255
    34b2:	80 81       	ld	r24, Z
    34b4:	91 81       	ldd	r25, Z+1	; 0x01
    34b6:	01 97       	sbiw	r24, 0x01	; 1
    34b8:	f1 f7       	brne	.-4      	; 0x34b6 <STEPPER_u8Rotate+0x2b2>
    34ba:	fe 01       	movw	r30, r28
    34bc:	ed 52       	subi	r30, 0x2D	; 45
    34be:	ff 4f       	sbci	r31, 0xFF	; 255
    34c0:	91 83       	std	Z+1, r25	; 0x01
    34c2:	80 83       	st	Z, r24
				_delay_ms(2);
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN1,DIO_u8Pin_HIGH);
    34c4:	fe 01       	movw	r30, r28
    34c6:	e6 51       	subi	r30, 0x16	; 22
    34c8:	ff 4f       	sbci	r31, 0xFF	; 255
    34ca:	01 90       	ld	r0, Z+
    34cc:	f0 81       	ld	r31, Z
    34ce:	e0 2d       	mov	r30, r0
    34d0:	80 81       	ld	r24, Z
    34d2:	fe 01       	movw	r30, r28
    34d4:	e6 51       	subi	r30, 0x16	; 22
    34d6:	ff 4f       	sbci	r31, 0xFF	; 255
    34d8:	01 90       	ld	r0, Z+
    34da:	f0 81       	ld	r31, Z
    34dc:	e0 2d       	mov	r30, r0
    34de:	91 81       	ldd	r25, Z+1	; 0x01
    34e0:	69 2f       	mov	r22, r25
    34e2:	41 e0       	ldi	r20, 0x01	; 1
    34e4:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN2,DIO_u8Pin_LOW);
    34e8:	fe 01       	movw	r30, r28
    34ea:	e6 51       	subi	r30, 0x16	; 22
    34ec:	ff 4f       	sbci	r31, 0xFF	; 255
    34ee:	01 90       	ld	r0, Z+
    34f0:	f0 81       	ld	r31, Z
    34f2:	e0 2d       	mov	r30, r0
    34f4:	80 81       	ld	r24, Z
    34f6:	fe 01       	movw	r30, r28
    34f8:	e6 51       	subi	r30, 0x16	; 22
    34fa:	ff 4f       	sbci	r31, 0xFF	; 255
    34fc:	01 90       	ld	r0, Z+
    34fe:	f0 81       	ld	r31, Z
    3500:	e0 2d       	mov	r30, r0
    3502:	92 81       	ldd	r25, Z+2	; 0x02
    3504:	69 2f       	mov	r22, r25
    3506:	40 e0       	ldi	r20, 0x00	; 0
    3508:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN3,DIO_u8Pin_HIGH);
    350c:	fe 01       	movw	r30, r28
    350e:	e6 51       	subi	r30, 0x16	; 22
    3510:	ff 4f       	sbci	r31, 0xFF	; 255
    3512:	01 90       	ld	r0, Z+
    3514:	f0 81       	ld	r31, Z
    3516:	e0 2d       	mov	r30, r0
    3518:	80 81       	ld	r24, Z
    351a:	fe 01       	movw	r30, r28
    351c:	e6 51       	subi	r30, 0x16	; 22
    351e:	ff 4f       	sbci	r31, 0xFF	; 255
    3520:	01 90       	ld	r0, Z+
    3522:	f0 81       	ld	r31, Z
    3524:	e0 2d       	mov	r30, r0
    3526:	93 81       	ldd	r25, Z+3	; 0x03
    3528:	69 2f       	mov	r22, r25
    352a:	41 e0       	ldi	r20, 0x01	; 1
    352c:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN4,DIO_u8Pin_HIGH);
    3530:	fe 01       	movw	r30, r28
    3532:	e6 51       	subi	r30, 0x16	; 22
    3534:	ff 4f       	sbci	r31, 0xFF	; 255
    3536:	01 90       	ld	r0, Z+
    3538:	f0 81       	ld	r31, Z
    353a:	e0 2d       	mov	r30, r0
    353c:	80 81       	ld	r24, Z
    353e:	fe 01       	movw	r30, r28
    3540:	e6 51       	subi	r30, 0x16	; 22
    3542:	ff 4f       	sbci	r31, 0xFF	; 255
    3544:	01 90       	ld	r0, Z+
    3546:	f0 81       	ld	r31, Z
    3548:	e0 2d       	mov	r30, r0
    354a:	94 81       	ldd	r25, Z+4	; 0x04
    354c:	69 2f       	mov	r22, r25
    354e:	41 e0       	ldi	r20, 0x01	; 1
    3550:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
    3554:	fe 01       	movw	r30, r28
    3556:	e1 53       	subi	r30, 0x31	; 49
    3558:	ff 4f       	sbci	r31, 0xFF	; 255
    355a:	80 e0       	ldi	r24, 0x00	; 0
    355c:	90 e0       	ldi	r25, 0x00	; 0
    355e:	a0 e0       	ldi	r26, 0x00	; 0
    3560:	b0 e4       	ldi	r27, 0x40	; 64
    3562:	80 83       	st	Z, r24
    3564:	91 83       	std	Z+1, r25	; 0x01
    3566:	a2 83       	std	Z+2, r26	; 0x02
    3568:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    356a:	8e 01       	movw	r16, r28
    356c:	05 53       	subi	r16, 0x35	; 53
    356e:	1f 4f       	sbci	r17, 0xFF	; 255
    3570:	fe 01       	movw	r30, r28
    3572:	e1 53       	subi	r30, 0x31	; 49
    3574:	ff 4f       	sbci	r31, 0xFF	; 255
    3576:	60 81       	ld	r22, Z
    3578:	71 81       	ldd	r23, Z+1	; 0x01
    357a:	82 81       	ldd	r24, Z+2	; 0x02
    357c:	93 81       	ldd	r25, Z+3	; 0x03
    357e:	20 e0       	ldi	r18, 0x00	; 0
    3580:	30 e0       	ldi	r19, 0x00	; 0
    3582:	4a ef       	ldi	r20, 0xFA	; 250
    3584:	54 e4       	ldi	r21, 0x44	; 68
    3586:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    358a:	dc 01       	movw	r26, r24
    358c:	cb 01       	movw	r24, r22
    358e:	f8 01       	movw	r30, r16
    3590:	80 83       	st	Z, r24
    3592:	91 83       	std	Z+1, r25	; 0x01
    3594:	a2 83       	std	Z+2, r26	; 0x02
    3596:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    3598:	fe 01       	movw	r30, r28
    359a:	e5 53       	subi	r30, 0x35	; 53
    359c:	ff 4f       	sbci	r31, 0xFF	; 255
    359e:	60 81       	ld	r22, Z
    35a0:	71 81       	ldd	r23, Z+1	; 0x01
    35a2:	82 81       	ldd	r24, Z+2	; 0x02
    35a4:	93 81       	ldd	r25, Z+3	; 0x03
    35a6:	20 e0       	ldi	r18, 0x00	; 0
    35a8:	30 e0       	ldi	r19, 0x00	; 0
    35aa:	40 e8       	ldi	r20, 0x80	; 128
    35ac:	5f e3       	ldi	r21, 0x3F	; 63
    35ae:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    35b2:	88 23       	and	r24, r24
    35b4:	44 f4       	brge	.+16     	; 0x35c6 <STEPPER_u8Rotate+0x3c2>
		__ticks = 1;
    35b6:	fe 01       	movw	r30, r28
    35b8:	e7 53       	subi	r30, 0x37	; 55
    35ba:	ff 4f       	sbci	r31, 0xFF	; 255
    35bc:	81 e0       	ldi	r24, 0x01	; 1
    35be:	90 e0       	ldi	r25, 0x00	; 0
    35c0:	91 83       	std	Z+1, r25	; 0x01
    35c2:	80 83       	st	Z, r24
    35c4:	64 c0       	rjmp	.+200    	; 0x368e <STEPPER_u8Rotate+0x48a>
	else if (__tmp > 65535)
    35c6:	fe 01       	movw	r30, r28
    35c8:	e5 53       	subi	r30, 0x35	; 53
    35ca:	ff 4f       	sbci	r31, 0xFF	; 255
    35cc:	60 81       	ld	r22, Z
    35ce:	71 81       	ldd	r23, Z+1	; 0x01
    35d0:	82 81       	ldd	r24, Z+2	; 0x02
    35d2:	93 81       	ldd	r25, Z+3	; 0x03
    35d4:	20 e0       	ldi	r18, 0x00	; 0
    35d6:	3f ef       	ldi	r19, 0xFF	; 255
    35d8:	4f e7       	ldi	r20, 0x7F	; 127
    35da:	57 e4       	ldi	r21, 0x47	; 71
    35dc:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    35e0:	18 16       	cp	r1, r24
    35e2:	0c f0       	brlt	.+2      	; 0x35e6 <STEPPER_u8Rotate+0x3e2>
    35e4:	43 c0       	rjmp	.+134    	; 0x366c <STEPPER_u8Rotate+0x468>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    35e6:	fe 01       	movw	r30, r28
    35e8:	e1 53       	subi	r30, 0x31	; 49
    35ea:	ff 4f       	sbci	r31, 0xFF	; 255
    35ec:	60 81       	ld	r22, Z
    35ee:	71 81       	ldd	r23, Z+1	; 0x01
    35f0:	82 81       	ldd	r24, Z+2	; 0x02
    35f2:	93 81       	ldd	r25, Z+3	; 0x03
    35f4:	20 e0       	ldi	r18, 0x00	; 0
    35f6:	30 e0       	ldi	r19, 0x00	; 0
    35f8:	40 e2       	ldi	r20, 0x20	; 32
    35fa:	51 e4       	ldi	r21, 0x41	; 65
    35fc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3600:	dc 01       	movw	r26, r24
    3602:	cb 01       	movw	r24, r22
    3604:	8e 01       	movw	r16, r28
    3606:	07 53       	subi	r16, 0x37	; 55
    3608:	1f 4f       	sbci	r17, 0xFF	; 255
    360a:	bc 01       	movw	r22, r24
    360c:	cd 01       	movw	r24, r26
    360e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3612:	dc 01       	movw	r26, r24
    3614:	cb 01       	movw	r24, r22
    3616:	f8 01       	movw	r30, r16
    3618:	91 83       	std	Z+1, r25	; 0x01
    361a:	80 83       	st	Z, r24
    361c:	1f c0       	rjmp	.+62     	; 0x365c <STEPPER_u8Rotate+0x458>
    361e:	fe 01       	movw	r30, r28
    3620:	e9 53       	subi	r30, 0x39	; 57
    3622:	ff 4f       	sbci	r31, 0xFF	; 255
    3624:	88 ec       	ldi	r24, 0xC8	; 200
    3626:	90 e0       	ldi	r25, 0x00	; 0
    3628:	91 83       	std	Z+1, r25	; 0x01
    362a:	80 83       	st	Z, r24
    362c:	fe 01       	movw	r30, r28
    362e:	e9 53       	subi	r30, 0x39	; 57
    3630:	ff 4f       	sbci	r31, 0xFF	; 255
    3632:	80 81       	ld	r24, Z
    3634:	91 81       	ldd	r25, Z+1	; 0x01
    3636:	01 97       	sbiw	r24, 0x01	; 1
    3638:	f1 f7       	brne	.-4      	; 0x3636 <STEPPER_u8Rotate+0x432>
    363a:	fe 01       	movw	r30, r28
    363c:	e9 53       	subi	r30, 0x39	; 57
    363e:	ff 4f       	sbci	r31, 0xFF	; 255
    3640:	91 83       	std	Z+1, r25	; 0x01
    3642:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3644:	de 01       	movw	r26, r28
    3646:	a7 53       	subi	r26, 0x37	; 55
    3648:	bf 4f       	sbci	r27, 0xFF	; 255
    364a:	fe 01       	movw	r30, r28
    364c:	e7 53       	subi	r30, 0x37	; 55
    364e:	ff 4f       	sbci	r31, 0xFF	; 255
    3650:	80 81       	ld	r24, Z
    3652:	91 81       	ldd	r25, Z+1	; 0x01
    3654:	01 97       	sbiw	r24, 0x01	; 1
    3656:	11 96       	adiw	r26, 0x01	; 1
    3658:	9c 93       	st	X, r25
    365a:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    365c:	fe 01       	movw	r30, r28
    365e:	e7 53       	subi	r30, 0x37	; 55
    3660:	ff 4f       	sbci	r31, 0xFF	; 255
    3662:	80 81       	ld	r24, Z
    3664:	91 81       	ldd	r25, Z+1	; 0x01
    3666:	00 97       	sbiw	r24, 0x00	; 0
    3668:	d1 f6       	brne	.-76     	; 0x361e <STEPPER_u8Rotate+0x41a>
    366a:	27 c0       	rjmp	.+78     	; 0x36ba <STEPPER_u8Rotate+0x4b6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    366c:	8e 01       	movw	r16, r28
    366e:	07 53       	subi	r16, 0x37	; 55
    3670:	1f 4f       	sbci	r17, 0xFF	; 255
    3672:	fe 01       	movw	r30, r28
    3674:	e5 53       	subi	r30, 0x35	; 53
    3676:	ff 4f       	sbci	r31, 0xFF	; 255
    3678:	60 81       	ld	r22, Z
    367a:	71 81       	ldd	r23, Z+1	; 0x01
    367c:	82 81       	ldd	r24, Z+2	; 0x02
    367e:	93 81       	ldd	r25, Z+3	; 0x03
    3680:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3684:	dc 01       	movw	r26, r24
    3686:	cb 01       	movw	r24, r22
    3688:	f8 01       	movw	r30, r16
    368a:	91 83       	std	Z+1, r25	; 0x01
    368c:	80 83       	st	Z, r24
    368e:	de 01       	movw	r26, r28
    3690:	ab 53       	subi	r26, 0x3B	; 59
    3692:	bf 4f       	sbci	r27, 0xFF	; 255
    3694:	fe 01       	movw	r30, r28
    3696:	e7 53       	subi	r30, 0x37	; 55
    3698:	ff 4f       	sbci	r31, 0xFF	; 255
    369a:	80 81       	ld	r24, Z
    369c:	91 81       	ldd	r25, Z+1	; 0x01
    369e:	8d 93       	st	X+, r24
    36a0:	9c 93       	st	X, r25
    36a2:	fe 01       	movw	r30, r28
    36a4:	eb 53       	subi	r30, 0x3B	; 59
    36a6:	ff 4f       	sbci	r31, 0xFF	; 255
    36a8:	80 81       	ld	r24, Z
    36aa:	91 81       	ldd	r25, Z+1	; 0x01
    36ac:	01 97       	sbiw	r24, 0x01	; 1
    36ae:	f1 f7       	brne	.-4      	; 0x36ac <STEPPER_u8Rotate+0x4a8>
    36b0:	fe 01       	movw	r30, r28
    36b2:	eb 53       	subi	r30, 0x3B	; 59
    36b4:	ff 4f       	sbci	r31, 0xFF	; 255
    36b6:	91 83       	std	Z+1, r25	; 0x01
    36b8:	80 83       	st	Z, r24
				_delay_ms(2);
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN1,DIO_u8Pin_HIGH);
    36ba:	fe 01       	movw	r30, r28
    36bc:	e6 51       	subi	r30, 0x16	; 22
    36be:	ff 4f       	sbci	r31, 0xFF	; 255
    36c0:	01 90       	ld	r0, Z+
    36c2:	f0 81       	ld	r31, Z
    36c4:	e0 2d       	mov	r30, r0
    36c6:	80 81       	ld	r24, Z
    36c8:	fe 01       	movw	r30, r28
    36ca:	e6 51       	subi	r30, 0x16	; 22
    36cc:	ff 4f       	sbci	r31, 0xFF	; 255
    36ce:	01 90       	ld	r0, Z+
    36d0:	f0 81       	ld	r31, Z
    36d2:	e0 2d       	mov	r30, r0
    36d4:	91 81       	ldd	r25, Z+1	; 0x01
    36d6:	69 2f       	mov	r22, r25
    36d8:	41 e0       	ldi	r20, 0x01	; 1
    36da:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN2,DIO_u8Pin_HIGH);
    36de:	fe 01       	movw	r30, r28
    36e0:	e6 51       	subi	r30, 0x16	; 22
    36e2:	ff 4f       	sbci	r31, 0xFF	; 255
    36e4:	01 90       	ld	r0, Z+
    36e6:	f0 81       	ld	r31, Z
    36e8:	e0 2d       	mov	r30, r0
    36ea:	80 81       	ld	r24, Z
    36ec:	fe 01       	movw	r30, r28
    36ee:	e6 51       	subi	r30, 0x16	; 22
    36f0:	ff 4f       	sbci	r31, 0xFF	; 255
    36f2:	01 90       	ld	r0, Z+
    36f4:	f0 81       	ld	r31, Z
    36f6:	e0 2d       	mov	r30, r0
    36f8:	92 81       	ldd	r25, Z+2	; 0x02
    36fa:	69 2f       	mov	r22, r25
    36fc:	41 e0       	ldi	r20, 0x01	; 1
    36fe:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN3,DIO_u8Pin_LOW);
    3702:	fe 01       	movw	r30, r28
    3704:	e6 51       	subi	r30, 0x16	; 22
    3706:	ff 4f       	sbci	r31, 0xFF	; 255
    3708:	01 90       	ld	r0, Z+
    370a:	f0 81       	ld	r31, Z
    370c:	e0 2d       	mov	r30, r0
    370e:	80 81       	ld	r24, Z
    3710:	fe 01       	movw	r30, r28
    3712:	e6 51       	subi	r30, 0x16	; 22
    3714:	ff 4f       	sbci	r31, 0xFF	; 255
    3716:	01 90       	ld	r0, Z+
    3718:	f0 81       	ld	r31, Z
    371a:	e0 2d       	mov	r30, r0
    371c:	93 81       	ldd	r25, Z+3	; 0x03
    371e:	69 2f       	mov	r22, r25
    3720:	40 e0       	ldi	r20, 0x00	; 0
    3722:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN4,DIO_u8Pin_HIGH);
    3726:	fe 01       	movw	r30, r28
    3728:	e6 51       	subi	r30, 0x16	; 22
    372a:	ff 4f       	sbci	r31, 0xFF	; 255
    372c:	01 90       	ld	r0, Z+
    372e:	f0 81       	ld	r31, Z
    3730:	e0 2d       	mov	r30, r0
    3732:	80 81       	ld	r24, Z
    3734:	fe 01       	movw	r30, r28
    3736:	e6 51       	subi	r30, 0x16	; 22
    3738:	ff 4f       	sbci	r31, 0xFF	; 255
    373a:	01 90       	ld	r0, Z+
    373c:	f0 81       	ld	r31, Z
    373e:	e0 2d       	mov	r30, r0
    3740:	94 81       	ldd	r25, Z+4	; 0x04
    3742:	69 2f       	mov	r22, r25
    3744:	41 e0       	ldi	r20, 0x01	; 1
    3746:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
    374a:	fe 01       	movw	r30, r28
    374c:	ef 53       	subi	r30, 0x3F	; 63
    374e:	ff 4f       	sbci	r31, 0xFF	; 255
    3750:	80 e0       	ldi	r24, 0x00	; 0
    3752:	90 e0       	ldi	r25, 0x00	; 0
    3754:	a0 e0       	ldi	r26, 0x00	; 0
    3756:	b0 e4       	ldi	r27, 0x40	; 64
    3758:	80 83       	st	Z, r24
    375a:	91 83       	std	Z+1, r25	; 0x01
    375c:	a2 83       	std	Z+2, r26	; 0x02
    375e:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3760:	8e 01       	movw	r16, r28
    3762:	03 54       	subi	r16, 0x43	; 67
    3764:	1f 4f       	sbci	r17, 0xFF	; 255
    3766:	fe 01       	movw	r30, r28
    3768:	ef 53       	subi	r30, 0x3F	; 63
    376a:	ff 4f       	sbci	r31, 0xFF	; 255
    376c:	60 81       	ld	r22, Z
    376e:	71 81       	ldd	r23, Z+1	; 0x01
    3770:	82 81       	ldd	r24, Z+2	; 0x02
    3772:	93 81       	ldd	r25, Z+3	; 0x03
    3774:	20 e0       	ldi	r18, 0x00	; 0
    3776:	30 e0       	ldi	r19, 0x00	; 0
    3778:	4a ef       	ldi	r20, 0xFA	; 250
    377a:	54 e4       	ldi	r21, 0x44	; 68
    377c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3780:	dc 01       	movw	r26, r24
    3782:	cb 01       	movw	r24, r22
    3784:	f8 01       	movw	r30, r16
    3786:	80 83       	st	Z, r24
    3788:	91 83       	std	Z+1, r25	; 0x01
    378a:	a2 83       	std	Z+2, r26	; 0x02
    378c:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    378e:	fe 01       	movw	r30, r28
    3790:	e3 54       	subi	r30, 0x43	; 67
    3792:	ff 4f       	sbci	r31, 0xFF	; 255
    3794:	60 81       	ld	r22, Z
    3796:	71 81       	ldd	r23, Z+1	; 0x01
    3798:	82 81       	ldd	r24, Z+2	; 0x02
    379a:	93 81       	ldd	r25, Z+3	; 0x03
    379c:	20 e0       	ldi	r18, 0x00	; 0
    379e:	30 e0       	ldi	r19, 0x00	; 0
    37a0:	40 e8       	ldi	r20, 0x80	; 128
    37a2:	5f e3       	ldi	r21, 0x3F	; 63
    37a4:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    37a8:	88 23       	and	r24, r24
    37aa:	44 f4       	brge	.+16     	; 0x37bc <STEPPER_u8Rotate+0x5b8>
		__ticks = 1;
    37ac:	fe 01       	movw	r30, r28
    37ae:	e5 54       	subi	r30, 0x45	; 69
    37b0:	ff 4f       	sbci	r31, 0xFF	; 255
    37b2:	81 e0       	ldi	r24, 0x01	; 1
    37b4:	90 e0       	ldi	r25, 0x00	; 0
    37b6:	91 83       	std	Z+1, r25	; 0x01
    37b8:	80 83       	st	Z, r24
    37ba:	64 c0       	rjmp	.+200    	; 0x3884 <STEPPER_u8Rotate+0x680>
	else if (__tmp > 65535)
    37bc:	fe 01       	movw	r30, r28
    37be:	e3 54       	subi	r30, 0x43	; 67
    37c0:	ff 4f       	sbci	r31, 0xFF	; 255
    37c2:	60 81       	ld	r22, Z
    37c4:	71 81       	ldd	r23, Z+1	; 0x01
    37c6:	82 81       	ldd	r24, Z+2	; 0x02
    37c8:	93 81       	ldd	r25, Z+3	; 0x03
    37ca:	20 e0       	ldi	r18, 0x00	; 0
    37cc:	3f ef       	ldi	r19, 0xFF	; 255
    37ce:	4f e7       	ldi	r20, 0x7F	; 127
    37d0:	57 e4       	ldi	r21, 0x47	; 71
    37d2:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    37d6:	18 16       	cp	r1, r24
    37d8:	0c f0       	brlt	.+2      	; 0x37dc <STEPPER_u8Rotate+0x5d8>
    37da:	43 c0       	rjmp	.+134    	; 0x3862 <STEPPER_u8Rotate+0x65e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    37dc:	fe 01       	movw	r30, r28
    37de:	ef 53       	subi	r30, 0x3F	; 63
    37e0:	ff 4f       	sbci	r31, 0xFF	; 255
    37e2:	60 81       	ld	r22, Z
    37e4:	71 81       	ldd	r23, Z+1	; 0x01
    37e6:	82 81       	ldd	r24, Z+2	; 0x02
    37e8:	93 81       	ldd	r25, Z+3	; 0x03
    37ea:	20 e0       	ldi	r18, 0x00	; 0
    37ec:	30 e0       	ldi	r19, 0x00	; 0
    37ee:	40 e2       	ldi	r20, 0x20	; 32
    37f0:	51 e4       	ldi	r21, 0x41	; 65
    37f2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    37f6:	dc 01       	movw	r26, r24
    37f8:	cb 01       	movw	r24, r22
    37fa:	8e 01       	movw	r16, r28
    37fc:	05 54       	subi	r16, 0x45	; 69
    37fe:	1f 4f       	sbci	r17, 0xFF	; 255
    3800:	bc 01       	movw	r22, r24
    3802:	cd 01       	movw	r24, r26
    3804:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3808:	dc 01       	movw	r26, r24
    380a:	cb 01       	movw	r24, r22
    380c:	f8 01       	movw	r30, r16
    380e:	91 83       	std	Z+1, r25	; 0x01
    3810:	80 83       	st	Z, r24
    3812:	1f c0       	rjmp	.+62     	; 0x3852 <STEPPER_u8Rotate+0x64e>
    3814:	fe 01       	movw	r30, r28
    3816:	e7 54       	subi	r30, 0x47	; 71
    3818:	ff 4f       	sbci	r31, 0xFF	; 255
    381a:	88 ec       	ldi	r24, 0xC8	; 200
    381c:	90 e0       	ldi	r25, 0x00	; 0
    381e:	91 83       	std	Z+1, r25	; 0x01
    3820:	80 83       	st	Z, r24
    3822:	fe 01       	movw	r30, r28
    3824:	e7 54       	subi	r30, 0x47	; 71
    3826:	ff 4f       	sbci	r31, 0xFF	; 255
    3828:	80 81       	ld	r24, Z
    382a:	91 81       	ldd	r25, Z+1	; 0x01
    382c:	01 97       	sbiw	r24, 0x01	; 1
    382e:	f1 f7       	brne	.-4      	; 0x382c <STEPPER_u8Rotate+0x628>
    3830:	fe 01       	movw	r30, r28
    3832:	e7 54       	subi	r30, 0x47	; 71
    3834:	ff 4f       	sbci	r31, 0xFF	; 255
    3836:	91 83       	std	Z+1, r25	; 0x01
    3838:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    383a:	de 01       	movw	r26, r28
    383c:	a5 54       	subi	r26, 0x45	; 69
    383e:	bf 4f       	sbci	r27, 0xFF	; 255
    3840:	fe 01       	movw	r30, r28
    3842:	e5 54       	subi	r30, 0x45	; 69
    3844:	ff 4f       	sbci	r31, 0xFF	; 255
    3846:	80 81       	ld	r24, Z
    3848:	91 81       	ldd	r25, Z+1	; 0x01
    384a:	01 97       	sbiw	r24, 0x01	; 1
    384c:	11 96       	adiw	r26, 0x01	; 1
    384e:	9c 93       	st	X, r25
    3850:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3852:	fe 01       	movw	r30, r28
    3854:	e5 54       	subi	r30, 0x45	; 69
    3856:	ff 4f       	sbci	r31, 0xFF	; 255
    3858:	80 81       	ld	r24, Z
    385a:	91 81       	ldd	r25, Z+1	; 0x01
    385c:	00 97       	sbiw	r24, 0x00	; 0
    385e:	d1 f6       	brne	.-76     	; 0x3814 <STEPPER_u8Rotate+0x610>
    3860:	27 c0       	rjmp	.+78     	; 0x38b0 <STEPPER_u8Rotate+0x6ac>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3862:	8e 01       	movw	r16, r28
    3864:	05 54       	subi	r16, 0x45	; 69
    3866:	1f 4f       	sbci	r17, 0xFF	; 255
    3868:	fe 01       	movw	r30, r28
    386a:	e3 54       	subi	r30, 0x43	; 67
    386c:	ff 4f       	sbci	r31, 0xFF	; 255
    386e:	60 81       	ld	r22, Z
    3870:	71 81       	ldd	r23, Z+1	; 0x01
    3872:	82 81       	ldd	r24, Z+2	; 0x02
    3874:	93 81       	ldd	r25, Z+3	; 0x03
    3876:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    387a:	dc 01       	movw	r26, r24
    387c:	cb 01       	movw	r24, r22
    387e:	f8 01       	movw	r30, r16
    3880:	91 83       	std	Z+1, r25	; 0x01
    3882:	80 83       	st	Z, r24
    3884:	de 01       	movw	r26, r28
    3886:	a9 54       	subi	r26, 0x49	; 73
    3888:	bf 4f       	sbci	r27, 0xFF	; 255
    388a:	fe 01       	movw	r30, r28
    388c:	e5 54       	subi	r30, 0x45	; 69
    388e:	ff 4f       	sbci	r31, 0xFF	; 255
    3890:	80 81       	ld	r24, Z
    3892:	91 81       	ldd	r25, Z+1	; 0x01
    3894:	8d 93       	st	X+, r24
    3896:	9c 93       	st	X, r25
    3898:	fe 01       	movw	r30, r28
    389a:	e9 54       	subi	r30, 0x49	; 73
    389c:	ff 4f       	sbci	r31, 0xFF	; 255
    389e:	80 81       	ld	r24, Z
    38a0:	91 81       	ldd	r25, Z+1	; 0x01
    38a2:	01 97       	sbiw	r24, 0x01	; 1
    38a4:	f1 f7       	brne	.-4      	; 0x38a2 <STEPPER_u8Rotate+0x69e>
    38a6:	fe 01       	movw	r30, r28
    38a8:	e9 54       	subi	r30, 0x49	; 73
    38aa:	ff 4f       	sbci	r31, 0xFF	; 255
    38ac:	91 83       	std	Z+1, r25	; 0x01
    38ae:	80 83       	st	Z, r24
				_delay_ms(2);
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN1,DIO_u8Pin_HIGH);
    38b0:	fe 01       	movw	r30, r28
    38b2:	e6 51       	subi	r30, 0x16	; 22
    38b4:	ff 4f       	sbci	r31, 0xFF	; 255
    38b6:	01 90       	ld	r0, Z+
    38b8:	f0 81       	ld	r31, Z
    38ba:	e0 2d       	mov	r30, r0
    38bc:	80 81       	ld	r24, Z
    38be:	fe 01       	movw	r30, r28
    38c0:	e6 51       	subi	r30, 0x16	; 22
    38c2:	ff 4f       	sbci	r31, 0xFF	; 255
    38c4:	01 90       	ld	r0, Z+
    38c6:	f0 81       	ld	r31, Z
    38c8:	e0 2d       	mov	r30, r0
    38ca:	91 81       	ldd	r25, Z+1	; 0x01
    38cc:	69 2f       	mov	r22, r25
    38ce:	41 e0       	ldi	r20, 0x01	; 1
    38d0:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN2,DIO_u8Pin_HIGH);
    38d4:	fe 01       	movw	r30, r28
    38d6:	e6 51       	subi	r30, 0x16	; 22
    38d8:	ff 4f       	sbci	r31, 0xFF	; 255
    38da:	01 90       	ld	r0, Z+
    38dc:	f0 81       	ld	r31, Z
    38de:	e0 2d       	mov	r30, r0
    38e0:	80 81       	ld	r24, Z
    38e2:	fe 01       	movw	r30, r28
    38e4:	e6 51       	subi	r30, 0x16	; 22
    38e6:	ff 4f       	sbci	r31, 0xFF	; 255
    38e8:	01 90       	ld	r0, Z+
    38ea:	f0 81       	ld	r31, Z
    38ec:	e0 2d       	mov	r30, r0
    38ee:	92 81       	ldd	r25, Z+2	; 0x02
    38f0:	69 2f       	mov	r22, r25
    38f2:	41 e0       	ldi	r20, 0x01	; 1
    38f4:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN3,DIO_u8Pin_HIGH);
    38f8:	fe 01       	movw	r30, r28
    38fa:	e6 51       	subi	r30, 0x16	; 22
    38fc:	ff 4f       	sbci	r31, 0xFF	; 255
    38fe:	01 90       	ld	r0, Z+
    3900:	f0 81       	ld	r31, Z
    3902:	e0 2d       	mov	r30, r0
    3904:	80 81       	ld	r24, Z
    3906:	fe 01       	movw	r30, r28
    3908:	e6 51       	subi	r30, 0x16	; 22
    390a:	ff 4f       	sbci	r31, 0xFF	; 255
    390c:	01 90       	ld	r0, Z+
    390e:	f0 81       	ld	r31, Z
    3910:	e0 2d       	mov	r30, r0
    3912:	93 81       	ldd	r25, Z+3	; 0x03
    3914:	69 2f       	mov	r22, r25
    3916:	41 e0       	ldi	r20, 0x01	; 1
    3918:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN4,DIO_u8Pin_LOW);
    391c:	fe 01       	movw	r30, r28
    391e:	e6 51       	subi	r30, 0x16	; 22
    3920:	ff 4f       	sbci	r31, 0xFF	; 255
    3922:	01 90       	ld	r0, Z+
    3924:	f0 81       	ld	r31, Z
    3926:	e0 2d       	mov	r30, r0
    3928:	80 81       	ld	r24, Z
    392a:	fe 01       	movw	r30, r28
    392c:	e6 51       	subi	r30, 0x16	; 22
    392e:	ff 4f       	sbci	r31, 0xFF	; 255
    3930:	01 90       	ld	r0, Z+
    3932:	f0 81       	ld	r31, Z
    3934:	e0 2d       	mov	r30, r0
    3936:	94 81       	ldd	r25, Z+4	; 0x04
    3938:	69 2f       	mov	r22, r25
    393a:	40 e0       	ldi	r20, 0x00	; 0
    393c:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
    3940:	fe 01       	movw	r30, r28
    3942:	ed 54       	subi	r30, 0x4D	; 77
    3944:	ff 4f       	sbci	r31, 0xFF	; 255
    3946:	80 e0       	ldi	r24, 0x00	; 0
    3948:	90 e0       	ldi	r25, 0x00	; 0
    394a:	a0 e0       	ldi	r26, 0x00	; 0
    394c:	b0 e4       	ldi	r27, 0x40	; 64
    394e:	80 83       	st	Z, r24
    3950:	91 83       	std	Z+1, r25	; 0x01
    3952:	a2 83       	std	Z+2, r26	; 0x02
    3954:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3956:	8e 01       	movw	r16, r28
    3958:	01 55       	subi	r16, 0x51	; 81
    395a:	1f 4f       	sbci	r17, 0xFF	; 255
    395c:	fe 01       	movw	r30, r28
    395e:	ed 54       	subi	r30, 0x4D	; 77
    3960:	ff 4f       	sbci	r31, 0xFF	; 255
    3962:	60 81       	ld	r22, Z
    3964:	71 81       	ldd	r23, Z+1	; 0x01
    3966:	82 81       	ldd	r24, Z+2	; 0x02
    3968:	93 81       	ldd	r25, Z+3	; 0x03
    396a:	20 e0       	ldi	r18, 0x00	; 0
    396c:	30 e0       	ldi	r19, 0x00	; 0
    396e:	4a ef       	ldi	r20, 0xFA	; 250
    3970:	54 e4       	ldi	r21, 0x44	; 68
    3972:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3976:	dc 01       	movw	r26, r24
    3978:	cb 01       	movw	r24, r22
    397a:	f8 01       	movw	r30, r16
    397c:	80 83       	st	Z, r24
    397e:	91 83       	std	Z+1, r25	; 0x01
    3980:	a2 83       	std	Z+2, r26	; 0x02
    3982:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    3984:	fe 01       	movw	r30, r28
    3986:	e1 55       	subi	r30, 0x51	; 81
    3988:	ff 4f       	sbci	r31, 0xFF	; 255
    398a:	60 81       	ld	r22, Z
    398c:	71 81       	ldd	r23, Z+1	; 0x01
    398e:	82 81       	ldd	r24, Z+2	; 0x02
    3990:	93 81       	ldd	r25, Z+3	; 0x03
    3992:	20 e0       	ldi	r18, 0x00	; 0
    3994:	30 e0       	ldi	r19, 0x00	; 0
    3996:	40 e8       	ldi	r20, 0x80	; 128
    3998:	5f e3       	ldi	r21, 0x3F	; 63
    399a:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    399e:	88 23       	and	r24, r24
    39a0:	44 f4       	brge	.+16     	; 0x39b2 <STEPPER_u8Rotate+0x7ae>
		__ticks = 1;
    39a2:	fe 01       	movw	r30, r28
    39a4:	e3 55       	subi	r30, 0x53	; 83
    39a6:	ff 4f       	sbci	r31, 0xFF	; 255
    39a8:	81 e0       	ldi	r24, 0x01	; 1
    39aa:	90 e0       	ldi	r25, 0x00	; 0
    39ac:	91 83       	std	Z+1, r25	; 0x01
    39ae:	80 83       	st	Z, r24
    39b0:	64 c0       	rjmp	.+200    	; 0x3a7a <STEPPER_u8Rotate+0x876>
	else if (__tmp > 65535)
    39b2:	fe 01       	movw	r30, r28
    39b4:	e1 55       	subi	r30, 0x51	; 81
    39b6:	ff 4f       	sbci	r31, 0xFF	; 255
    39b8:	60 81       	ld	r22, Z
    39ba:	71 81       	ldd	r23, Z+1	; 0x01
    39bc:	82 81       	ldd	r24, Z+2	; 0x02
    39be:	93 81       	ldd	r25, Z+3	; 0x03
    39c0:	20 e0       	ldi	r18, 0x00	; 0
    39c2:	3f ef       	ldi	r19, 0xFF	; 255
    39c4:	4f e7       	ldi	r20, 0x7F	; 127
    39c6:	57 e4       	ldi	r21, 0x47	; 71
    39c8:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    39cc:	18 16       	cp	r1, r24
    39ce:	0c f0       	brlt	.+2      	; 0x39d2 <STEPPER_u8Rotate+0x7ce>
    39d0:	43 c0       	rjmp	.+134    	; 0x3a58 <STEPPER_u8Rotate+0x854>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    39d2:	fe 01       	movw	r30, r28
    39d4:	ed 54       	subi	r30, 0x4D	; 77
    39d6:	ff 4f       	sbci	r31, 0xFF	; 255
    39d8:	60 81       	ld	r22, Z
    39da:	71 81       	ldd	r23, Z+1	; 0x01
    39dc:	82 81       	ldd	r24, Z+2	; 0x02
    39de:	93 81       	ldd	r25, Z+3	; 0x03
    39e0:	20 e0       	ldi	r18, 0x00	; 0
    39e2:	30 e0       	ldi	r19, 0x00	; 0
    39e4:	40 e2       	ldi	r20, 0x20	; 32
    39e6:	51 e4       	ldi	r21, 0x41	; 65
    39e8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    39ec:	dc 01       	movw	r26, r24
    39ee:	cb 01       	movw	r24, r22
    39f0:	8e 01       	movw	r16, r28
    39f2:	03 55       	subi	r16, 0x53	; 83
    39f4:	1f 4f       	sbci	r17, 0xFF	; 255
    39f6:	bc 01       	movw	r22, r24
    39f8:	cd 01       	movw	r24, r26
    39fa:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    39fe:	dc 01       	movw	r26, r24
    3a00:	cb 01       	movw	r24, r22
    3a02:	f8 01       	movw	r30, r16
    3a04:	91 83       	std	Z+1, r25	; 0x01
    3a06:	80 83       	st	Z, r24
    3a08:	1f c0       	rjmp	.+62     	; 0x3a48 <STEPPER_u8Rotate+0x844>
    3a0a:	fe 01       	movw	r30, r28
    3a0c:	e5 55       	subi	r30, 0x55	; 85
    3a0e:	ff 4f       	sbci	r31, 0xFF	; 255
    3a10:	88 ec       	ldi	r24, 0xC8	; 200
    3a12:	90 e0       	ldi	r25, 0x00	; 0
    3a14:	91 83       	std	Z+1, r25	; 0x01
    3a16:	80 83       	st	Z, r24
    3a18:	fe 01       	movw	r30, r28
    3a1a:	e5 55       	subi	r30, 0x55	; 85
    3a1c:	ff 4f       	sbci	r31, 0xFF	; 255
    3a1e:	80 81       	ld	r24, Z
    3a20:	91 81       	ldd	r25, Z+1	; 0x01
    3a22:	01 97       	sbiw	r24, 0x01	; 1
    3a24:	f1 f7       	brne	.-4      	; 0x3a22 <STEPPER_u8Rotate+0x81e>
    3a26:	fe 01       	movw	r30, r28
    3a28:	e5 55       	subi	r30, 0x55	; 85
    3a2a:	ff 4f       	sbci	r31, 0xFF	; 255
    3a2c:	91 83       	std	Z+1, r25	; 0x01
    3a2e:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3a30:	de 01       	movw	r26, r28
    3a32:	a3 55       	subi	r26, 0x53	; 83
    3a34:	bf 4f       	sbci	r27, 0xFF	; 255
    3a36:	fe 01       	movw	r30, r28
    3a38:	e3 55       	subi	r30, 0x53	; 83
    3a3a:	ff 4f       	sbci	r31, 0xFF	; 255
    3a3c:	80 81       	ld	r24, Z
    3a3e:	91 81       	ldd	r25, Z+1	; 0x01
    3a40:	01 97       	sbiw	r24, 0x01	; 1
    3a42:	11 96       	adiw	r26, 0x01	; 1
    3a44:	9c 93       	st	X, r25
    3a46:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3a48:	fe 01       	movw	r30, r28
    3a4a:	e3 55       	subi	r30, 0x53	; 83
    3a4c:	ff 4f       	sbci	r31, 0xFF	; 255
    3a4e:	80 81       	ld	r24, Z
    3a50:	91 81       	ldd	r25, Z+1	; 0x01
    3a52:	00 97       	sbiw	r24, 0x00	; 0
    3a54:	d1 f6       	brne	.-76     	; 0x3a0a <STEPPER_u8Rotate+0x806>
    3a56:	3b cc       	rjmp	.-1930   	; 0x32ce <STEPPER_u8Rotate+0xca>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3a58:	8e 01       	movw	r16, r28
    3a5a:	03 55       	subi	r16, 0x53	; 83
    3a5c:	1f 4f       	sbci	r17, 0xFF	; 255
    3a5e:	fe 01       	movw	r30, r28
    3a60:	e1 55       	subi	r30, 0x51	; 81
    3a62:	ff 4f       	sbci	r31, 0xFF	; 255
    3a64:	60 81       	ld	r22, Z
    3a66:	71 81       	ldd	r23, Z+1	; 0x01
    3a68:	82 81       	ldd	r24, Z+2	; 0x02
    3a6a:	93 81       	ldd	r25, Z+3	; 0x03
    3a6c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3a70:	dc 01       	movw	r26, r24
    3a72:	cb 01       	movw	r24, r22
    3a74:	f8 01       	movw	r30, r16
    3a76:	91 83       	std	Z+1, r25	; 0x01
    3a78:	80 83       	st	Z, r24
    3a7a:	de 01       	movw	r26, r28
    3a7c:	a7 55       	subi	r26, 0x57	; 87
    3a7e:	bf 4f       	sbci	r27, 0xFF	; 255
    3a80:	fe 01       	movw	r30, r28
    3a82:	e3 55       	subi	r30, 0x53	; 83
    3a84:	ff 4f       	sbci	r31, 0xFF	; 255
    3a86:	80 81       	ld	r24, Z
    3a88:	91 81       	ldd	r25, Z+1	; 0x01
    3a8a:	11 96       	adiw	r26, 0x01	; 1
    3a8c:	9c 93       	st	X, r25
    3a8e:	8e 93       	st	-X, r24
    3a90:	fe 01       	movw	r30, r28
    3a92:	e7 55       	subi	r30, 0x57	; 87
    3a94:	ff 4f       	sbci	r31, 0xFF	; 255
    3a96:	80 81       	ld	r24, Z
    3a98:	91 81       	ldd	r25, Z+1	; 0x01
    3a9a:	01 97       	sbiw	r24, 0x01	; 1
    3a9c:	f1 f7       	brne	.-4      	; 0x3a9a <STEPPER_u8Rotate+0x896>
    3a9e:	fe 01       	movw	r30, r28
    3aa0:	e7 55       	subi	r30, 0x57	; 87
    3aa2:	ff 4f       	sbci	r31, 0xFF	; 255
    3aa4:	91 83       	std	Z+1, r25	; 0x01
    3aa6:	80 83       	st	Z, r24
    3aa8:	12 cc       	rjmp	.-2012   	; 0x32ce <STEPPER_u8Rotate+0xca>
				_delay_ms(2);
			} break;
			case CW: while(1)
			{
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN4,DIO_u8Pin_LOW);
    3aaa:	fe 01       	movw	r30, r28
    3aac:	e6 51       	subi	r30, 0x16	; 22
    3aae:	ff 4f       	sbci	r31, 0xFF	; 255
    3ab0:	01 90       	ld	r0, Z+
    3ab2:	f0 81       	ld	r31, Z
    3ab4:	e0 2d       	mov	r30, r0
    3ab6:	80 81       	ld	r24, Z
    3ab8:	fe 01       	movw	r30, r28
    3aba:	e6 51       	subi	r30, 0x16	; 22
    3abc:	ff 4f       	sbci	r31, 0xFF	; 255
    3abe:	01 90       	ld	r0, Z+
    3ac0:	f0 81       	ld	r31, Z
    3ac2:	e0 2d       	mov	r30, r0
    3ac4:	94 81       	ldd	r25, Z+4	; 0x04
    3ac6:	69 2f       	mov	r22, r25
    3ac8:	40 e0       	ldi	r20, 0x00	; 0
    3aca:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN3,DIO_u8Pin_HIGH);
    3ace:	fe 01       	movw	r30, r28
    3ad0:	e6 51       	subi	r30, 0x16	; 22
    3ad2:	ff 4f       	sbci	r31, 0xFF	; 255
    3ad4:	01 90       	ld	r0, Z+
    3ad6:	f0 81       	ld	r31, Z
    3ad8:	e0 2d       	mov	r30, r0
    3ada:	80 81       	ld	r24, Z
    3adc:	fe 01       	movw	r30, r28
    3ade:	e6 51       	subi	r30, 0x16	; 22
    3ae0:	ff 4f       	sbci	r31, 0xFF	; 255
    3ae2:	01 90       	ld	r0, Z+
    3ae4:	f0 81       	ld	r31, Z
    3ae6:	e0 2d       	mov	r30, r0
    3ae8:	93 81       	ldd	r25, Z+3	; 0x03
    3aea:	69 2f       	mov	r22, r25
    3aec:	41 e0       	ldi	r20, 0x01	; 1
    3aee:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN2,DIO_u8Pin_HIGH);
    3af2:	fe 01       	movw	r30, r28
    3af4:	e6 51       	subi	r30, 0x16	; 22
    3af6:	ff 4f       	sbci	r31, 0xFF	; 255
    3af8:	01 90       	ld	r0, Z+
    3afa:	f0 81       	ld	r31, Z
    3afc:	e0 2d       	mov	r30, r0
    3afe:	80 81       	ld	r24, Z
    3b00:	fe 01       	movw	r30, r28
    3b02:	e6 51       	subi	r30, 0x16	; 22
    3b04:	ff 4f       	sbci	r31, 0xFF	; 255
    3b06:	01 90       	ld	r0, Z+
    3b08:	f0 81       	ld	r31, Z
    3b0a:	e0 2d       	mov	r30, r0
    3b0c:	92 81       	ldd	r25, Z+2	; 0x02
    3b0e:	69 2f       	mov	r22, r25
    3b10:	41 e0       	ldi	r20, 0x01	; 1
    3b12:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN1,DIO_u8Pin_HIGH);
    3b16:	fe 01       	movw	r30, r28
    3b18:	e6 51       	subi	r30, 0x16	; 22
    3b1a:	ff 4f       	sbci	r31, 0xFF	; 255
    3b1c:	01 90       	ld	r0, Z+
    3b1e:	f0 81       	ld	r31, Z
    3b20:	e0 2d       	mov	r30, r0
    3b22:	80 81       	ld	r24, Z
    3b24:	fe 01       	movw	r30, r28
    3b26:	e6 51       	subi	r30, 0x16	; 22
    3b28:	ff 4f       	sbci	r31, 0xFF	; 255
    3b2a:	01 90       	ld	r0, Z+
    3b2c:	f0 81       	ld	r31, Z
    3b2e:	e0 2d       	mov	r30, r0
    3b30:	91 81       	ldd	r25, Z+1	; 0x01
    3b32:	69 2f       	mov	r22, r25
    3b34:	41 e0       	ldi	r20, 0x01	; 1
    3b36:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
    3b3a:	fe 01       	movw	r30, r28
    3b3c:	eb 55       	subi	r30, 0x5B	; 91
    3b3e:	ff 4f       	sbci	r31, 0xFF	; 255
    3b40:	80 e0       	ldi	r24, 0x00	; 0
    3b42:	90 e0       	ldi	r25, 0x00	; 0
    3b44:	a0 e0       	ldi	r26, 0x00	; 0
    3b46:	b0 e4       	ldi	r27, 0x40	; 64
    3b48:	80 83       	st	Z, r24
    3b4a:	91 83       	std	Z+1, r25	; 0x01
    3b4c:	a2 83       	std	Z+2, r26	; 0x02
    3b4e:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3b50:	8e 01       	movw	r16, r28
    3b52:	0f 55       	subi	r16, 0x5F	; 95
    3b54:	1f 4f       	sbci	r17, 0xFF	; 255
    3b56:	fe 01       	movw	r30, r28
    3b58:	eb 55       	subi	r30, 0x5B	; 91
    3b5a:	ff 4f       	sbci	r31, 0xFF	; 255
    3b5c:	60 81       	ld	r22, Z
    3b5e:	71 81       	ldd	r23, Z+1	; 0x01
    3b60:	82 81       	ldd	r24, Z+2	; 0x02
    3b62:	93 81       	ldd	r25, Z+3	; 0x03
    3b64:	20 e0       	ldi	r18, 0x00	; 0
    3b66:	30 e0       	ldi	r19, 0x00	; 0
    3b68:	4a ef       	ldi	r20, 0xFA	; 250
    3b6a:	54 e4       	ldi	r21, 0x44	; 68
    3b6c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3b70:	dc 01       	movw	r26, r24
    3b72:	cb 01       	movw	r24, r22
    3b74:	f8 01       	movw	r30, r16
    3b76:	80 83       	st	Z, r24
    3b78:	91 83       	std	Z+1, r25	; 0x01
    3b7a:	a2 83       	std	Z+2, r26	; 0x02
    3b7c:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    3b7e:	fe 01       	movw	r30, r28
    3b80:	ef 55       	subi	r30, 0x5F	; 95
    3b82:	ff 4f       	sbci	r31, 0xFF	; 255
    3b84:	60 81       	ld	r22, Z
    3b86:	71 81       	ldd	r23, Z+1	; 0x01
    3b88:	82 81       	ldd	r24, Z+2	; 0x02
    3b8a:	93 81       	ldd	r25, Z+3	; 0x03
    3b8c:	20 e0       	ldi	r18, 0x00	; 0
    3b8e:	30 e0       	ldi	r19, 0x00	; 0
    3b90:	40 e8       	ldi	r20, 0x80	; 128
    3b92:	5f e3       	ldi	r21, 0x3F	; 63
    3b94:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3b98:	88 23       	and	r24, r24
    3b9a:	44 f4       	brge	.+16     	; 0x3bac <STEPPER_u8Rotate+0x9a8>
		__ticks = 1;
    3b9c:	fe 01       	movw	r30, r28
    3b9e:	e1 56       	subi	r30, 0x61	; 97
    3ba0:	ff 4f       	sbci	r31, 0xFF	; 255
    3ba2:	81 e0       	ldi	r24, 0x01	; 1
    3ba4:	90 e0       	ldi	r25, 0x00	; 0
    3ba6:	91 83       	std	Z+1, r25	; 0x01
    3ba8:	80 83       	st	Z, r24
    3baa:	64 c0       	rjmp	.+200    	; 0x3c74 <STEPPER_u8Rotate+0xa70>
	else if (__tmp > 65535)
    3bac:	fe 01       	movw	r30, r28
    3bae:	ef 55       	subi	r30, 0x5F	; 95
    3bb0:	ff 4f       	sbci	r31, 0xFF	; 255
    3bb2:	60 81       	ld	r22, Z
    3bb4:	71 81       	ldd	r23, Z+1	; 0x01
    3bb6:	82 81       	ldd	r24, Z+2	; 0x02
    3bb8:	93 81       	ldd	r25, Z+3	; 0x03
    3bba:	20 e0       	ldi	r18, 0x00	; 0
    3bbc:	3f ef       	ldi	r19, 0xFF	; 255
    3bbe:	4f e7       	ldi	r20, 0x7F	; 127
    3bc0:	57 e4       	ldi	r21, 0x47	; 71
    3bc2:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    3bc6:	18 16       	cp	r1, r24
    3bc8:	0c f0       	brlt	.+2      	; 0x3bcc <STEPPER_u8Rotate+0x9c8>
    3bca:	43 c0       	rjmp	.+134    	; 0x3c52 <STEPPER_u8Rotate+0xa4e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3bcc:	fe 01       	movw	r30, r28
    3bce:	eb 55       	subi	r30, 0x5B	; 91
    3bd0:	ff 4f       	sbci	r31, 0xFF	; 255
    3bd2:	60 81       	ld	r22, Z
    3bd4:	71 81       	ldd	r23, Z+1	; 0x01
    3bd6:	82 81       	ldd	r24, Z+2	; 0x02
    3bd8:	93 81       	ldd	r25, Z+3	; 0x03
    3bda:	20 e0       	ldi	r18, 0x00	; 0
    3bdc:	30 e0       	ldi	r19, 0x00	; 0
    3bde:	40 e2       	ldi	r20, 0x20	; 32
    3be0:	51 e4       	ldi	r21, 0x41	; 65
    3be2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3be6:	dc 01       	movw	r26, r24
    3be8:	cb 01       	movw	r24, r22
    3bea:	8e 01       	movw	r16, r28
    3bec:	01 56       	subi	r16, 0x61	; 97
    3bee:	1f 4f       	sbci	r17, 0xFF	; 255
    3bf0:	bc 01       	movw	r22, r24
    3bf2:	cd 01       	movw	r24, r26
    3bf4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3bf8:	dc 01       	movw	r26, r24
    3bfa:	cb 01       	movw	r24, r22
    3bfc:	f8 01       	movw	r30, r16
    3bfe:	91 83       	std	Z+1, r25	; 0x01
    3c00:	80 83       	st	Z, r24
    3c02:	1f c0       	rjmp	.+62     	; 0x3c42 <STEPPER_u8Rotate+0xa3e>
    3c04:	fe 01       	movw	r30, r28
    3c06:	e3 56       	subi	r30, 0x63	; 99
    3c08:	ff 4f       	sbci	r31, 0xFF	; 255
    3c0a:	88 ec       	ldi	r24, 0xC8	; 200
    3c0c:	90 e0       	ldi	r25, 0x00	; 0
    3c0e:	91 83       	std	Z+1, r25	; 0x01
    3c10:	80 83       	st	Z, r24
    3c12:	fe 01       	movw	r30, r28
    3c14:	e3 56       	subi	r30, 0x63	; 99
    3c16:	ff 4f       	sbci	r31, 0xFF	; 255
    3c18:	80 81       	ld	r24, Z
    3c1a:	91 81       	ldd	r25, Z+1	; 0x01
    3c1c:	01 97       	sbiw	r24, 0x01	; 1
    3c1e:	f1 f7       	brne	.-4      	; 0x3c1c <STEPPER_u8Rotate+0xa18>
    3c20:	fe 01       	movw	r30, r28
    3c22:	e3 56       	subi	r30, 0x63	; 99
    3c24:	ff 4f       	sbci	r31, 0xFF	; 255
    3c26:	91 83       	std	Z+1, r25	; 0x01
    3c28:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3c2a:	de 01       	movw	r26, r28
    3c2c:	a1 56       	subi	r26, 0x61	; 97
    3c2e:	bf 4f       	sbci	r27, 0xFF	; 255
    3c30:	fe 01       	movw	r30, r28
    3c32:	e1 56       	subi	r30, 0x61	; 97
    3c34:	ff 4f       	sbci	r31, 0xFF	; 255
    3c36:	80 81       	ld	r24, Z
    3c38:	91 81       	ldd	r25, Z+1	; 0x01
    3c3a:	01 97       	sbiw	r24, 0x01	; 1
    3c3c:	11 96       	adiw	r26, 0x01	; 1
    3c3e:	9c 93       	st	X, r25
    3c40:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3c42:	fe 01       	movw	r30, r28
    3c44:	e1 56       	subi	r30, 0x61	; 97
    3c46:	ff 4f       	sbci	r31, 0xFF	; 255
    3c48:	80 81       	ld	r24, Z
    3c4a:	91 81       	ldd	r25, Z+1	; 0x01
    3c4c:	00 97       	sbiw	r24, 0x00	; 0
    3c4e:	d1 f6       	brne	.-76     	; 0x3c04 <STEPPER_u8Rotate+0xa00>
    3c50:	27 c0       	rjmp	.+78     	; 0x3ca0 <STEPPER_u8Rotate+0xa9c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3c52:	8e 01       	movw	r16, r28
    3c54:	01 56       	subi	r16, 0x61	; 97
    3c56:	1f 4f       	sbci	r17, 0xFF	; 255
    3c58:	fe 01       	movw	r30, r28
    3c5a:	ef 55       	subi	r30, 0x5F	; 95
    3c5c:	ff 4f       	sbci	r31, 0xFF	; 255
    3c5e:	60 81       	ld	r22, Z
    3c60:	71 81       	ldd	r23, Z+1	; 0x01
    3c62:	82 81       	ldd	r24, Z+2	; 0x02
    3c64:	93 81       	ldd	r25, Z+3	; 0x03
    3c66:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3c6a:	dc 01       	movw	r26, r24
    3c6c:	cb 01       	movw	r24, r22
    3c6e:	f8 01       	movw	r30, r16
    3c70:	91 83       	std	Z+1, r25	; 0x01
    3c72:	80 83       	st	Z, r24
    3c74:	de 01       	movw	r26, r28
    3c76:	a5 56       	subi	r26, 0x65	; 101
    3c78:	bf 4f       	sbci	r27, 0xFF	; 255
    3c7a:	fe 01       	movw	r30, r28
    3c7c:	e1 56       	subi	r30, 0x61	; 97
    3c7e:	ff 4f       	sbci	r31, 0xFF	; 255
    3c80:	80 81       	ld	r24, Z
    3c82:	91 81       	ldd	r25, Z+1	; 0x01
    3c84:	8d 93       	st	X+, r24
    3c86:	9c 93       	st	X, r25
    3c88:	fe 01       	movw	r30, r28
    3c8a:	e5 56       	subi	r30, 0x65	; 101
    3c8c:	ff 4f       	sbci	r31, 0xFF	; 255
    3c8e:	80 81       	ld	r24, Z
    3c90:	91 81       	ldd	r25, Z+1	; 0x01
    3c92:	01 97       	sbiw	r24, 0x01	; 1
    3c94:	f1 f7       	brne	.-4      	; 0x3c92 <STEPPER_u8Rotate+0xa8e>
    3c96:	fe 01       	movw	r30, r28
    3c98:	e5 56       	subi	r30, 0x65	; 101
    3c9a:	ff 4f       	sbci	r31, 0xFF	; 255
    3c9c:	91 83       	std	Z+1, r25	; 0x01
    3c9e:	80 83       	st	Z, r24
				_delay_ms(2);
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN4,DIO_u8Pin_HIGH);
    3ca0:	fe 01       	movw	r30, r28
    3ca2:	e6 51       	subi	r30, 0x16	; 22
    3ca4:	ff 4f       	sbci	r31, 0xFF	; 255
    3ca6:	01 90       	ld	r0, Z+
    3ca8:	f0 81       	ld	r31, Z
    3caa:	e0 2d       	mov	r30, r0
    3cac:	80 81       	ld	r24, Z
    3cae:	fe 01       	movw	r30, r28
    3cb0:	e6 51       	subi	r30, 0x16	; 22
    3cb2:	ff 4f       	sbci	r31, 0xFF	; 255
    3cb4:	01 90       	ld	r0, Z+
    3cb6:	f0 81       	ld	r31, Z
    3cb8:	e0 2d       	mov	r30, r0
    3cba:	94 81       	ldd	r25, Z+4	; 0x04
    3cbc:	69 2f       	mov	r22, r25
    3cbe:	41 e0       	ldi	r20, 0x01	; 1
    3cc0:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN3,DIO_u8Pin_LOW);
    3cc4:	fe 01       	movw	r30, r28
    3cc6:	e6 51       	subi	r30, 0x16	; 22
    3cc8:	ff 4f       	sbci	r31, 0xFF	; 255
    3cca:	01 90       	ld	r0, Z+
    3ccc:	f0 81       	ld	r31, Z
    3cce:	e0 2d       	mov	r30, r0
    3cd0:	80 81       	ld	r24, Z
    3cd2:	fe 01       	movw	r30, r28
    3cd4:	e6 51       	subi	r30, 0x16	; 22
    3cd6:	ff 4f       	sbci	r31, 0xFF	; 255
    3cd8:	01 90       	ld	r0, Z+
    3cda:	f0 81       	ld	r31, Z
    3cdc:	e0 2d       	mov	r30, r0
    3cde:	93 81       	ldd	r25, Z+3	; 0x03
    3ce0:	69 2f       	mov	r22, r25
    3ce2:	40 e0       	ldi	r20, 0x00	; 0
    3ce4:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN2,DIO_u8Pin_HIGH);
    3ce8:	fe 01       	movw	r30, r28
    3cea:	e6 51       	subi	r30, 0x16	; 22
    3cec:	ff 4f       	sbci	r31, 0xFF	; 255
    3cee:	01 90       	ld	r0, Z+
    3cf0:	f0 81       	ld	r31, Z
    3cf2:	e0 2d       	mov	r30, r0
    3cf4:	80 81       	ld	r24, Z
    3cf6:	fe 01       	movw	r30, r28
    3cf8:	e6 51       	subi	r30, 0x16	; 22
    3cfa:	ff 4f       	sbci	r31, 0xFF	; 255
    3cfc:	01 90       	ld	r0, Z+
    3cfe:	f0 81       	ld	r31, Z
    3d00:	e0 2d       	mov	r30, r0
    3d02:	92 81       	ldd	r25, Z+2	; 0x02
    3d04:	69 2f       	mov	r22, r25
    3d06:	41 e0       	ldi	r20, 0x01	; 1
    3d08:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN1,DIO_u8Pin_HIGH);
    3d0c:	fe 01       	movw	r30, r28
    3d0e:	e6 51       	subi	r30, 0x16	; 22
    3d10:	ff 4f       	sbci	r31, 0xFF	; 255
    3d12:	01 90       	ld	r0, Z+
    3d14:	f0 81       	ld	r31, Z
    3d16:	e0 2d       	mov	r30, r0
    3d18:	80 81       	ld	r24, Z
    3d1a:	fe 01       	movw	r30, r28
    3d1c:	e6 51       	subi	r30, 0x16	; 22
    3d1e:	ff 4f       	sbci	r31, 0xFF	; 255
    3d20:	01 90       	ld	r0, Z+
    3d22:	f0 81       	ld	r31, Z
    3d24:	e0 2d       	mov	r30, r0
    3d26:	91 81       	ldd	r25, Z+1	; 0x01
    3d28:	69 2f       	mov	r22, r25
    3d2a:	41 e0       	ldi	r20, 0x01	; 1
    3d2c:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
    3d30:	fe 01       	movw	r30, r28
    3d32:	e9 56       	subi	r30, 0x69	; 105
    3d34:	ff 4f       	sbci	r31, 0xFF	; 255
    3d36:	80 e0       	ldi	r24, 0x00	; 0
    3d38:	90 e0       	ldi	r25, 0x00	; 0
    3d3a:	a0 e0       	ldi	r26, 0x00	; 0
    3d3c:	b0 e4       	ldi	r27, 0x40	; 64
    3d3e:	80 83       	st	Z, r24
    3d40:	91 83       	std	Z+1, r25	; 0x01
    3d42:	a2 83       	std	Z+2, r26	; 0x02
    3d44:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3d46:	8e 01       	movw	r16, r28
    3d48:	0d 56       	subi	r16, 0x6D	; 109
    3d4a:	1f 4f       	sbci	r17, 0xFF	; 255
    3d4c:	fe 01       	movw	r30, r28
    3d4e:	e9 56       	subi	r30, 0x69	; 105
    3d50:	ff 4f       	sbci	r31, 0xFF	; 255
    3d52:	60 81       	ld	r22, Z
    3d54:	71 81       	ldd	r23, Z+1	; 0x01
    3d56:	82 81       	ldd	r24, Z+2	; 0x02
    3d58:	93 81       	ldd	r25, Z+3	; 0x03
    3d5a:	20 e0       	ldi	r18, 0x00	; 0
    3d5c:	30 e0       	ldi	r19, 0x00	; 0
    3d5e:	4a ef       	ldi	r20, 0xFA	; 250
    3d60:	54 e4       	ldi	r21, 0x44	; 68
    3d62:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3d66:	dc 01       	movw	r26, r24
    3d68:	cb 01       	movw	r24, r22
    3d6a:	f8 01       	movw	r30, r16
    3d6c:	80 83       	st	Z, r24
    3d6e:	91 83       	std	Z+1, r25	; 0x01
    3d70:	a2 83       	std	Z+2, r26	; 0x02
    3d72:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    3d74:	fe 01       	movw	r30, r28
    3d76:	ed 56       	subi	r30, 0x6D	; 109
    3d78:	ff 4f       	sbci	r31, 0xFF	; 255
    3d7a:	60 81       	ld	r22, Z
    3d7c:	71 81       	ldd	r23, Z+1	; 0x01
    3d7e:	82 81       	ldd	r24, Z+2	; 0x02
    3d80:	93 81       	ldd	r25, Z+3	; 0x03
    3d82:	20 e0       	ldi	r18, 0x00	; 0
    3d84:	30 e0       	ldi	r19, 0x00	; 0
    3d86:	40 e8       	ldi	r20, 0x80	; 128
    3d88:	5f e3       	ldi	r21, 0x3F	; 63
    3d8a:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3d8e:	88 23       	and	r24, r24
    3d90:	44 f4       	brge	.+16     	; 0x3da2 <STEPPER_u8Rotate+0xb9e>
		__ticks = 1;
    3d92:	fe 01       	movw	r30, r28
    3d94:	ef 56       	subi	r30, 0x6F	; 111
    3d96:	ff 4f       	sbci	r31, 0xFF	; 255
    3d98:	81 e0       	ldi	r24, 0x01	; 1
    3d9a:	90 e0       	ldi	r25, 0x00	; 0
    3d9c:	91 83       	std	Z+1, r25	; 0x01
    3d9e:	80 83       	st	Z, r24
    3da0:	64 c0       	rjmp	.+200    	; 0x3e6a <STEPPER_u8Rotate+0xc66>
	else if (__tmp > 65535)
    3da2:	fe 01       	movw	r30, r28
    3da4:	ed 56       	subi	r30, 0x6D	; 109
    3da6:	ff 4f       	sbci	r31, 0xFF	; 255
    3da8:	60 81       	ld	r22, Z
    3daa:	71 81       	ldd	r23, Z+1	; 0x01
    3dac:	82 81       	ldd	r24, Z+2	; 0x02
    3dae:	93 81       	ldd	r25, Z+3	; 0x03
    3db0:	20 e0       	ldi	r18, 0x00	; 0
    3db2:	3f ef       	ldi	r19, 0xFF	; 255
    3db4:	4f e7       	ldi	r20, 0x7F	; 127
    3db6:	57 e4       	ldi	r21, 0x47	; 71
    3db8:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    3dbc:	18 16       	cp	r1, r24
    3dbe:	0c f0       	brlt	.+2      	; 0x3dc2 <STEPPER_u8Rotate+0xbbe>
    3dc0:	43 c0       	rjmp	.+134    	; 0x3e48 <STEPPER_u8Rotate+0xc44>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3dc2:	fe 01       	movw	r30, r28
    3dc4:	e9 56       	subi	r30, 0x69	; 105
    3dc6:	ff 4f       	sbci	r31, 0xFF	; 255
    3dc8:	60 81       	ld	r22, Z
    3dca:	71 81       	ldd	r23, Z+1	; 0x01
    3dcc:	82 81       	ldd	r24, Z+2	; 0x02
    3dce:	93 81       	ldd	r25, Z+3	; 0x03
    3dd0:	20 e0       	ldi	r18, 0x00	; 0
    3dd2:	30 e0       	ldi	r19, 0x00	; 0
    3dd4:	40 e2       	ldi	r20, 0x20	; 32
    3dd6:	51 e4       	ldi	r21, 0x41	; 65
    3dd8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3ddc:	dc 01       	movw	r26, r24
    3dde:	cb 01       	movw	r24, r22
    3de0:	8e 01       	movw	r16, r28
    3de2:	0f 56       	subi	r16, 0x6F	; 111
    3de4:	1f 4f       	sbci	r17, 0xFF	; 255
    3de6:	bc 01       	movw	r22, r24
    3de8:	cd 01       	movw	r24, r26
    3dea:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3dee:	dc 01       	movw	r26, r24
    3df0:	cb 01       	movw	r24, r22
    3df2:	f8 01       	movw	r30, r16
    3df4:	91 83       	std	Z+1, r25	; 0x01
    3df6:	80 83       	st	Z, r24
    3df8:	1f c0       	rjmp	.+62     	; 0x3e38 <STEPPER_u8Rotate+0xc34>
    3dfa:	fe 01       	movw	r30, r28
    3dfc:	e1 57       	subi	r30, 0x71	; 113
    3dfe:	ff 4f       	sbci	r31, 0xFF	; 255
    3e00:	88 ec       	ldi	r24, 0xC8	; 200
    3e02:	90 e0       	ldi	r25, 0x00	; 0
    3e04:	91 83       	std	Z+1, r25	; 0x01
    3e06:	80 83       	st	Z, r24
    3e08:	fe 01       	movw	r30, r28
    3e0a:	e1 57       	subi	r30, 0x71	; 113
    3e0c:	ff 4f       	sbci	r31, 0xFF	; 255
    3e0e:	80 81       	ld	r24, Z
    3e10:	91 81       	ldd	r25, Z+1	; 0x01
    3e12:	01 97       	sbiw	r24, 0x01	; 1
    3e14:	f1 f7       	brne	.-4      	; 0x3e12 <STEPPER_u8Rotate+0xc0e>
    3e16:	fe 01       	movw	r30, r28
    3e18:	e1 57       	subi	r30, 0x71	; 113
    3e1a:	ff 4f       	sbci	r31, 0xFF	; 255
    3e1c:	91 83       	std	Z+1, r25	; 0x01
    3e1e:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3e20:	de 01       	movw	r26, r28
    3e22:	af 56       	subi	r26, 0x6F	; 111
    3e24:	bf 4f       	sbci	r27, 0xFF	; 255
    3e26:	fe 01       	movw	r30, r28
    3e28:	ef 56       	subi	r30, 0x6F	; 111
    3e2a:	ff 4f       	sbci	r31, 0xFF	; 255
    3e2c:	80 81       	ld	r24, Z
    3e2e:	91 81       	ldd	r25, Z+1	; 0x01
    3e30:	01 97       	sbiw	r24, 0x01	; 1
    3e32:	11 96       	adiw	r26, 0x01	; 1
    3e34:	9c 93       	st	X, r25
    3e36:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3e38:	fe 01       	movw	r30, r28
    3e3a:	ef 56       	subi	r30, 0x6F	; 111
    3e3c:	ff 4f       	sbci	r31, 0xFF	; 255
    3e3e:	80 81       	ld	r24, Z
    3e40:	91 81       	ldd	r25, Z+1	; 0x01
    3e42:	00 97       	sbiw	r24, 0x00	; 0
    3e44:	d1 f6       	brne	.-76     	; 0x3dfa <STEPPER_u8Rotate+0xbf6>
    3e46:	27 c0       	rjmp	.+78     	; 0x3e96 <STEPPER_u8Rotate+0xc92>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3e48:	8e 01       	movw	r16, r28
    3e4a:	0f 56       	subi	r16, 0x6F	; 111
    3e4c:	1f 4f       	sbci	r17, 0xFF	; 255
    3e4e:	fe 01       	movw	r30, r28
    3e50:	ed 56       	subi	r30, 0x6D	; 109
    3e52:	ff 4f       	sbci	r31, 0xFF	; 255
    3e54:	60 81       	ld	r22, Z
    3e56:	71 81       	ldd	r23, Z+1	; 0x01
    3e58:	82 81       	ldd	r24, Z+2	; 0x02
    3e5a:	93 81       	ldd	r25, Z+3	; 0x03
    3e5c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3e60:	dc 01       	movw	r26, r24
    3e62:	cb 01       	movw	r24, r22
    3e64:	f8 01       	movw	r30, r16
    3e66:	91 83       	std	Z+1, r25	; 0x01
    3e68:	80 83       	st	Z, r24
    3e6a:	de 01       	movw	r26, r28
    3e6c:	a3 57       	subi	r26, 0x73	; 115
    3e6e:	bf 4f       	sbci	r27, 0xFF	; 255
    3e70:	fe 01       	movw	r30, r28
    3e72:	ef 56       	subi	r30, 0x6F	; 111
    3e74:	ff 4f       	sbci	r31, 0xFF	; 255
    3e76:	80 81       	ld	r24, Z
    3e78:	91 81       	ldd	r25, Z+1	; 0x01
    3e7a:	8d 93       	st	X+, r24
    3e7c:	9c 93       	st	X, r25
    3e7e:	fe 01       	movw	r30, r28
    3e80:	e3 57       	subi	r30, 0x73	; 115
    3e82:	ff 4f       	sbci	r31, 0xFF	; 255
    3e84:	80 81       	ld	r24, Z
    3e86:	91 81       	ldd	r25, Z+1	; 0x01
    3e88:	01 97       	sbiw	r24, 0x01	; 1
    3e8a:	f1 f7       	brne	.-4      	; 0x3e88 <STEPPER_u8Rotate+0xc84>
    3e8c:	fe 01       	movw	r30, r28
    3e8e:	e3 57       	subi	r30, 0x73	; 115
    3e90:	ff 4f       	sbci	r31, 0xFF	; 255
    3e92:	91 83       	std	Z+1, r25	; 0x01
    3e94:	80 83       	st	Z, r24
				_delay_ms(2);
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN4,DIO_u8Pin_HIGH);
    3e96:	fe 01       	movw	r30, r28
    3e98:	e6 51       	subi	r30, 0x16	; 22
    3e9a:	ff 4f       	sbci	r31, 0xFF	; 255
    3e9c:	01 90       	ld	r0, Z+
    3e9e:	f0 81       	ld	r31, Z
    3ea0:	e0 2d       	mov	r30, r0
    3ea2:	80 81       	ld	r24, Z
    3ea4:	fe 01       	movw	r30, r28
    3ea6:	e6 51       	subi	r30, 0x16	; 22
    3ea8:	ff 4f       	sbci	r31, 0xFF	; 255
    3eaa:	01 90       	ld	r0, Z+
    3eac:	f0 81       	ld	r31, Z
    3eae:	e0 2d       	mov	r30, r0
    3eb0:	94 81       	ldd	r25, Z+4	; 0x04
    3eb2:	69 2f       	mov	r22, r25
    3eb4:	41 e0       	ldi	r20, 0x01	; 1
    3eb6:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN3,DIO_u8Pin_HIGH);
    3eba:	fe 01       	movw	r30, r28
    3ebc:	e6 51       	subi	r30, 0x16	; 22
    3ebe:	ff 4f       	sbci	r31, 0xFF	; 255
    3ec0:	01 90       	ld	r0, Z+
    3ec2:	f0 81       	ld	r31, Z
    3ec4:	e0 2d       	mov	r30, r0
    3ec6:	80 81       	ld	r24, Z
    3ec8:	fe 01       	movw	r30, r28
    3eca:	e6 51       	subi	r30, 0x16	; 22
    3ecc:	ff 4f       	sbci	r31, 0xFF	; 255
    3ece:	01 90       	ld	r0, Z+
    3ed0:	f0 81       	ld	r31, Z
    3ed2:	e0 2d       	mov	r30, r0
    3ed4:	93 81       	ldd	r25, Z+3	; 0x03
    3ed6:	69 2f       	mov	r22, r25
    3ed8:	41 e0       	ldi	r20, 0x01	; 1
    3eda:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN2,DIO_u8Pin_LOW);
    3ede:	fe 01       	movw	r30, r28
    3ee0:	e6 51       	subi	r30, 0x16	; 22
    3ee2:	ff 4f       	sbci	r31, 0xFF	; 255
    3ee4:	01 90       	ld	r0, Z+
    3ee6:	f0 81       	ld	r31, Z
    3ee8:	e0 2d       	mov	r30, r0
    3eea:	80 81       	ld	r24, Z
    3eec:	fe 01       	movw	r30, r28
    3eee:	e6 51       	subi	r30, 0x16	; 22
    3ef0:	ff 4f       	sbci	r31, 0xFF	; 255
    3ef2:	01 90       	ld	r0, Z+
    3ef4:	f0 81       	ld	r31, Z
    3ef6:	e0 2d       	mov	r30, r0
    3ef8:	92 81       	ldd	r25, Z+2	; 0x02
    3efa:	69 2f       	mov	r22, r25
    3efc:	40 e0       	ldi	r20, 0x00	; 0
    3efe:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN1,DIO_u8Pin_HIGH);
    3f02:	fe 01       	movw	r30, r28
    3f04:	e6 51       	subi	r30, 0x16	; 22
    3f06:	ff 4f       	sbci	r31, 0xFF	; 255
    3f08:	01 90       	ld	r0, Z+
    3f0a:	f0 81       	ld	r31, Z
    3f0c:	e0 2d       	mov	r30, r0
    3f0e:	80 81       	ld	r24, Z
    3f10:	fe 01       	movw	r30, r28
    3f12:	e6 51       	subi	r30, 0x16	; 22
    3f14:	ff 4f       	sbci	r31, 0xFF	; 255
    3f16:	01 90       	ld	r0, Z+
    3f18:	f0 81       	ld	r31, Z
    3f1a:	e0 2d       	mov	r30, r0
    3f1c:	91 81       	ldd	r25, Z+1	; 0x01
    3f1e:	69 2f       	mov	r22, r25
    3f20:	41 e0       	ldi	r20, 0x01	; 1
    3f22:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
    3f26:	fe 01       	movw	r30, r28
    3f28:	e7 57       	subi	r30, 0x77	; 119
    3f2a:	ff 4f       	sbci	r31, 0xFF	; 255
    3f2c:	80 e0       	ldi	r24, 0x00	; 0
    3f2e:	90 e0       	ldi	r25, 0x00	; 0
    3f30:	a0 e0       	ldi	r26, 0x00	; 0
    3f32:	b0 e4       	ldi	r27, 0x40	; 64
    3f34:	80 83       	st	Z, r24
    3f36:	91 83       	std	Z+1, r25	; 0x01
    3f38:	a2 83       	std	Z+2, r26	; 0x02
    3f3a:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3f3c:	8e 01       	movw	r16, r28
    3f3e:	0b 57       	subi	r16, 0x7B	; 123
    3f40:	1f 4f       	sbci	r17, 0xFF	; 255
    3f42:	fe 01       	movw	r30, r28
    3f44:	e7 57       	subi	r30, 0x77	; 119
    3f46:	ff 4f       	sbci	r31, 0xFF	; 255
    3f48:	60 81       	ld	r22, Z
    3f4a:	71 81       	ldd	r23, Z+1	; 0x01
    3f4c:	82 81       	ldd	r24, Z+2	; 0x02
    3f4e:	93 81       	ldd	r25, Z+3	; 0x03
    3f50:	20 e0       	ldi	r18, 0x00	; 0
    3f52:	30 e0       	ldi	r19, 0x00	; 0
    3f54:	4a ef       	ldi	r20, 0xFA	; 250
    3f56:	54 e4       	ldi	r21, 0x44	; 68
    3f58:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3f5c:	dc 01       	movw	r26, r24
    3f5e:	cb 01       	movw	r24, r22
    3f60:	f8 01       	movw	r30, r16
    3f62:	80 83       	st	Z, r24
    3f64:	91 83       	std	Z+1, r25	; 0x01
    3f66:	a2 83       	std	Z+2, r26	; 0x02
    3f68:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    3f6a:	fe 01       	movw	r30, r28
    3f6c:	eb 57       	subi	r30, 0x7B	; 123
    3f6e:	ff 4f       	sbci	r31, 0xFF	; 255
    3f70:	60 81       	ld	r22, Z
    3f72:	71 81       	ldd	r23, Z+1	; 0x01
    3f74:	82 81       	ldd	r24, Z+2	; 0x02
    3f76:	93 81       	ldd	r25, Z+3	; 0x03
    3f78:	20 e0       	ldi	r18, 0x00	; 0
    3f7a:	30 e0       	ldi	r19, 0x00	; 0
    3f7c:	40 e8       	ldi	r20, 0x80	; 128
    3f7e:	5f e3       	ldi	r21, 0x3F	; 63
    3f80:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3f84:	88 23       	and	r24, r24
    3f86:	44 f4       	brge	.+16     	; 0x3f98 <STEPPER_u8Rotate+0xd94>
		__ticks = 1;
    3f88:	fe 01       	movw	r30, r28
    3f8a:	ed 57       	subi	r30, 0x7D	; 125
    3f8c:	ff 4f       	sbci	r31, 0xFF	; 255
    3f8e:	81 e0       	ldi	r24, 0x01	; 1
    3f90:	90 e0       	ldi	r25, 0x00	; 0
    3f92:	91 83       	std	Z+1, r25	; 0x01
    3f94:	80 83       	st	Z, r24
    3f96:	64 c0       	rjmp	.+200    	; 0x4060 <STEPPER_u8Rotate+0xe5c>
	else if (__tmp > 65535)
    3f98:	fe 01       	movw	r30, r28
    3f9a:	eb 57       	subi	r30, 0x7B	; 123
    3f9c:	ff 4f       	sbci	r31, 0xFF	; 255
    3f9e:	60 81       	ld	r22, Z
    3fa0:	71 81       	ldd	r23, Z+1	; 0x01
    3fa2:	82 81       	ldd	r24, Z+2	; 0x02
    3fa4:	93 81       	ldd	r25, Z+3	; 0x03
    3fa6:	20 e0       	ldi	r18, 0x00	; 0
    3fa8:	3f ef       	ldi	r19, 0xFF	; 255
    3faa:	4f e7       	ldi	r20, 0x7F	; 127
    3fac:	57 e4       	ldi	r21, 0x47	; 71
    3fae:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    3fb2:	18 16       	cp	r1, r24
    3fb4:	0c f0       	brlt	.+2      	; 0x3fb8 <STEPPER_u8Rotate+0xdb4>
    3fb6:	43 c0       	rjmp	.+134    	; 0x403e <STEPPER_u8Rotate+0xe3a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3fb8:	fe 01       	movw	r30, r28
    3fba:	e7 57       	subi	r30, 0x77	; 119
    3fbc:	ff 4f       	sbci	r31, 0xFF	; 255
    3fbe:	60 81       	ld	r22, Z
    3fc0:	71 81       	ldd	r23, Z+1	; 0x01
    3fc2:	82 81       	ldd	r24, Z+2	; 0x02
    3fc4:	93 81       	ldd	r25, Z+3	; 0x03
    3fc6:	20 e0       	ldi	r18, 0x00	; 0
    3fc8:	30 e0       	ldi	r19, 0x00	; 0
    3fca:	40 e2       	ldi	r20, 0x20	; 32
    3fcc:	51 e4       	ldi	r21, 0x41	; 65
    3fce:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3fd2:	dc 01       	movw	r26, r24
    3fd4:	cb 01       	movw	r24, r22
    3fd6:	8e 01       	movw	r16, r28
    3fd8:	0d 57       	subi	r16, 0x7D	; 125
    3fda:	1f 4f       	sbci	r17, 0xFF	; 255
    3fdc:	bc 01       	movw	r22, r24
    3fde:	cd 01       	movw	r24, r26
    3fe0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3fe4:	dc 01       	movw	r26, r24
    3fe6:	cb 01       	movw	r24, r22
    3fe8:	f8 01       	movw	r30, r16
    3fea:	91 83       	std	Z+1, r25	; 0x01
    3fec:	80 83       	st	Z, r24
    3fee:	1f c0       	rjmp	.+62     	; 0x402e <STEPPER_u8Rotate+0xe2a>
    3ff0:	fe 01       	movw	r30, r28
    3ff2:	ef 57       	subi	r30, 0x7F	; 127
    3ff4:	ff 4f       	sbci	r31, 0xFF	; 255
    3ff6:	88 ec       	ldi	r24, 0xC8	; 200
    3ff8:	90 e0       	ldi	r25, 0x00	; 0
    3ffa:	91 83       	std	Z+1, r25	; 0x01
    3ffc:	80 83       	st	Z, r24
    3ffe:	fe 01       	movw	r30, r28
    4000:	ef 57       	subi	r30, 0x7F	; 127
    4002:	ff 4f       	sbci	r31, 0xFF	; 255
    4004:	80 81       	ld	r24, Z
    4006:	91 81       	ldd	r25, Z+1	; 0x01
    4008:	01 97       	sbiw	r24, 0x01	; 1
    400a:	f1 f7       	brne	.-4      	; 0x4008 <STEPPER_u8Rotate+0xe04>
    400c:	fe 01       	movw	r30, r28
    400e:	ef 57       	subi	r30, 0x7F	; 127
    4010:	ff 4f       	sbci	r31, 0xFF	; 255
    4012:	91 83       	std	Z+1, r25	; 0x01
    4014:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4016:	de 01       	movw	r26, r28
    4018:	ad 57       	subi	r26, 0x7D	; 125
    401a:	bf 4f       	sbci	r27, 0xFF	; 255
    401c:	fe 01       	movw	r30, r28
    401e:	ed 57       	subi	r30, 0x7D	; 125
    4020:	ff 4f       	sbci	r31, 0xFF	; 255
    4022:	80 81       	ld	r24, Z
    4024:	91 81       	ldd	r25, Z+1	; 0x01
    4026:	01 97       	sbiw	r24, 0x01	; 1
    4028:	11 96       	adiw	r26, 0x01	; 1
    402a:	9c 93       	st	X, r25
    402c:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    402e:	fe 01       	movw	r30, r28
    4030:	ed 57       	subi	r30, 0x7D	; 125
    4032:	ff 4f       	sbci	r31, 0xFF	; 255
    4034:	80 81       	ld	r24, Z
    4036:	91 81       	ldd	r25, Z+1	; 0x01
    4038:	00 97       	sbiw	r24, 0x00	; 0
    403a:	d1 f6       	brne	.-76     	; 0x3ff0 <STEPPER_u8Rotate+0xdec>
    403c:	27 c0       	rjmp	.+78     	; 0x408c <STEPPER_u8Rotate+0xe88>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    403e:	8e 01       	movw	r16, r28
    4040:	0d 57       	subi	r16, 0x7D	; 125
    4042:	1f 4f       	sbci	r17, 0xFF	; 255
    4044:	fe 01       	movw	r30, r28
    4046:	eb 57       	subi	r30, 0x7B	; 123
    4048:	ff 4f       	sbci	r31, 0xFF	; 255
    404a:	60 81       	ld	r22, Z
    404c:	71 81       	ldd	r23, Z+1	; 0x01
    404e:	82 81       	ldd	r24, Z+2	; 0x02
    4050:	93 81       	ldd	r25, Z+3	; 0x03
    4052:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4056:	dc 01       	movw	r26, r24
    4058:	cb 01       	movw	r24, r22
    405a:	f8 01       	movw	r30, r16
    405c:	91 83       	std	Z+1, r25	; 0x01
    405e:	80 83       	st	Z, r24
    4060:	de 01       	movw	r26, r28
    4062:	a1 58       	subi	r26, 0x81	; 129
    4064:	bf 4f       	sbci	r27, 0xFF	; 255
    4066:	fe 01       	movw	r30, r28
    4068:	ed 57       	subi	r30, 0x7D	; 125
    406a:	ff 4f       	sbci	r31, 0xFF	; 255
    406c:	80 81       	ld	r24, Z
    406e:	91 81       	ldd	r25, Z+1	; 0x01
    4070:	8d 93       	st	X+, r24
    4072:	9c 93       	st	X, r25
    4074:	fe 01       	movw	r30, r28
    4076:	e1 58       	subi	r30, 0x81	; 129
    4078:	ff 4f       	sbci	r31, 0xFF	; 255
    407a:	80 81       	ld	r24, Z
    407c:	91 81       	ldd	r25, Z+1	; 0x01
    407e:	01 97       	sbiw	r24, 0x01	; 1
    4080:	f1 f7       	brne	.-4      	; 0x407e <STEPPER_u8Rotate+0xe7a>
    4082:	fe 01       	movw	r30, r28
    4084:	e1 58       	subi	r30, 0x81	; 129
    4086:	ff 4f       	sbci	r31, 0xFF	; 255
    4088:	91 83       	std	Z+1, r25	; 0x01
    408a:	80 83       	st	Z, r24
				_delay_ms(2);
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN4,DIO_u8Pin_HIGH);
    408c:	fe 01       	movw	r30, r28
    408e:	e6 51       	subi	r30, 0x16	; 22
    4090:	ff 4f       	sbci	r31, 0xFF	; 255
    4092:	01 90       	ld	r0, Z+
    4094:	f0 81       	ld	r31, Z
    4096:	e0 2d       	mov	r30, r0
    4098:	80 81       	ld	r24, Z
    409a:	fe 01       	movw	r30, r28
    409c:	e6 51       	subi	r30, 0x16	; 22
    409e:	ff 4f       	sbci	r31, 0xFF	; 255
    40a0:	01 90       	ld	r0, Z+
    40a2:	f0 81       	ld	r31, Z
    40a4:	e0 2d       	mov	r30, r0
    40a6:	94 81       	ldd	r25, Z+4	; 0x04
    40a8:	69 2f       	mov	r22, r25
    40aa:	41 e0       	ldi	r20, 0x01	; 1
    40ac:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN3,DIO_u8Pin_HIGH);
    40b0:	fe 01       	movw	r30, r28
    40b2:	e6 51       	subi	r30, 0x16	; 22
    40b4:	ff 4f       	sbci	r31, 0xFF	; 255
    40b6:	01 90       	ld	r0, Z+
    40b8:	f0 81       	ld	r31, Z
    40ba:	e0 2d       	mov	r30, r0
    40bc:	80 81       	ld	r24, Z
    40be:	fe 01       	movw	r30, r28
    40c0:	e6 51       	subi	r30, 0x16	; 22
    40c2:	ff 4f       	sbci	r31, 0xFF	; 255
    40c4:	01 90       	ld	r0, Z+
    40c6:	f0 81       	ld	r31, Z
    40c8:	e0 2d       	mov	r30, r0
    40ca:	93 81       	ldd	r25, Z+3	; 0x03
    40cc:	69 2f       	mov	r22, r25
    40ce:	41 e0       	ldi	r20, 0x01	; 1
    40d0:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN2,DIO_u8Pin_HIGH);
    40d4:	fe 01       	movw	r30, r28
    40d6:	e6 51       	subi	r30, 0x16	; 22
    40d8:	ff 4f       	sbci	r31, 0xFF	; 255
    40da:	01 90       	ld	r0, Z+
    40dc:	f0 81       	ld	r31, Z
    40de:	e0 2d       	mov	r30, r0
    40e0:	80 81       	ld	r24, Z
    40e2:	fe 01       	movw	r30, r28
    40e4:	e6 51       	subi	r30, 0x16	; 22
    40e6:	ff 4f       	sbci	r31, 0xFF	; 255
    40e8:	01 90       	ld	r0, Z+
    40ea:	f0 81       	ld	r31, Z
    40ec:	e0 2d       	mov	r30, r0
    40ee:	92 81       	ldd	r25, Z+2	; 0x02
    40f0:	69 2f       	mov	r22, r25
    40f2:	41 e0       	ldi	r20, 0x01	; 1
    40f4:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN1,DIO_u8Pin_LOW);
    40f8:	fe 01       	movw	r30, r28
    40fa:	e6 51       	subi	r30, 0x16	; 22
    40fc:	ff 4f       	sbci	r31, 0xFF	; 255
    40fe:	01 90       	ld	r0, Z+
    4100:	f0 81       	ld	r31, Z
    4102:	e0 2d       	mov	r30, r0
    4104:	80 81       	ld	r24, Z
    4106:	fe 01       	movw	r30, r28
    4108:	e6 51       	subi	r30, 0x16	; 22
    410a:	ff 4f       	sbci	r31, 0xFF	; 255
    410c:	01 90       	ld	r0, Z+
    410e:	f0 81       	ld	r31, Z
    4110:	e0 2d       	mov	r30, r0
    4112:	91 81       	ldd	r25, Z+1	; 0x01
    4114:	69 2f       	mov	r22, r25
    4116:	40 e0       	ldi	r20, 0x00	; 0
    4118:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
    411c:	fe 01       	movw	r30, r28
    411e:	e5 58       	subi	r30, 0x85	; 133
    4120:	ff 4f       	sbci	r31, 0xFF	; 255
    4122:	80 e0       	ldi	r24, 0x00	; 0
    4124:	90 e0       	ldi	r25, 0x00	; 0
    4126:	a0 e0       	ldi	r26, 0x00	; 0
    4128:	b0 e4       	ldi	r27, 0x40	; 64
    412a:	80 83       	st	Z, r24
    412c:	91 83       	std	Z+1, r25	; 0x01
    412e:	a2 83       	std	Z+2, r26	; 0x02
    4130:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4132:	8e 01       	movw	r16, r28
    4134:	09 58       	subi	r16, 0x89	; 137
    4136:	1f 4f       	sbci	r17, 0xFF	; 255
    4138:	fe 01       	movw	r30, r28
    413a:	e5 58       	subi	r30, 0x85	; 133
    413c:	ff 4f       	sbci	r31, 0xFF	; 255
    413e:	60 81       	ld	r22, Z
    4140:	71 81       	ldd	r23, Z+1	; 0x01
    4142:	82 81       	ldd	r24, Z+2	; 0x02
    4144:	93 81       	ldd	r25, Z+3	; 0x03
    4146:	20 e0       	ldi	r18, 0x00	; 0
    4148:	30 e0       	ldi	r19, 0x00	; 0
    414a:	4a ef       	ldi	r20, 0xFA	; 250
    414c:	54 e4       	ldi	r21, 0x44	; 68
    414e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4152:	dc 01       	movw	r26, r24
    4154:	cb 01       	movw	r24, r22
    4156:	f8 01       	movw	r30, r16
    4158:	80 83       	st	Z, r24
    415a:	91 83       	std	Z+1, r25	; 0x01
    415c:	a2 83       	std	Z+2, r26	; 0x02
    415e:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    4160:	fe 01       	movw	r30, r28
    4162:	e9 58       	subi	r30, 0x89	; 137
    4164:	ff 4f       	sbci	r31, 0xFF	; 255
    4166:	60 81       	ld	r22, Z
    4168:	71 81       	ldd	r23, Z+1	; 0x01
    416a:	82 81       	ldd	r24, Z+2	; 0x02
    416c:	93 81       	ldd	r25, Z+3	; 0x03
    416e:	20 e0       	ldi	r18, 0x00	; 0
    4170:	30 e0       	ldi	r19, 0x00	; 0
    4172:	40 e8       	ldi	r20, 0x80	; 128
    4174:	5f e3       	ldi	r21, 0x3F	; 63
    4176:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    417a:	88 23       	and	r24, r24
    417c:	44 f4       	brge	.+16     	; 0x418e <STEPPER_u8Rotate+0xf8a>
		__ticks = 1;
    417e:	fe 01       	movw	r30, r28
    4180:	eb 58       	subi	r30, 0x8B	; 139
    4182:	ff 4f       	sbci	r31, 0xFF	; 255
    4184:	81 e0       	ldi	r24, 0x01	; 1
    4186:	90 e0       	ldi	r25, 0x00	; 0
    4188:	91 83       	std	Z+1, r25	; 0x01
    418a:	80 83       	st	Z, r24
    418c:	64 c0       	rjmp	.+200    	; 0x4256 <STEPPER_u8Rotate+0x1052>
	else if (__tmp > 65535)
    418e:	fe 01       	movw	r30, r28
    4190:	e9 58       	subi	r30, 0x89	; 137
    4192:	ff 4f       	sbci	r31, 0xFF	; 255
    4194:	60 81       	ld	r22, Z
    4196:	71 81       	ldd	r23, Z+1	; 0x01
    4198:	82 81       	ldd	r24, Z+2	; 0x02
    419a:	93 81       	ldd	r25, Z+3	; 0x03
    419c:	20 e0       	ldi	r18, 0x00	; 0
    419e:	3f ef       	ldi	r19, 0xFF	; 255
    41a0:	4f e7       	ldi	r20, 0x7F	; 127
    41a2:	57 e4       	ldi	r21, 0x47	; 71
    41a4:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    41a8:	18 16       	cp	r1, r24
    41aa:	0c f0       	brlt	.+2      	; 0x41ae <STEPPER_u8Rotate+0xfaa>
    41ac:	43 c0       	rjmp	.+134    	; 0x4234 <STEPPER_u8Rotate+0x1030>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    41ae:	fe 01       	movw	r30, r28
    41b0:	e5 58       	subi	r30, 0x85	; 133
    41b2:	ff 4f       	sbci	r31, 0xFF	; 255
    41b4:	60 81       	ld	r22, Z
    41b6:	71 81       	ldd	r23, Z+1	; 0x01
    41b8:	82 81       	ldd	r24, Z+2	; 0x02
    41ba:	93 81       	ldd	r25, Z+3	; 0x03
    41bc:	20 e0       	ldi	r18, 0x00	; 0
    41be:	30 e0       	ldi	r19, 0x00	; 0
    41c0:	40 e2       	ldi	r20, 0x20	; 32
    41c2:	51 e4       	ldi	r21, 0x41	; 65
    41c4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    41c8:	dc 01       	movw	r26, r24
    41ca:	cb 01       	movw	r24, r22
    41cc:	8e 01       	movw	r16, r28
    41ce:	0b 58       	subi	r16, 0x8B	; 139
    41d0:	1f 4f       	sbci	r17, 0xFF	; 255
    41d2:	bc 01       	movw	r22, r24
    41d4:	cd 01       	movw	r24, r26
    41d6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    41da:	dc 01       	movw	r26, r24
    41dc:	cb 01       	movw	r24, r22
    41de:	f8 01       	movw	r30, r16
    41e0:	91 83       	std	Z+1, r25	; 0x01
    41e2:	80 83       	st	Z, r24
    41e4:	1f c0       	rjmp	.+62     	; 0x4224 <STEPPER_u8Rotate+0x1020>
    41e6:	fe 01       	movw	r30, r28
    41e8:	ed 58       	subi	r30, 0x8D	; 141
    41ea:	ff 4f       	sbci	r31, 0xFF	; 255
    41ec:	88 ec       	ldi	r24, 0xC8	; 200
    41ee:	90 e0       	ldi	r25, 0x00	; 0
    41f0:	91 83       	std	Z+1, r25	; 0x01
    41f2:	80 83       	st	Z, r24
    41f4:	fe 01       	movw	r30, r28
    41f6:	ed 58       	subi	r30, 0x8D	; 141
    41f8:	ff 4f       	sbci	r31, 0xFF	; 255
    41fa:	80 81       	ld	r24, Z
    41fc:	91 81       	ldd	r25, Z+1	; 0x01
    41fe:	01 97       	sbiw	r24, 0x01	; 1
    4200:	f1 f7       	brne	.-4      	; 0x41fe <STEPPER_u8Rotate+0xffa>
    4202:	fe 01       	movw	r30, r28
    4204:	ed 58       	subi	r30, 0x8D	; 141
    4206:	ff 4f       	sbci	r31, 0xFF	; 255
    4208:	91 83       	std	Z+1, r25	; 0x01
    420a:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    420c:	de 01       	movw	r26, r28
    420e:	ab 58       	subi	r26, 0x8B	; 139
    4210:	bf 4f       	sbci	r27, 0xFF	; 255
    4212:	fe 01       	movw	r30, r28
    4214:	eb 58       	subi	r30, 0x8B	; 139
    4216:	ff 4f       	sbci	r31, 0xFF	; 255
    4218:	80 81       	ld	r24, Z
    421a:	91 81       	ldd	r25, Z+1	; 0x01
    421c:	01 97       	sbiw	r24, 0x01	; 1
    421e:	11 96       	adiw	r26, 0x01	; 1
    4220:	9c 93       	st	X, r25
    4222:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4224:	fe 01       	movw	r30, r28
    4226:	eb 58       	subi	r30, 0x8B	; 139
    4228:	ff 4f       	sbci	r31, 0xFF	; 255
    422a:	80 81       	ld	r24, Z
    422c:	91 81       	ldd	r25, Z+1	; 0x01
    422e:	00 97       	sbiw	r24, 0x00	; 0
    4230:	d1 f6       	brne	.-76     	; 0x41e6 <STEPPER_u8Rotate+0xfe2>
    4232:	3b cc       	rjmp	.-1930   	; 0x3aaa <STEPPER_u8Rotate+0x8a6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4234:	8e 01       	movw	r16, r28
    4236:	0b 58       	subi	r16, 0x8B	; 139
    4238:	1f 4f       	sbci	r17, 0xFF	; 255
    423a:	fe 01       	movw	r30, r28
    423c:	e9 58       	subi	r30, 0x89	; 137
    423e:	ff 4f       	sbci	r31, 0xFF	; 255
    4240:	60 81       	ld	r22, Z
    4242:	71 81       	ldd	r23, Z+1	; 0x01
    4244:	82 81       	ldd	r24, Z+2	; 0x02
    4246:	93 81       	ldd	r25, Z+3	; 0x03
    4248:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    424c:	dc 01       	movw	r26, r24
    424e:	cb 01       	movw	r24, r22
    4250:	f8 01       	movw	r30, r16
    4252:	91 83       	std	Z+1, r25	; 0x01
    4254:	80 83       	st	Z, r24
    4256:	de 01       	movw	r26, r28
    4258:	af 58       	subi	r26, 0x8F	; 143
    425a:	bf 4f       	sbci	r27, 0xFF	; 255
    425c:	fe 01       	movw	r30, r28
    425e:	eb 58       	subi	r30, 0x8B	; 139
    4260:	ff 4f       	sbci	r31, 0xFF	; 255
    4262:	80 81       	ld	r24, Z
    4264:	91 81       	ldd	r25, Z+1	; 0x01
    4266:	11 96       	adiw	r26, 0x01	; 1
    4268:	9c 93       	st	X, r25
    426a:	8e 93       	st	-X, r24
    426c:	fe 01       	movw	r30, r28
    426e:	ef 58       	subi	r30, 0x8F	; 143
    4270:	ff 4f       	sbci	r31, 0xFF	; 255
    4272:	80 81       	ld	r24, Z
    4274:	91 81       	ldd	r25, Z+1	; 0x01
    4276:	01 97       	sbiw	r24, 0x01	; 1
    4278:	f1 f7       	brne	.-4      	; 0x4276 <STEPPER_u8Rotate+0x1072>
    427a:	fe 01       	movw	r30, r28
    427c:	ef 58       	subi	r30, 0x8F	; 143
    427e:	ff 4f       	sbci	r31, 0xFF	; 255
    4280:	91 83       	std	Z+1, r25	; 0x01
    4282:	80 83       	st	Z, r24
    4284:	12 cc       	rjmp	.-2012   	; 0x3aaa <STEPPER_u8Rotate+0x8a6>
				_delay_ms(2);
			} break;
			default: Local_u8ErorState=WORNG_DIRECTION; break;
    4286:	fe 01       	movw	r30, r28
    4288:	e7 51       	subi	r30, 0x17	; 23
    428a:	ff 4f       	sbci	r31, 0xFF	; 255
    428c:	85 e0       	ldi	r24, 0x05	; 5
    428e:	80 83       	st	Z, r24
    4290:	4a c7       	rjmp	.+3732   	; 0x5126 <STEPPER_u8Rotate+0x1f22>
			}
		}
		else
		{
			Local_u32IterationsNum=(Copy_u16Angle*10)/7;
    4292:	fe 01       	movw	r30, r28
    4294:	e4 51       	subi	r30, 0x14	; 20
    4296:	ff 4f       	sbci	r31, 0xFF	; 255
    4298:	80 81       	ld	r24, Z
    429a:	91 81       	ldd	r25, Z+1	; 0x01
    429c:	9c 01       	movw	r18, r24
    429e:	22 0f       	add	r18, r18
    42a0:	33 1f       	adc	r19, r19
    42a2:	c9 01       	movw	r24, r18
    42a4:	88 0f       	add	r24, r24
    42a6:	99 1f       	adc	r25, r25
    42a8:	88 0f       	add	r24, r24
    42aa:	99 1f       	adc	r25, r25
    42ac:	82 0f       	add	r24, r18
    42ae:	93 1f       	adc	r25, r19
    42b0:	27 e0       	ldi	r18, 0x07	; 7
    42b2:	30 e0       	ldi	r19, 0x00	; 0
    42b4:	b9 01       	movw	r22, r18
    42b6:	0e 94 9d 35 	call	0x6b3a	; 0x6b3a <__udivmodhi4>
    42ba:	cb 01       	movw	r24, r22
    42bc:	fe 01       	movw	r30, r28
    42be:	eb 51       	subi	r30, 0x1B	; 27
    42c0:	ff 4f       	sbci	r31, 0xFF	; 255
    42c2:	cc 01       	movw	r24, r24
    42c4:	a0 e0       	ldi	r26, 0x00	; 0
    42c6:	b0 e0       	ldi	r27, 0x00	; 0
    42c8:	80 83       	st	Z, r24
    42ca:	91 83       	std	Z+1, r25	; 0x01
    42cc:	a2 83       	std	Z+2, r26	; 0x02
    42ce:	b3 83       	std	Z+3, r27	; 0x03
			switch(Copy_u8Direction)
    42d0:	fe 01       	movw	r30, r28
    42d2:	e2 51       	subi	r30, 0x12	; 18
    42d4:	ff 4f       	sbci	r31, 0xFF	; 255
    42d6:	80 81       	ld	r24, Z
    42d8:	28 2f       	mov	r18, r24
    42da:	30 e0       	ldi	r19, 0x00	; 0
    42dc:	c1 51       	subi	r28, 0x11	; 17
    42de:	df 4f       	sbci	r29, 0xFF	; 255
    42e0:	39 83       	std	Y+1, r19	; 0x01
    42e2:	28 83       	st	Y, r18
    42e4:	cf 5e       	subi	r28, 0xEF	; 239
    42e6:	d0 40       	sbci	r29, 0x00	; 0
    42e8:	c1 51       	subi	r28, 0x11	; 17
    42ea:	df 4f       	sbci	r29, 0xFF	; 255
    42ec:	88 81       	ld	r24, Y
    42ee:	99 81       	ldd	r25, Y+1	; 0x01
    42f0:	cf 5e       	subi	r28, 0xEF	; 239
    42f2:	d0 40       	sbci	r29, 0x00	; 0
    42f4:	81 30       	cpi	r24, 0x01	; 1
    42f6:	91 05       	cpc	r25, r1
    42f8:	09 f4       	brne	.+2      	; 0x42fc <STEPPER_u8Rotate+0x10f8>
    42fa:	f8 c3       	rjmp	.+2032   	; 0x4aec <STEPPER_u8Rotate+0x18e8>
    42fc:	c1 51       	subi	r28, 0x11	; 17
    42fe:	df 4f       	sbci	r29, 0xFF	; 255
    4300:	e8 81       	ld	r30, Y
    4302:	f9 81       	ldd	r31, Y+1	; 0x01
    4304:	cf 5e       	subi	r28, 0xEF	; 239
    4306:	d0 40       	sbci	r29, 0x00	; 0
    4308:	e2 30       	cpi	r30, 0x02	; 2
    430a:	f1 05       	cpc	r31, r1
    430c:	09 f0       	breq	.+2      	; 0x4310 <STEPPER_u8Rotate+0x110c>
    430e:	06 c7       	rjmp	.+3596   	; 0x511c <STEPPER_u8Rotate+0x1f18>
			{
			case CCW: for(Local_u32Counter=0;Local_u32Counter<Local_u32IterationsNum;Local_u32Counter++)
    4310:	fe 01       	movw	r30, r28
    4312:	ef 51       	subi	r30, 0x1F	; 31
    4314:	ff 4f       	sbci	r31, 0xFF	; 255
    4316:	10 82       	st	Z, r1
    4318:	11 82       	std	Z+1, r1	; 0x01
    431a:	12 82       	std	Z+2, r1	; 0x02
    431c:	13 82       	std	Z+3, r1	; 0x03
    431e:	d0 c3       	rjmp	.+1952   	; 0x4ac0 <STEPPER_u8Rotate+0x18bc>
			{
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN1,DIO_u8Pin_LOW);
    4320:	fe 01       	movw	r30, r28
    4322:	e6 51       	subi	r30, 0x16	; 22
    4324:	ff 4f       	sbci	r31, 0xFF	; 255
    4326:	01 90       	ld	r0, Z+
    4328:	f0 81       	ld	r31, Z
    432a:	e0 2d       	mov	r30, r0
    432c:	80 81       	ld	r24, Z
    432e:	fe 01       	movw	r30, r28
    4330:	e6 51       	subi	r30, 0x16	; 22
    4332:	ff 4f       	sbci	r31, 0xFF	; 255
    4334:	01 90       	ld	r0, Z+
    4336:	f0 81       	ld	r31, Z
    4338:	e0 2d       	mov	r30, r0
    433a:	91 81       	ldd	r25, Z+1	; 0x01
    433c:	69 2f       	mov	r22, r25
    433e:	40 e0       	ldi	r20, 0x00	; 0
    4340:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN2,DIO_u8Pin_HIGH);
    4344:	fe 01       	movw	r30, r28
    4346:	e6 51       	subi	r30, 0x16	; 22
    4348:	ff 4f       	sbci	r31, 0xFF	; 255
    434a:	01 90       	ld	r0, Z+
    434c:	f0 81       	ld	r31, Z
    434e:	e0 2d       	mov	r30, r0
    4350:	80 81       	ld	r24, Z
    4352:	fe 01       	movw	r30, r28
    4354:	e6 51       	subi	r30, 0x16	; 22
    4356:	ff 4f       	sbci	r31, 0xFF	; 255
    4358:	01 90       	ld	r0, Z+
    435a:	f0 81       	ld	r31, Z
    435c:	e0 2d       	mov	r30, r0
    435e:	92 81       	ldd	r25, Z+2	; 0x02
    4360:	69 2f       	mov	r22, r25
    4362:	41 e0       	ldi	r20, 0x01	; 1
    4364:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN3,DIO_u8Pin_HIGH);
    4368:	fe 01       	movw	r30, r28
    436a:	e6 51       	subi	r30, 0x16	; 22
    436c:	ff 4f       	sbci	r31, 0xFF	; 255
    436e:	01 90       	ld	r0, Z+
    4370:	f0 81       	ld	r31, Z
    4372:	e0 2d       	mov	r30, r0
    4374:	80 81       	ld	r24, Z
    4376:	fe 01       	movw	r30, r28
    4378:	e6 51       	subi	r30, 0x16	; 22
    437a:	ff 4f       	sbci	r31, 0xFF	; 255
    437c:	01 90       	ld	r0, Z+
    437e:	f0 81       	ld	r31, Z
    4380:	e0 2d       	mov	r30, r0
    4382:	93 81       	ldd	r25, Z+3	; 0x03
    4384:	69 2f       	mov	r22, r25
    4386:	41 e0       	ldi	r20, 0x01	; 1
    4388:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN4,DIO_u8Pin_HIGH);
    438c:	fe 01       	movw	r30, r28
    438e:	e6 51       	subi	r30, 0x16	; 22
    4390:	ff 4f       	sbci	r31, 0xFF	; 255
    4392:	01 90       	ld	r0, Z+
    4394:	f0 81       	ld	r31, Z
    4396:	e0 2d       	mov	r30, r0
    4398:	80 81       	ld	r24, Z
    439a:	fe 01       	movw	r30, r28
    439c:	e6 51       	subi	r30, 0x16	; 22
    439e:	ff 4f       	sbci	r31, 0xFF	; 255
    43a0:	01 90       	ld	r0, Z+
    43a2:	f0 81       	ld	r31, Z
    43a4:	e0 2d       	mov	r30, r0
    43a6:	94 81       	ldd	r25, Z+4	; 0x04
    43a8:	69 2f       	mov	r22, r25
    43aa:	41 e0       	ldi	r20, 0x01	; 1
    43ac:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
    43b0:	fe 01       	movw	r30, r28
    43b2:	e3 59       	subi	r30, 0x93	; 147
    43b4:	ff 4f       	sbci	r31, 0xFF	; 255
    43b6:	80 e0       	ldi	r24, 0x00	; 0
    43b8:	90 e0       	ldi	r25, 0x00	; 0
    43ba:	a0 e0       	ldi	r26, 0x00	; 0
    43bc:	b0 e4       	ldi	r27, 0x40	; 64
    43be:	80 83       	st	Z, r24
    43c0:	91 83       	std	Z+1, r25	; 0x01
    43c2:	a2 83       	std	Z+2, r26	; 0x02
    43c4:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    43c6:	8e 01       	movw	r16, r28
    43c8:	07 59       	subi	r16, 0x97	; 151
    43ca:	1f 4f       	sbci	r17, 0xFF	; 255
    43cc:	fe 01       	movw	r30, r28
    43ce:	e3 59       	subi	r30, 0x93	; 147
    43d0:	ff 4f       	sbci	r31, 0xFF	; 255
    43d2:	60 81       	ld	r22, Z
    43d4:	71 81       	ldd	r23, Z+1	; 0x01
    43d6:	82 81       	ldd	r24, Z+2	; 0x02
    43d8:	93 81       	ldd	r25, Z+3	; 0x03
    43da:	20 e0       	ldi	r18, 0x00	; 0
    43dc:	30 e0       	ldi	r19, 0x00	; 0
    43de:	4a ef       	ldi	r20, 0xFA	; 250
    43e0:	54 e4       	ldi	r21, 0x44	; 68
    43e2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    43e6:	dc 01       	movw	r26, r24
    43e8:	cb 01       	movw	r24, r22
    43ea:	f8 01       	movw	r30, r16
    43ec:	80 83       	st	Z, r24
    43ee:	91 83       	std	Z+1, r25	; 0x01
    43f0:	a2 83       	std	Z+2, r26	; 0x02
    43f2:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    43f4:	fe 01       	movw	r30, r28
    43f6:	e7 59       	subi	r30, 0x97	; 151
    43f8:	ff 4f       	sbci	r31, 0xFF	; 255
    43fa:	60 81       	ld	r22, Z
    43fc:	71 81       	ldd	r23, Z+1	; 0x01
    43fe:	82 81       	ldd	r24, Z+2	; 0x02
    4400:	93 81       	ldd	r25, Z+3	; 0x03
    4402:	20 e0       	ldi	r18, 0x00	; 0
    4404:	30 e0       	ldi	r19, 0x00	; 0
    4406:	40 e8       	ldi	r20, 0x80	; 128
    4408:	5f e3       	ldi	r21, 0x3F	; 63
    440a:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    440e:	88 23       	and	r24, r24
    4410:	44 f4       	brge	.+16     	; 0x4422 <STEPPER_u8Rotate+0x121e>
		__ticks = 1;
    4412:	fe 01       	movw	r30, r28
    4414:	e9 59       	subi	r30, 0x99	; 153
    4416:	ff 4f       	sbci	r31, 0xFF	; 255
    4418:	81 e0       	ldi	r24, 0x01	; 1
    441a:	90 e0       	ldi	r25, 0x00	; 0
    441c:	91 83       	std	Z+1, r25	; 0x01
    441e:	80 83       	st	Z, r24
    4420:	64 c0       	rjmp	.+200    	; 0x44ea <STEPPER_u8Rotate+0x12e6>
	else if (__tmp > 65535)
    4422:	fe 01       	movw	r30, r28
    4424:	e7 59       	subi	r30, 0x97	; 151
    4426:	ff 4f       	sbci	r31, 0xFF	; 255
    4428:	60 81       	ld	r22, Z
    442a:	71 81       	ldd	r23, Z+1	; 0x01
    442c:	82 81       	ldd	r24, Z+2	; 0x02
    442e:	93 81       	ldd	r25, Z+3	; 0x03
    4430:	20 e0       	ldi	r18, 0x00	; 0
    4432:	3f ef       	ldi	r19, 0xFF	; 255
    4434:	4f e7       	ldi	r20, 0x7F	; 127
    4436:	57 e4       	ldi	r21, 0x47	; 71
    4438:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    443c:	18 16       	cp	r1, r24
    443e:	0c f0       	brlt	.+2      	; 0x4442 <STEPPER_u8Rotate+0x123e>
    4440:	43 c0       	rjmp	.+134    	; 0x44c8 <STEPPER_u8Rotate+0x12c4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4442:	fe 01       	movw	r30, r28
    4444:	e3 59       	subi	r30, 0x93	; 147
    4446:	ff 4f       	sbci	r31, 0xFF	; 255
    4448:	60 81       	ld	r22, Z
    444a:	71 81       	ldd	r23, Z+1	; 0x01
    444c:	82 81       	ldd	r24, Z+2	; 0x02
    444e:	93 81       	ldd	r25, Z+3	; 0x03
    4450:	20 e0       	ldi	r18, 0x00	; 0
    4452:	30 e0       	ldi	r19, 0x00	; 0
    4454:	40 e2       	ldi	r20, 0x20	; 32
    4456:	51 e4       	ldi	r21, 0x41	; 65
    4458:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    445c:	dc 01       	movw	r26, r24
    445e:	cb 01       	movw	r24, r22
    4460:	8e 01       	movw	r16, r28
    4462:	09 59       	subi	r16, 0x99	; 153
    4464:	1f 4f       	sbci	r17, 0xFF	; 255
    4466:	bc 01       	movw	r22, r24
    4468:	cd 01       	movw	r24, r26
    446a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    446e:	dc 01       	movw	r26, r24
    4470:	cb 01       	movw	r24, r22
    4472:	f8 01       	movw	r30, r16
    4474:	91 83       	std	Z+1, r25	; 0x01
    4476:	80 83       	st	Z, r24
    4478:	1f c0       	rjmp	.+62     	; 0x44b8 <STEPPER_u8Rotate+0x12b4>
    447a:	fe 01       	movw	r30, r28
    447c:	eb 59       	subi	r30, 0x9B	; 155
    447e:	ff 4f       	sbci	r31, 0xFF	; 255
    4480:	88 ec       	ldi	r24, 0xC8	; 200
    4482:	90 e0       	ldi	r25, 0x00	; 0
    4484:	91 83       	std	Z+1, r25	; 0x01
    4486:	80 83       	st	Z, r24
    4488:	fe 01       	movw	r30, r28
    448a:	eb 59       	subi	r30, 0x9B	; 155
    448c:	ff 4f       	sbci	r31, 0xFF	; 255
    448e:	80 81       	ld	r24, Z
    4490:	91 81       	ldd	r25, Z+1	; 0x01
    4492:	01 97       	sbiw	r24, 0x01	; 1
    4494:	f1 f7       	brne	.-4      	; 0x4492 <STEPPER_u8Rotate+0x128e>
    4496:	fe 01       	movw	r30, r28
    4498:	eb 59       	subi	r30, 0x9B	; 155
    449a:	ff 4f       	sbci	r31, 0xFF	; 255
    449c:	91 83       	std	Z+1, r25	; 0x01
    449e:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    44a0:	de 01       	movw	r26, r28
    44a2:	a9 59       	subi	r26, 0x99	; 153
    44a4:	bf 4f       	sbci	r27, 0xFF	; 255
    44a6:	fe 01       	movw	r30, r28
    44a8:	e9 59       	subi	r30, 0x99	; 153
    44aa:	ff 4f       	sbci	r31, 0xFF	; 255
    44ac:	80 81       	ld	r24, Z
    44ae:	91 81       	ldd	r25, Z+1	; 0x01
    44b0:	01 97       	sbiw	r24, 0x01	; 1
    44b2:	11 96       	adiw	r26, 0x01	; 1
    44b4:	9c 93       	st	X, r25
    44b6:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    44b8:	fe 01       	movw	r30, r28
    44ba:	e9 59       	subi	r30, 0x99	; 153
    44bc:	ff 4f       	sbci	r31, 0xFF	; 255
    44be:	80 81       	ld	r24, Z
    44c0:	91 81       	ldd	r25, Z+1	; 0x01
    44c2:	00 97       	sbiw	r24, 0x00	; 0
    44c4:	d1 f6       	brne	.-76     	; 0x447a <STEPPER_u8Rotate+0x1276>
    44c6:	27 c0       	rjmp	.+78     	; 0x4516 <STEPPER_u8Rotate+0x1312>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    44c8:	8e 01       	movw	r16, r28
    44ca:	09 59       	subi	r16, 0x99	; 153
    44cc:	1f 4f       	sbci	r17, 0xFF	; 255
    44ce:	fe 01       	movw	r30, r28
    44d0:	e7 59       	subi	r30, 0x97	; 151
    44d2:	ff 4f       	sbci	r31, 0xFF	; 255
    44d4:	60 81       	ld	r22, Z
    44d6:	71 81       	ldd	r23, Z+1	; 0x01
    44d8:	82 81       	ldd	r24, Z+2	; 0x02
    44da:	93 81       	ldd	r25, Z+3	; 0x03
    44dc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    44e0:	dc 01       	movw	r26, r24
    44e2:	cb 01       	movw	r24, r22
    44e4:	f8 01       	movw	r30, r16
    44e6:	91 83       	std	Z+1, r25	; 0x01
    44e8:	80 83       	st	Z, r24
    44ea:	de 01       	movw	r26, r28
    44ec:	ad 59       	subi	r26, 0x9D	; 157
    44ee:	bf 4f       	sbci	r27, 0xFF	; 255
    44f0:	fe 01       	movw	r30, r28
    44f2:	e9 59       	subi	r30, 0x99	; 153
    44f4:	ff 4f       	sbci	r31, 0xFF	; 255
    44f6:	80 81       	ld	r24, Z
    44f8:	91 81       	ldd	r25, Z+1	; 0x01
    44fa:	8d 93       	st	X+, r24
    44fc:	9c 93       	st	X, r25
    44fe:	fe 01       	movw	r30, r28
    4500:	ed 59       	subi	r30, 0x9D	; 157
    4502:	ff 4f       	sbci	r31, 0xFF	; 255
    4504:	80 81       	ld	r24, Z
    4506:	91 81       	ldd	r25, Z+1	; 0x01
    4508:	01 97       	sbiw	r24, 0x01	; 1
    450a:	f1 f7       	brne	.-4      	; 0x4508 <STEPPER_u8Rotate+0x1304>
    450c:	fe 01       	movw	r30, r28
    450e:	ed 59       	subi	r30, 0x9D	; 157
    4510:	ff 4f       	sbci	r31, 0xFF	; 255
    4512:	91 83       	std	Z+1, r25	; 0x01
    4514:	80 83       	st	Z, r24
				_delay_ms(2);
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN1,DIO_u8Pin_HIGH);
    4516:	fe 01       	movw	r30, r28
    4518:	e6 51       	subi	r30, 0x16	; 22
    451a:	ff 4f       	sbci	r31, 0xFF	; 255
    451c:	01 90       	ld	r0, Z+
    451e:	f0 81       	ld	r31, Z
    4520:	e0 2d       	mov	r30, r0
    4522:	80 81       	ld	r24, Z
    4524:	fe 01       	movw	r30, r28
    4526:	e6 51       	subi	r30, 0x16	; 22
    4528:	ff 4f       	sbci	r31, 0xFF	; 255
    452a:	01 90       	ld	r0, Z+
    452c:	f0 81       	ld	r31, Z
    452e:	e0 2d       	mov	r30, r0
    4530:	91 81       	ldd	r25, Z+1	; 0x01
    4532:	69 2f       	mov	r22, r25
    4534:	41 e0       	ldi	r20, 0x01	; 1
    4536:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN2,DIO_u8Pin_LOW);
    453a:	fe 01       	movw	r30, r28
    453c:	e6 51       	subi	r30, 0x16	; 22
    453e:	ff 4f       	sbci	r31, 0xFF	; 255
    4540:	01 90       	ld	r0, Z+
    4542:	f0 81       	ld	r31, Z
    4544:	e0 2d       	mov	r30, r0
    4546:	80 81       	ld	r24, Z
    4548:	fe 01       	movw	r30, r28
    454a:	e6 51       	subi	r30, 0x16	; 22
    454c:	ff 4f       	sbci	r31, 0xFF	; 255
    454e:	01 90       	ld	r0, Z+
    4550:	f0 81       	ld	r31, Z
    4552:	e0 2d       	mov	r30, r0
    4554:	92 81       	ldd	r25, Z+2	; 0x02
    4556:	69 2f       	mov	r22, r25
    4558:	40 e0       	ldi	r20, 0x00	; 0
    455a:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN3,DIO_u8Pin_HIGH);
    455e:	fe 01       	movw	r30, r28
    4560:	e6 51       	subi	r30, 0x16	; 22
    4562:	ff 4f       	sbci	r31, 0xFF	; 255
    4564:	01 90       	ld	r0, Z+
    4566:	f0 81       	ld	r31, Z
    4568:	e0 2d       	mov	r30, r0
    456a:	80 81       	ld	r24, Z
    456c:	fe 01       	movw	r30, r28
    456e:	e6 51       	subi	r30, 0x16	; 22
    4570:	ff 4f       	sbci	r31, 0xFF	; 255
    4572:	01 90       	ld	r0, Z+
    4574:	f0 81       	ld	r31, Z
    4576:	e0 2d       	mov	r30, r0
    4578:	93 81       	ldd	r25, Z+3	; 0x03
    457a:	69 2f       	mov	r22, r25
    457c:	41 e0       	ldi	r20, 0x01	; 1
    457e:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN4,DIO_u8Pin_HIGH);
    4582:	fe 01       	movw	r30, r28
    4584:	e6 51       	subi	r30, 0x16	; 22
    4586:	ff 4f       	sbci	r31, 0xFF	; 255
    4588:	01 90       	ld	r0, Z+
    458a:	f0 81       	ld	r31, Z
    458c:	e0 2d       	mov	r30, r0
    458e:	80 81       	ld	r24, Z
    4590:	fe 01       	movw	r30, r28
    4592:	e6 51       	subi	r30, 0x16	; 22
    4594:	ff 4f       	sbci	r31, 0xFF	; 255
    4596:	01 90       	ld	r0, Z+
    4598:	f0 81       	ld	r31, Z
    459a:	e0 2d       	mov	r30, r0
    459c:	94 81       	ldd	r25, Z+4	; 0x04
    459e:	69 2f       	mov	r22, r25
    45a0:	41 e0       	ldi	r20, 0x01	; 1
    45a2:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
    45a6:	fe 01       	movw	r30, r28
    45a8:	e1 5a       	subi	r30, 0xA1	; 161
    45aa:	ff 4f       	sbci	r31, 0xFF	; 255
    45ac:	80 e0       	ldi	r24, 0x00	; 0
    45ae:	90 e0       	ldi	r25, 0x00	; 0
    45b0:	a0 e0       	ldi	r26, 0x00	; 0
    45b2:	b0 e4       	ldi	r27, 0x40	; 64
    45b4:	80 83       	st	Z, r24
    45b6:	91 83       	std	Z+1, r25	; 0x01
    45b8:	a2 83       	std	Z+2, r26	; 0x02
    45ba:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    45bc:	8e 01       	movw	r16, r28
    45be:	05 5a       	subi	r16, 0xA5	; 165
    45c0:	1f 4f       	sbci	r17, 0xFF	; 255
    45c2:	fe 01       	movw	r30, r28
    45c4:	e1 5a       	subi	r30, 0xA1	; 161
    45c6:	ff 4f       	sbci	r31, 0xFF	; 255
    45c8:	60 81       	ld	r22, Z
    45ca:	71 81       	ldd	r23, Z+1	; 0x01
    45cc:	82 81       	ldd	r24, Z+2	; 0x02
    45ce:	93 81       	ldd	r25, Z+3	; 0x03
    45d0:	20 e0       	ldi	r18, 0x00	; 0
    45d2:	30 e0       	ldi	r19, 0x00	; 0
    45d4:	4a ef       	ldi	r20, 0xFA	; 250
    45d6:	54 e4       	ldi	r21, 0x44	; 68
    45d8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    45dc:	dc 01       	movw	r26, r24
    45de:	cb 01       	movw	r24, r22
    45e0:	f8 01       	movw	r30, r16
    45e2:	80 83       	st	Z, r24
    45e4:	91 83       	std	Z+1, r25	; 0x01
    45e6:	a2 83       	std	Z+2, r26	; 0x02
    45e8:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    45ea:	fe 01       	movw	r30, r28
    45ec:	e5 5a       	subi	r30, 0xA5	; 165
    45ee:	ff 4f       	sbci	r31, 0xFF	; 255
    45f0:	60 81       	ld	r22, Z
    45f2:	71 81       	ldd	r23, Z+1	; 0x01
    45f4:	82 81       	ldd	r24, Z+2	; 0x02
    45f6:	93 81       	ldd	r25, Z+3	; 0x03
    45f8:	20 e0       	ldi	r18, 0x00	; 0
    45fa:	30 e0       	ldi	r19, 0x00	; 0
    45fc:	40 e8       	ldi	r20, 0x80	; 128
    45fe:	5f e3       	ldi	r21, 0x3F	; 63
    4600:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    4604:	88 23       	and	r24, r24
    4606:	44 f4       	brge	.+16     	; 0x4618 <STEPPER_u8Rotate+0x1414>
		__ticks = 1;
    4608:	fe 01       	movw	r30, r28
    460a:	e7 5a       	subi	r30, 0xA7	; 167
    460c:	ff 4f       	sbci	r31, 0xFF	; 255
    460e:	81 e0       	ldi	r24, 0x01	; 1
    4610:	90 e0       	ldi	r25, 0x00	; 0
    4612:	91 83       	std	Z+1, r25	; 0x01
    4614:	80 83       	st	Z, r24
    4616:	64 c0       	rjmp	.+200    	; 0x46e0 <STEPPER_u8Rotate+0x14dc>
	else if (__tmp > 65535)
    4618:	fe 01       	movw	r30, r28
    461a:	e5 5a       	subi	r30, 0xA5	; 165
    461c:	ff 4f       	sbci	r31, 0xFF	; 255
    461e:	60 81       	ld	r22, Z
    4620:	71 81       	ldd	r23, Z+1	; 0x01
    4622:	82 81       	ldd	r24, Z+2	; 0x02
    4624:	93 81       	ldd	r25, Z+3	; 0x03
    4626:	20 e0       	ldi	r18, 0x00	; 0
    4628:	3f ef       	ldi	r19, 0xFF	; 255
    462a:	4f e7       	ldi	r20, 0x7F	; 127
    462c:	57 e4       	ldi	r21, 0x47	; 71
    462e:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    4632:	18 16       	cp	r1, r24
    4634:	0c f0       	brlt	.+2      	; 0x4638 <STEPPER_u8Rotate+0x1434>
    4636:	43 c0       	rjmp	.+134    	; 0x46be <STEPPER_u8Rotate+0x14ba>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4638:	fe 01       	movw	r30, r28
    463a:	e1 5a       	subi	r30, 0xA1	; 161
    463c:	ff 4f       	sbci	r31, 0xFF	; 255
    463e:	60 81       	ld	r22, Z
    4640:	71 81       	ldd	r23, Z+1	; 0x01
    4642:	82 81       	ldd	r24, Z+2	; 0x02
    4644:	93 81       	ldd	r25, Z+3	; 0x03
    4646:	20 e0       	ldi	r18, 0x00	; 0
    4648:	30 e0       	ldi	r19, 0x00	; 0
    464a:	40 e2       	ldi	r20, 0x20	; 32
    464c:	51 e4       	ldi	r21, 0x41	; 65
    464e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4652:	dc 01       	movw	r26, r24
    4654:	cb 01       	movw	r24, r22
    4656:	8e 01       	movw	r16, r28
    4658:	07 5a       	subi	r16, 0xA7	; 167
    465a:	1f 4f       	sbci	r17, 0xFF	; 255
    465c:	bc 01       	movw	r22, r24
    465e:	cd 01       	movw	r24, r26
    4660:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4664:	dc 01       	movw	r26, r24
    4666:	cb 01       	movw	r24, r22
    4668:	f8 01       	movw	r30, r16
    466a:	91 83       	std	Z+1, r25	; 0x01
    466c:	80 83       	st	Z, r24
    466e:	1f c0       	rjmp	.+62     	; 0x46ae <STEPPER_u8Rotate+0x14aa>
    4670:	fe 01       	movw	r30, r28
    4672:	e9 5a       	subi	r30, 0xA9	; 169
    4674:	ff 4f       	sbci	r31, 0xFF	; 255
    4676:	88 ec       	ldi	r24, 0xC8	; 200
    4678:	90 e0       	ldi	r25, 0x00	; 0
    467a:	91 83       	std	Z+1, r25	; 0x01
    467c:	80 83       	st	Z, r24
    467e:	fe 01       	movw	r30, r28
    4680:	e9 5a       	subi	r30, 0xA9	; 169
    4682:	ff 4f       	sbci	r31, 0xFF	; 255
    4684:	80 81       	ld	r24, Z
    4686:	91 81       	ldd	r25, Z+1	; 0x01
    4688:	01 97       	sbiw	r24, 0x01	; 1
    468a:	f1 f7       	brne	.-4      	; 0x4688 <STEPPER_u8Rotate+0x1484>
    468c:	fe 01       	movw	r30, r28
    468e:	e9 5a       	subi	r30, 0xA9	; 169
    4690:	ff 4f       	sbci	r31, 0xFF	; 255
    4692:	91 83       	std	Z+1, r25	; 0x01
    4694:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4696:	de 01       	movw	r26, r28
    4698:	a7 5a       	subi	r26, 0xA7	; 167
    469a:	bf 4f       	sbci	r27, 0xFF	; 255
    469c:	fe 01       	movw	r30, r28
    469e:	e7 5a       	subi	r30, 0xA7	; 167
    46a0:	ff 4f       	sbci	r31, 0xFF	; 255
    46a2:	80 81       	ld	r24, Z
    46a4:	91 81       	ldd	r25, Z+1	; 0x01
    46a6:	01 97       	sbiw	r24, 0x01	; 1
    46a8:	11 96       	adiw	r26, 0x01	; 1
    46aa:	9c 93       	st	X, r25
    46ac:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    46ae:	fe 01       	movw	r30, r28
    46b0:	e7 5a       	subi	r30, 0xA7	; 167
    46b2:	ff 4f       	sbci	r31, 0xFF	; 255
    46b4:	80 81       	ld	r24, Z
    46b6:	91 81       	ldd	r25, Z+1	; 0x01
    46b8:	00 97       	sbiw	r24, 0x00	; 0
    46ba:	d1 f6       	brne	.-76     	; 0x4670 <STEPPER_u8Rotate+0x146c>
    46bc:	27 c0       	rjmp	.+78     	; 0x470c <STEPPER_u8Rotate+0x1508>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    46be:	8e 01       	movw	r16, r28
    46c0:	07 5a       	subi	r16, 0xA7	; 167
    46c2:	1f 4f       	sbci	r17, 0xFF	; 255
    46c4:	fe 01       	movw	r30, r28
    46c6:	e5 5a       	subi	r30, 0xA5	; 165
    46c8:	ff 4f       	sbci	r31, 0xFF	; 255
    46ca:	60 81       	ld	r22, Z
    46cc:	71 81       	ldd	r23, Z+1	; 0x01
    46ce:	82 81       	ldd	r24, Z+2	; 0x02
    46d0:	93 81       	ldd	r25, Z+3	; 0x03
    46d2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    46d6:	dc 01       	movw	r26, r24
    46d8:	cb 01       	movw	r24, r22
    46da:	f8 01       	movw	r30, r16
    46dc:	91 83       	std	Z+1, r25	; 0x01
    46de:	80 83       	st	Z, r24
    46e0:	de 01       	movw	r26, r28
    46e2:	ab 5a       	subi	r26, 0xAB	; 171
    46e4:	bf 4f       	sbci	r27, 0xFF	; 255
    46e6:	fe 01       	movw	r30, r28
    46e8:	e7 5a       	subi	r30, 0xA7	; 167
    46ea:	ff 4f       	sbci	r31, 0xFF	; 255
    46ec:	80 81       	ld	r24, Z
    46ee:	91 81       	ldd	r25, Z+1	; 0x01
    46f0:	8d 93       	st	X+, r24
    46f2:	9c 93       	st	X, r25
    46f4:	fe 01       	movw	r30, r28
    46f6:	eb 5a       	subi	r30, 0xAB	; 171
    46f8:	ff 4f       	sbci	r31, 0xFF	; 255
    46fa:	80 81       	ld	r24, Z
    46fc:	91 81       	ldd	r25, Z+1	; 0x01
    46fe:	01 97       	sbiw	r24, 0x01	; 1
    4700:	f1 f7       	brne	.-4      	; 0x46fe <STEPPER_u8Rotate+0x14fa>
    4702:	fe 01       	movw	r30, r28
    4704:	eb 5a       	subi	r30, 0xAB	; 171
    4706:	ff 4f       	sbci	r31, 0xFF	; 255
    4708:	91 83       	std	Z+1, r25	; 0x01
    470a:	80 83       	st	Z, r24
				_delay_ms(2);
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN1,DIO_u8Pin_HIGH);
    470c:	fe 01       	movw	r30, r28
    470e:	e6 51       	subi	r30, 0x16	; 22
    4710:	ff 4f       	sbci	r31, 0xFF	; 255
    4712:	01 90       	ld	r0, Z+
    4714:	f0 81       	ld	r31, Z
    4716:	e0 2d       	mov	r30, r0
    4718:	80 81       	ld	r24, Z
    471a:	fe 01       	movw	r30, r28
    471c:	e6 51       	subi	r30, 0x16	; 22
    471e:	ff 4f       	sbci	r31, 0xFF	; 255
    4720:	01 90       	ld	r0, Z+
    4722:	f0 81       	ld	r31, Z
    4724:	e0 2d       	mov	r30, r0
    4726:	91 81       	ldd	r25, Z+1	; 0x01
    4728:	69 2f       	mov	r22, r25
    472a:	41 e0       	ldi	r20, 0x01	; 1
    472c:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN2,DIO_u8Pin_HIGH);
    4730:	fe 01       	movw	r30, r28
    4732:	e6 51       	subi	r30, 0x16	; 22
    4734:	ff 4f       	sbci	r31, 0xFF	; 255
    4736:	01 90       	ld	r0, Z+
    4738:	f0 81       	ld	r31, Z
    473a:	e0 2d       	mov	r30, r0
    473c:	80 81       	ld	r24, Z
    473e:	fe 01       	movw	r30, r28
    4740:	e6 51       	subi	r30, 0x16	; 22
    4742:	ff 4f       	sbci	r31, 0xFF	; 255
    4744:	01 90       	ld	r0, Z+
    4746:	f0 81       	ld	r31, Z
    4748:	e0 2d       	mov	r30, r0
    474a:	92 81       	ldd	r25, Z+2	; 0x02
    474c:	69 2f       	mov	r22, r25
    474e:	41 e0       	ldi	r20, 0x01	; 1
    4750:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN3,DIO_u8Pin_LOW);
    4754:	fe 01       	movw	r30, r28
    4756:	e6 51       	subi	r30, 0x16	; 22
    4758:	ff 4f       	sbci	r31, 0xFF	; 255
    475a:	01 90       	ld	r0, Z+
    475c:	f0 81       	ld	r31, Z
    475e:	e0 2d       	mov	r30, r0
    4760:	80 81       	ld	r24, Z
    4762:	fe 01       	movw	r30, r28
    4764:	e6 51       	subi	r30, 0x16	; 22
    4766:	ff 4f       	sbci	r31, 0xFF	; 255
    4768:	01 90       	ld	r0, Z+
    476a:	f0 81       	ld	r31, Z
    476c:	e0 2d       	mov	r30, r0
    476e:	93 81       	ldd	r25, Z+3	; 0x03
    4770:	69 2f       	mov	r22, r25
    4772:	40 e0       	ldi	r20, 0x00	; 0
    4774:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN4,DIO_u8Pin_HIGH);
    4778:	fe 01       	movw	r30, r28
    477a:	e6 51       	subi	r30, 0x16	; 22
    477c:	ff 4f       	sbci	r31, 0xFF	; 255
    477e:	01 90       	ld	r0, Z+
    4780:	f0 81       	ld	r31, Z
    4782:	e0 2d       	mov	r30, r0
    4784:	80 81       	ld	r24, Z
    4786:	fe 01       	movw	r30, r28
    4788:	e6 51       	subi	r30, 0x16	; 22
    478a:	ff 4f       	sbci	r31, 0xFF	; 255
    478c:	01 90       	ld	r0, Z+
    478e:	f0 81       	ld	r31, Z
    4790:	e0 2d       	mov	r30, r0
    4792:	94 81       	ldd	r25, Z+4	; 0x04
    4794:	69 2f       	mov	r22, r25
    4796:	41 e0       	ldi	r20, 0x01	; 1
    4798:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
    479c:	fe 01       	movw	r30, r28
    479e:	ef 5a       	subi	r30, 0xAF	; 175
    47a0:	ff 4f       	sbci	r31, 0xFF	; 255
    47a2:	80 e0       	ldi	r24, 0x00	; 0
    47a4:	90 e0       	ldi	r25, 0x00	; 0
    47a6:	a0 e0       	ldi	r26, 0x00	; 0
    47a8:	b0 e4       	ldi	r27, 0x40	; 64
    47aa:	80 83       	st	Z, r24
    47ac:	91 83       	std	Z+1, r25	; 0x01
    47ae:	a2 83       	std	Z+2, r26	; 0x02
    47b0:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    47b2:	8e 01       	movw	r16, r28
    47b4:	03 5b       	subi	r16, 0xB3	; 179
    47b6:	1f 4f       	sbci	r17, 0xFF	; 255
    47b8:	fe 01       	movw	r30, r28
    47ba:	ef 5a       	subi	r30, 0xAF	; 175
    47bc:	ff 4f       	sbci	r31, 0xFF	; 255
    47be:	60 81       	ld	r22, Z
    47c0:	71 81       	ldd	r23, Z+1	; 0x01
    47c2:	82 81       	ldd	r24, Z+2	; 0x02
    47c4:	93 81       	ldd	r25, Z+3	; 0x03
    47c6:	20 e0       	ldi	r18, 0x00	; 0
    47c8:	30 e0       	ldi	r19, 0x00	; 0
    47ca:	4a ef       	ldi	r20, 0xFA	; 250
    47cc:	54 e4       	ldi	r21, 0x44	; 68
    47ce:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    47d2:	dc 01       	movw	r26, r24
    47d4:	cb 01       	movw	r24, r22
    47d6:	f8 01       	movw	r30, r16
    47d8:	80 83       	st	Z, r24
    47da:	91 83       	std	Z+1, r25	; 0x01
    47dc:	a2 83       	std	Z+2, r26	; 0x02
    47de:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    47e0:	fe 01       	movw	r30, r28
    47e2:	e3 5b       	subi	r30, 0xB3	; 179
    47e4:	ff 4f       	sbci	r31, 0xFF	; 255
    47e6:	60 81       	ld	r22, Z
    47e8:	71 81       	ldd	r23, Z+1	; 0x01
    47ea:	82 81       	ldd	r24, Z+2	; 0x02
    47ec:	93 81       	ldd	r25, Z+3	; 0x03
    47ee:	20 e0       	ldi	r18, 0x00	; 0
    47f0:	30 e0       	ldi	r19, 0x00	; 0
    47f2:	40 e8       	ldi	r20, 0x80	; 128
    47f4:	5f e3       	ldi	r21, 0x3F	; 63
    47f6:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    47fa:	88 23       	and	r24, r24
    47fc:	44 f4       	brge	.+16     	; 0x480e <STEPPER_u8Rotate+0x160a>
		__ticks = 1;
    47fe:	fe 01       	movw	r30, r28
    4800:	e5 5b       	subi	r30, 0xB5	; 181
    4802:	ff 4f       	sbci	r31, 0xFF	; 255
    4804:	81 e0       	ldi	r24, 0x01	; 1
    4806:	90 e0       	ldi	r25, 0x00	; 0
    4808:	91 83       	std	Z+1, r25	; 0x01
    480a:	80 83       	st	Z, r24
    480c:	64 c0       	rjmp	.+200    	; 0x48d6 <STEPPER_u8Rotate+0x16d2>
	else if (__tmp > 65535)
    480e:	fe 01       	movw	r30, r28
    4810:	e3 5b       	subi	r30, 0xB3	; 179
    4812:	ff 4f       	sbci	r31, 0xFF	; 255
    4814:	60 81       	ld	r22, Z
    4816:	71 81       	ldd	r23, Z+1	; 0x01
    4818:	82 81       	ldd	r24, Z+2	; 0x02
    481a:	93 81       	ldd	r25, Z+3	; 0x03
    481c:	20 e0       	ldi	r18, 0x00	; 0
    481e:	3f ef       	ldi	r19, 0xFF	; 255
    4820:	4f e7       	ldi	r20, 0x7F	; 127
    4822:	57 e4       	ldi	r21, 0x47	; 71
    4824:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    4828:	18 16       	cp	r1, r24
    482a:	0c f0       	brlt	.+2      	; 0x482e <STEPPER_u8Rotate+0x162a>
    482c:	43 c0       	rjmp	.+134    	; 0x48b4 <STEPPER_u8Rotate+0x16b0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    482e:	fe 01       	movw	r30, r28
    4830:	ef 5a       	subi	r30, 0xAF	; 175
    4832:	ff 4f       	sbci	r31, 0xFF	; 255
    4834:	60 81       	ld	r22, Z
    4836:	71 81       	ldd	r23, Z+1	; 0x01
    4838:	82 81       	ldd	r24, Z+2	; 0x02
    483a:	93 81       	ldd	r25, Z+3	; 0x03
    483c:	20 e0       	ldi	r18, 0x00	; 0
    483e:	30 e0       	ldi	r19, 0x00	; 0
    4840:	40 e2       	ldi	r20, 0x20	; 32
    4842:	51 e4       	ldi	r21, 0x41	; 65
    4844:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4848:	dc 01       	movw	r26, r24
    484a:	cb 01       	movw	r24, r22
    484c:	8e 01       	movw	r16, r28
    484e:	05 5b       	subi	r16, 0xB5	; 181
    4850:	1f 4f       	sbci	r17, 0xFF	; 255
    4852:	bc 01       	movw	r22, r24
    4854:	cd 01       	movw	r24, r26
    4856:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    485a:	dc 01       	movw	r26, r24
    485c:	cb 01       	movw	r24, r22
    485e:	f8 01       	movw	r30, r16
    4860:	91 83       	std	Z+1, r25	; 0x01
    4862:	80 83       	st	Z, r24
    4864:	1f c0       	rjmp	.+62     	; 0x48a4 <STEPPER_u8Rotate+0x16a0>
    4866:	fe 01       	movw	r30, r28
    4868:	e7 5b       	subi	r30, 0xB7	; 183
    486a:	ff 4f       	sbci	r31, 0xFF	; 255
    486c:	88 ec       	ldi	r24, 0xC8	; 200
    486e:	90 e0       	ldi	r25, 0x00	; 0
    4870:	91 83       	std	Z+1, r25	; 0x01
    4872:	80 83       	st	Z, r24
    4874:	fe 01       	movw	r30, r28
    4876:	e7 5b       	subi	r30, 0xB7	; 183
    4878:	ff 4f       	sbci	r31, 0xFF	; 255
    487a:	80 81       	ld	r24, Z
    487c:	91 81       	ldd	r25, Z+1	; 0x01
    487e:	01 97       	sbiw	r24, 0x01	; 1
    4880:	f1 f7       	brne	.-4      	; 0x487e <STEPPER_u8Rotate+0x167a>
    4882:	fe 01       	movw	r30, r28
    4884:	e7 5b       	subi	r30, 0xB7	; 183
    4886:	ff 4f       	sbci	r31, 0xFF	; 255
    4888:	91 83       	std	Z+1, r25	; 0x01
    488a:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    488c:	de 01       	movw	r26, r28
    488e:	a5 5b       	subi	r26, 0xB5	; 181
    4890:	bf 4f       	sbci	r27, 0xFF	; 255
    4892:	fe 01       	movw	r30, r28
    4894:	e5 5b       	subi	r30, 0xB5	; 181
    4896:	ff 4f       	sbci	r31, 0xFF	; 255
    4898:	80 81       	ld	r24, Z
    489a:	91 81       	ldd	r25, Z+1	; 0x01
    489c:	01 97       	sbiw	r24, 0x01	; 1
    489e:	11 96       	adiw	r26, 0x01	; 1
    48a0:	9c 93       	st	X, r25
    48a2:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    48a4:	fe 01       	movw	r30, r28
    48a6:	e5 5b       	subi	r30, 0xB5	; 181
    48a8:	ff 4f       	sbci	r31, 0xFF	; 255
    48aa:	80 81       	ld	r24, Z
    48ac:	91 81       	ldd	r25, Z+1	; 0x01
    48ae:	00 97       	sbiw	r24, 0x00	; 0
    48b0:	d1 f6       	brne	.-76     	; 0x4866 <STEPPER_u8Rotate+0x1662>
    48b2:	27 c0       	rjmp	.+78     	; 0x4902 <STEPPER_u8Rotate+0x16fe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    48b4:	8e 01       	movw	r16, r28
    48b6:	05 5b       	subi	r16, 0xB5	; 181
    48b8:	1f 4f       	sbci	r17, 0xFF	; 255
    48ba:	fe 01       	movw	r30, r28
    48bc:	e3 5b       	subi	r30, 0xB3	; 179
    48be:	ff 4f       	sbci	r31, 0xFF	; 255
    48c0:	60 81       	ld	r22, Z
    48c2:	71 81       	ldd	r23, Z+1	; 0x01
    48c4:	82 81       	ldd	r24, Z+2	; 0x02
    48c6:	93 81       	ldd	r25, Z+3	; 0x03
    48c8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    48cc:	dc 01       	movw	r26, r24
    48ce:	cb 01       	movw	r24, r22
    48d0:	f8 01       	movw	r30, r16
    48d2:	91 83       	std	Z+1, r25	; 0x01
    48d4:	80 83       	st	Z, r24
    48d6:	de 01       	movw	r26, r28
    48d8:	a9 5b       	subi	r26, 0xB9	; 185
    48da:	bf 4f       	sbci	r27, 0xFF	; 255
    48dc:	fe 01       	movw	r30, r28
    48de:	e5 5b       	subi	r30, 0xB5	; 181
    48e0:	ff 4f       	sbci	r31, 0xFF	; 255
    48e2:	80 81       	ld	r24, Z
    48e4:	91 81       	ldd	r25, Z+1	; 0x01
    48e6:	8d 93       	st	X+, r24
    48e8:	9c 93       	st	X, r25
    48ea:	fe 01       	movw	r30, r28
    48ec:	e9 5b       	subi	r30, 0xB9	; 185
    48ee:	ff 4f       	sbci	r31, 0xFF	; 255
    48f0:	80 81       	ld	r24, Z
    48f2:	91 81       	ldd	r25, Z+1	; 0x01
    48f4:	01 97       	sbiw	r24, 0x01	; 1
    48f6:	f1 f7       	brne	.-4      	; 0x48f4 <STEPPER_u8Rotate+0x16f0>
    48f8:	fe 01       	movw	r30, r28
    48fa:	e9 5b       	subi	r30, 0xB9	; 185
    48fc:	ff 4f       	sbci	r31, 0xFF	; 255
    48fe:	91 83       	std	Z+1, r25	; 0x01
    4900:	80 83       	st	Z, r24
				_delay_ms(2);
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN1,DIO_u8Pin_HIGH);
    4902:	fe 01       	movw	r30, r28
    4904:	e6 51       	subi	r30, 0x16	; 22
    4906:	ff 4f       	sbci	r31, 0xFF	; 255
    4908:	01 90       	ld	r0, Z+
    490a:	f0 81       	ld	r31, Z
    490c:	e0 2d       	mov	r30, r0
    490e:	80 81       	ld	r24, Z
    4910:	fe 01       	movw	r30, r28
    4912:	e6 51       	subi	r30, 0x16	; 22
    4914:	ff 4f       	sbci	r31, 0xFF	; 255
    4916:	01 90       	ld	r0, Z+
    4918:	f0 81       	ld	r31, Z
    491a:	e0 2d       	mov	r30, r0
    491c:	91 81       	ldd	r25, Z+1	; 0x01
    491e:	69 2f       	mov	r22, r25
    4920:	41 e0       	ldi	r20, 0x01	; 1
    4922:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN2,DIO_u8Pin_HIGH);
    4926:	fe 01       	movw	r30, r28
    4928:	e6 51       	subi	r30, 0x16	; 22
    492a:	ff 4f       	sbci	r31, 0xFF	; 255
    492c:	01 90       	ld	r0, Z+
    492e:	f0 81       	ld	r31, Z
    4930:	e0 2d       	mov	r30, r0
    4932:	80 81       	ld	r24, Z
    4934:	fe 01       	movw	r30, r28
    4936:	e6 51       	subi	r30, 0x16	; 22
    4938:	ff 4f       	sbci	r31, 0xFF	; 255
    493a:	01 90       	ld	r0, Z+
    493c:	f0 81       	ld	r31, Z
    493e:	e0 2d       	mov	r30, r0
    4940:	92 81       	ldd	r25, Z+2	; 0x02
    4942:	69 2f       	mov	r22, r25
    4944:	41 e0       	ldi	r20, 0x01	; 1
    4946:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN3,DIO_u8Pin_HIGH);
    494a:	fe 01       	movw	r30, r28
    494c:	e6 51       	subi	r30, 0x16	; 22
    494e:	ff 4f       	sbci	r31, 0xFF	; 255
    4950:	01 90       	ld	r0, Z+
    4952:	f0 81       	ld	r31, Z
    4954:	e0 2d       	mov	r30, r0
    4956:	80 81       	ld	r24, Z
    4958:	fe 01       	movw	r30, r28
    495a:	e6 51       	subi	r30, 0x16	; 22
    495c:	ff 4f       	sbci	r31, 0xFF	; 255
    495e:	01 90       	ld	r0, Z+
    4960:	f0 81       	ld	r31, Z
    4962:	e0 2d       	mov	r30, r0
    4964:	93 81       	ldd	r25, Z+3	; 0x03
    4966:	69 2f       	mov	r22, r25
    4968:	41 e0       	ldi	r20, 0x01	; 1
    496a:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN4,DIO_u8Pin_LOW);
    496e:	fe 01       	movw	r30, r28
    4970:	e6 51       	subi	r30, 0x16	; 22
    4972:	ff 4f       	sbci	r31, 0xFF	; 255
    4974:	01 90       	ld	r0, Z+
    4976:	f0 81       	ld	r31, Z
    4978:	e0 2d       	mov	r30, r0
    497a:	80 81       	ld	r24, Z
    497c:	fe 01       	movw	r30, r28
    497e:	e6 51       	subi	r30, 0x16	; 22
    4980:	ff 4f       	sbci	r31, 0xFF	; 255
    4982:	01 90       	ld	r0, Z+
    4984:	f0 81       	ld	r31, Z
    4986:	e0 2d       	mov	r30, r0
    4988:	94 81       	ldd	r25, Z+4	; 0x04
    498a:	69 2f       	mov	r22, r25
    498c:	40 e0       	ldi	r20, 0x00	; 0
    498e:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
    4992:	fe 01       	movw	r30, r28
    4994:	ed 5b       	subi	r30, 0xBD	; 189
    4996:	ff 4f       	sbci	r31, 0xFF	; 255
    4998:	80 e0       	ldi	r24, 0x00	; 0
    499a:	90 e0       	ldi	r25, 0x00	; 0
    499c:	a0 e0       	ldi	r26, 0x00	; 0
    499e:	b0 e4       	ldi	r27, 0x40	; 64
    49a0:	80 83       	st	Z, r24
    49a2:	91 83       	std	Z+1, r25	; 0x01
    49a4:	a2 83       	std	Z+2, r26	; 0x02
    49a6:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    49a8:	8e 01       	movw	r16, r28
    49aa:	01 5c       	subi	r16, 0xC1	; 193
    49ac:	1f 4f       	sbci	r17, 0xFF	; 255
    49ae:	fe 01       	movw	r30, r28
    49b0:	ed 5b       	subi	r30, 0xBD	; 189
    49b2:	ff 4f       	sbci	r31, 0xFF	; 255
    49b4:	60 81       	ld	r22, Z
    49b6:	71 81       	ldd	r23, Z+1	; 0x01
    49b8:	82 81       	ldd	r24, Z+2	; 0x02
    49ba:	93 81       	ldd	r25, Z+3	; 0x03
    49bc:	20 e0       	ldi	r18, 0x00	; 0
    49be:	30 e0       	ldi	r19, 0x00	; 0
    49c0:	4a ef       	ldi	r20, 0xFA	; 250
    49c2:	54 e4       	ldi	r21, 0x44	; 68
    49c4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    49c8:	dc 01       	movw	r26, r24
    49ca:	cb 01       	movw	r24, r22
    49cc:	f8 01       	movw	r30, r16
    49ce:	80 83       	st	Z, r24
    49d0:	91 83       	std	Z+1, r25	; 0x01
    49d2:	a2 83       	std	Z+2, r26	; 0x02
    49d4:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    49d6:	fe 01       	movw	r30, r28
    49d8:	ff 96       	adiw	r30, 0x3f	; 63
    49da:	60 81       	ld	r22, Z
    49dc:	71 81       	ldd	r23, Z+1	; 0x01
    49de:	82 81       	ldd	r24, Z+2	; 0x02
    49e0:	93 81       	ldd	r25, Z+3	; 0x03
    49e2:	20 e0       	ldi	r18, 0x00	; 0
    49e4:	30 e0       	ldi	r19, 0x00	; 0
    49e6:	40 e8       	ldi	r20, 0x80	; 128
    49e8:	5f e3       	ldi	r21, 0x3F	; 63
    49ea:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    49ee:	88 23       	and	r24, r24
    49f0:	2c f4       	brge	.+10     	; 0x49fc <STEPPER_u8Rotate+0x17f8>
		__ticks = 1;
    49f2:	81 e0       	ldi	r24, 0x01	; 1
    49f4:	90 e0       	ldi	r25, 0x00	; 0
    49f6:	9e af       	std	Y+62, r25	; 0x3e
    49f8:	8d af       	std	Y+61, r24	; 0x3d
    49fa:	46 c0       	rjmp	.+140    	; 0x4a88 <STEPPER_u8Rotate+0x1884>
	else if (__tmp > 65535)
    49fc:	fe 01       	movw	r30, r28
    49fe:	ff 96       	adiw	r30, 0x3f	; 63
    4a00:	60 81       	ld	r22, Z
    4a02:	71 81       	ldd	r23, Z+1	; 0x01
    4a04:	82 81       	ldd	r24, Z+2	; 0x02
    4a06:	93 81       	ldd	r25, Z+3	; 0x03
    4a08:	20 e0       	ldi	r18, 0x00	; 0
    4a0a:	3f ef       	ldi	r19, 0xFF	; 255
    4a0c:	4f e7       	ldi	r20, 0x7F	; 127
    4a0e:	57 e4       	ldi	r21, 0x47	; 71
    4a10:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    4a14:	18 16       	cp	r1, r24
    4a16:	64 f5       	brge	.+88     	; 0x4a70 <STEPPER_u8Rotate+0x186c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4a18:	fe 01       	movw	r30, r28
    4a1a:	ed 5b       	subi	r30, 0xBD	; 189
    4a1c:	ff 4f       	sbci	r31, 0xFF	; 255
    4a1e:	60 81       	ld	r22, Z
    4a20:	71 81       	ldd	r23, Z+1	; 0x01
    4a22:	82 81       	ldd	r24, Z+2	; 0x02
    4a24:	93 81       	ldd	r25, Z+3	; 0x03
    4a26:	20 e0       	ldi	r18, 0x00	; 0
    4a28:	30 e0       	ldi	r19, 0x00	; 0
    4a2a:	40 e2       	ldi	r20, 0x20	; 32
    4a2c:	51 e4       	ldi	r21, 0x41	; 65
    4a2e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4a32:	dc 01       	movw	r26, r24
    4a34:	cb 01       	movw	r24, r22
    4a36:	bc 01       	movw	r22, r24
    4a38:	cd 01       	movw	r24, r26
    4a3a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4a3e:	dc 01       	movw	r26, r24
    4a40:	cb 01       	movw	r24, r22
    4a42:	9e af       	std	Y+62, r25	; 0x3e
    4a44:	8d af       	std	Y+61, r24	; 0x3d
    4a46:	0f c0       	rjmp	.+30     	; 0x4a66 <STEPPER_u8Rotate+0x1862>
    4a48:	88 ec       	ldi	r24, 0xC8	; 200
    4a4a:	90 e0       	ldi	r25, 0x00	; 0
    4a4c:	9c af       	std	Y+60, r25	; 0x3c
    4a4e:	8b af       	std	Y+59, r24	; 0x3b
    4a50:	8b ad       	ldd	r24, Y+59	; 0x3b
    4a52:	9c ad       	ldd	r25, Y+60	; 0x3c
    4a54:	01 97       	sbiw	r24, 0x01	; 1
    4a56:	f1 f7       	brne	.-4      	; 0x4a54 <STEPPER_u8Rotate+0x1850>
    4a58:	9c af       	std	Y+60, r25	; 0x3c
    4a5a:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4a5c:	8d ad       	ldd	r24, Y+61	; 0x3d
    4a5e:	9e ad       	ldd	r25, Y+62	; 0x3e
    4a60:	01 97       	sbiw	r24, 0x01	; 1
    4a62:	9e af       	std	Y+62, r25	; 0x3e
    4a64:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4a66:	8d ad       	ldd	r24, Y+61	; 0x3d
    4a68:	9e ad       	ldd	r25, Y+62	; 0x3e
    4a6a:	00 97       	sbiw	r24, 0x00	; 0
    4a6c:	69 f7       	brne	.-38     	; 0x4a48 <STEPPER_u8Rotate+0x1844>
    4a6e:	16 c0       	rjmp	.+44     	; 0x4a9c <STEPPER_u8Rotate+0x1898>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4a70:	fe 01       	movw	r30, r28
    4a72:	ff 96       	adiw	r30, 0x3f	; 63
    4a74:	60 81       	ld	r22, Z
    4a76:	71 81       	ldd	r23, Z+1	; 0x01
    4a78:	82 81       	ldd	r24, Z+2	; 0x02
    4a7a:	93 81       	ldd	r25, Z+3	; 0x03
    4a7c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4a80:	dc 01       	movw	r26, r24
    4a82:	cb 01       	movw	r24, r22
    4a84:	9e af       	std	Y+62, r25	; 0x3e
    4a86:	8d af       	std	Y+61, r24	; 0x3d
    4a88:	8d ad       	ldd	r24, Y+61	; 0x3d
    4a8a:	9e ad       	ldd	r25, Y+62	; 0x3e
    4a8c:	9a af       	std	Y+58, r25	; 0x3a
    4a8e:	89 af       	std	Y+57, r24	; 0x39
    4a90:	89 ad       	ldd	r24, Y+57	; 0x39
    4a92:	9a ad       	ldd	r25, Y+58	; 0x3a
    4a94:	01 97       	sbiw	r24, 0x01	; 1
    4a96:	f1 f7       	brne	.-4      	; 0x4a94 <STEPPER_u8Rotate+0x1890>
    4a98:	9a af       	std	Y+58, r25	; 0x3a
    4a9a:	89 af       	std	Y+57, r24	; 0x39
		else
		{
			Local_u32IterationsNum=(Copy_u16Angle*10)/7;
			switch(Copy_u8Direction)
			{
			case CCW: for(Local_u32Counter=0;Local_u32Counter<Local_u32IterationsNum;Local_u32Counter++)
    4a9c:	9e 01       	movw	r18, r28
    4a9e:	2f 51       	subi	r18, 0x1F	; 31
    4aa0:	3f 4f       	sbci	r19, 0xFF	; 255
    4aa2:	fe 01       	movw	r30, r28
    4aa4:	ef 51       	subi	r30, 0x1F	; 31
    4aa6:	ff 4f       	sbci	r31, 0xFF	; 255
    4aa8:	80 81       	ld	r24, Z
    4aaa:	91 81       	ldd	r25, Z+1	; 0x01
    4aac:	a2 81       	ldd	r26, Z+2	; 0x02
    4aae:	b3 81       	ldd	r27, Z+3	; 0x03
    4ab0:	01 96       	adiw	r24, 0x01	; 1
    4ab2:	a1 1d       	adc	r26, r1
    4ab4:	b1 1d       	adc	r27, r1
    4ab6:	f9 01       	movw	r30, r18
    4ab8:	80 83       	st	Z, r24
    4aba:	91 83       	std	Z+1, r25	; 0x01
    4abc:	a2 83       	std	Z+2, r26	; 0x02
    4abe:	b3 83       	std	Z+3, r27	; 0x03
    4ac0:	fe 01       	movw	r30, r28
    4ac2:	ef 51       	subi	r30, 0x1F	; 31
    4ac4:	ff 4f       	sbci	r31, 0xFF	; 255
    4ac6:	de 01       	movw	r26, r28
    4ac8:	ab 51       	subi	r26, 0x1B	; 27
    4aca:	bf 4f       	sbci	r27, 0xFF	; 255
    4acc:	20 81       	ld	r18, Z
    4ace:	31 81       	ldd	r19, Z+1	; 0x01
    4ad0:	42 81       	ldd	r20, Z+2	; 0x02
    4ad2:	53 81       	ldd	r21, Z+3	; 0x03
    4ad4:	8d 91       	ld	r24, X+
    4ad6:	9d 91       	ld	r25, X+
    4ad8:	0d 90       	ld	r0, X+
    4ada:	bc 91       	ld	r27, X
    4adc:	a0 2d       	mov	r26, r0
    4ade:	28 17       	cp	r18, r24
    4ae0:	39 07       	cpc	r19, r25
    4ae2:	4a 07       	cpc	r20, r26
    4ae4:	5b 07       	cpc	r21, r27
    4ae6:	08 f4       	brcc	.+2      	; 0x4aea <STEPPER_u8Rotate+0x18e6>
    4ae8:	1b cc       	rjmp	.-1994   	; 0x4320 <STEPPER_u8Rotate+0x111c>
    4aea:	1d c3       	rjmp	.+1594   	; 0x5126 <STEPPER_u8Rotate+0x1f22>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN2,DIO_u8Pin_HIGH);
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN3,DIO_u8Pin_HIGH);
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN4,DIO_u8Pin_LOW);
				_delay_ms(2);
			} break;
			case CW: for(Local_u32Counter=0;Local_u32Counter<Local_u32IterationsNum;Local_u32Counter++)
    4aec:	fe 01       	movw	r30, r28
    4aee:	ef 51       	subi	r30, 0x1F	; 31
    4af0:	ff 4f       	sbci	r31, 0xFF	; 255
    4af2:	10 82       	st	Z, r1
    4af4:	11 82       	std	Z+1, r1	; 0x01
    4af6:	12 82       	std	Z+2, r1	; 0x02
    4af8:	13 82       	std	Z+3, r1	; 0x03
    4afa:	fa c2       	rjmp	.+1524   	; 0x50f0 <STEPPER_u8Rotate+0x1eec>
			{
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN4,DIO_u8Pin_LOW);
    4afc:	fe 01       	movw	r30, r28
    4afe:	e6 51       	subi	r30, 0x16	; 22
    4b00:	ff 4f       	sbci	r31, 0xFF	; 255
    4b02:	01 90       	ld	r0, Z+
    4b04:	f0 81       	ld	r31, Z
    4b06:	e0 2d       	mov	r30, r0
    4b08:	80 81       	ld	r24, Z
    4b0a:	fe 01       	movw	r30, r28
    4b0c:	e6 51       	subi	r30, 0x16	; 22
    4b0e:	ff 4f       	sbci	r31, 0xFF	; 255
    4b10:	01 90       	ld	r0, Z+
    4b12:	f0 81       	ld	r31, Z
    4b14:	e0 2d       	mov	r30, r0
    4b16:	94 81       	ldd	r25, Z+4	; 0x04
    4b18:	69 2f       	mov	r22, r25
    4b1a:	40 e0       	ldi	r20, 0x00	; 0
    4b1c:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN3,DIO_u8Pin_HIGH);
    4b20:	fe 01       	movw	r30, r28
    4b22:	e6 51       	subi	r30, 0x16	; 22
    4b24:	ff 4f       	sbci	r31, 0xFF	; 255
    4b26:	01 90       	ld	r0, Z+
    4b28:	f0 81       	ld	r31, Z
    4b2a:	e0 2d       	mov	r30, r0
    4b2c:	80 81       	ld	r24, Z
    4b2e:	fe 01       	movw	r30, r28
    4b30:	e6 51       	subi	r30, 0x16	; 22
    4b32:	ff 4f       	sbci	r31, 0xFF	; 255
    4b34:	01 90       	ld	r0, Z+
    4b36:	f0 81       	ld	r31, Z
    4b38:	e0 2d       	mov	r30, r0
    4b3a:	93 81       	ldd	r25, Z+3	; 0x03
    4b3c:	69 2f       	mov	r22, r25
    4b3e:	41 e0       	ldi	r20, 0x01	; 1
    4b40:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN2,DIO_u8Pin_HIGH);
    4b44:	fe 01       	movw	r30, r28
    4b46:	e6 51       	subi	r30, 0x16	; 22
    4b48:	ff 4f       	sbci	r31, 0xFF	; 255
    4b4a:	01 90       	ld	r0, Z+
    4b4c:	f0 81       	ld	r31, Z
    4b4e:	e0 2d       	mov	r30, r0
    4b50:	80 81       	ld	r24, Z
    4b52:	fe 01       	movw	r30, r28
    4b54:	e6 51       	subi	r30, 0x16	; 22
    4b56:	ff 4f       	sbci	r31, 0xFF	; 255
    4b58:	01 90       	ld	r0, Z+
    4b5a:	f0 81       	ld	r31, Z
    4b5c:	e0 2d       	mov	r30, r0
    4b5e:	92 81       	ldd	r25, Z+2	; 0x02
    4b60:	69 2f       	mov	r22, r25
    4b62:	41 e0       	ldi	r20, 0x01	; 1
    4b64:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN1,DIO_u8Pin_HIGH);
    4b68:	fe 01       	movw	r30, r28
    4b6a:	e6 51       	subi	r30, 0x16	; 22
    4b6c:	ff 4f       	sbci	r31, 0xFF	; 255
    4b6e:	01 90       	ld	r0, Z+
    4b70:	f0 81       	ld	r31, Z
    4b72:	e0 2d       	mov	r30, r0
    4b74:	80 81       	ld	r24, Z
    4b76:	fe 01       	movw	r30, r28
    4b78:	e6 51       	subi	r30, 0x16	; 22
    4b7a:	ff 4f       	sbci	r31, 0xFF	; 255
    4b7c:	01 90       	ld	r0, Z+
    4b7e:	f0 81       	ld	r31, Z
    4b80:	e0 2d       	mov	r30, r0
    4b82:	91 81       	ldd	r25, Z+1	; 0x01
    4b84:	69 2f       	mov	r22, r25
    4b86:	41 e0       	ldi	r20, 0x01	; 1
    4b88:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
    4b8c:	80 e0       	ldi	r24, 0x00	; 0
    4b8e:	90 e0       	ldi	r25, 0x00	; 0
    4b90:	a0 e0       	ldi	r26, 0x00	; 0
    4b92:	b0 e4       	ldi	r27, 0x40	; 64
    4b94:	8d ab       	std	Y+53, r24	; 0x35
    4b96:	9e ab       	std	Y+54, r25	; 0x36
    4b98:	af ab       	std	Y+55, r26	; 0x37
    4b9a:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4b9c:	6d a9       	ldd	r22, Y+53	; 0x35
    4b9e:	7e a9       	ldd	r23, Y+54	; 0x36
    4ba0:	8f a9       	ldd	r24, Y+55	; 0x37
    4ba2:	98 ad       	ldd	r25, Y+56	; 0x38
    4ba4:	20 e0       	ldi	r18, 0x00	; 0
    4ba6:	30 e0       	ldi	r19, 0x00	; 0
    4ba8:	4a ef       	ldi	r20, 0xFA	; 250
    4baa:	54 e4       	ldi	r21, 0x44	; 68
    4bac:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4bb0:	dc 01       	movw	r26, r24
    4bb2:	cb 01       	movw	r24, r22
    4bb4:	89 ab       	std	Y+49, r24	; 0x31
    4bb6:	9a ab       	std	Y+50, r25	; 0x32
    4bb8:	ab ab       	std	Y+51, r26	; 0x33
    4bba:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    4bbc:	69 a9       	ldd	r22, Y+49	; 0x31
    4bbe:	7a a9       	ldd	r23, Y+50	; 0x32
    4bc0:	8b a9       	ldd	r24, Y+51	; 0x33
    4bc2:	9c a9       	ldd	r25, Y+52	; 0x34
    4bc4:	20 e0       	ldi	r18, 0x00	; 0
    4bc6:	30 e0       	ldi	r19, 0x00	; 0
    4bc8:	40 e8       	ldi	r20, 0x80	; 128
    4bca:	5f e3       	ldi	r21, 0x3F	; 63
    4bcc:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    4bd0:	88 23       	and	r24, r24
    4bd2:	2c f4       	brge	.+10     	; 0x4bde <STEPPER_u8Rotate+0x19da>
		__ticks = 1;
    4bd4:	81 e0       	ldi	r24, 0x01	; 1
    4bd6:	90 e0       	ldi	r25, 0x00	; 0
    4bd8:	98 ab       	std	Y+48, r25	; 0x30
    4bda:	8f a7       	std	Y+47, r24	; 0x2f
    4bdc:	3f c0       	rjmp	.+126    	; 0x4c5c <STEPPER_u8Rotate+0x1a58>
	else if (__tmp > 65535)
    4bde:	69 a9       	ldd	r22, Y+49	; 0x31
    4be0:	7a a9       	ldd	r23, Y+50	; 0x32
    4be2:	8b a9       	ldd	r24, Y+51	; 0x33
    4be4:	9c a9       	ldd	r25, Y+52	; 0x34
    4be6:	20 e0       	ldi	r18, 0x00	; 0
    4be8:	3f ef       	ldi	r19, 0xFF	; 255
    4bea:	4f e7       	ldi	r20, 0x7F	; 127
    4bec:	57 e4       	ldi	r21, 0x47	; 71
    4bee:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    4bf2:	18 16       	cp	r1, r24
    4bf4:	4c f5       	brge	.+82     	; 0x4c48 <STEPPER_u8Rotate+0x1a44>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4bf6:	6d a9       	ldd	r22, Y+53	; 0x35
    4bf8:	7e a9       	ldd	r23, Y+54	; 0x36
    4bfa:	8f a9       	ldd	r24, Y+55	; 0x37
    4bfc:	98 ad       	ldd	r25, Y+56	; 0x38
    4bfe:	20 e0       	ldi	r18, 0x00	; 0
    4c00:	30 e0       	ldi	r19, 0x00	; 0
    4c02:	40 e2       	ldi	r20, 0x20	; 32
    4c04:	51 e4       	ldi	r21, 0x41	; 65
    4c06:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4c0a:	dc 01       	movw	r26, r24
    4c0c:	cb 01       	movw	r24, r22
    4c0e:	bc 01       	movw	r22, r24
    4c10:	cd 01       	movw	r24, r26
    4c12:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4c16:	dc 01       	movw	r26, r24
    4c18:	cb 01       	movw	r24, r22
    4c1a:	98 ab       	std	Y+48, r25	; 0x30
    4c1c:	8f a7       	std	Y+47, r24	; 0x2f
    4c1e:	0f c0       	rjmp	.+30     	; 0x4c3e <STEPPER_u8Rotate+0x1a3a>
    4c20:	88 ec       	ldi	r24, 0xC8	; 200
    4c22:	90 e0       	ldi	r25, 0x00	; 0
    4c24:	9e a7       	std	Y+46, r25	; 0x2e
    4c26:	8d a7       	std	Y+45, r24	; 0x2d
    4c28:	8d a5       	ldd	r24, Y+45	; 0x2d
    4c2a:	9e a5       	ldd	r25, Y+46	; 0x2e
    4c2c:	01 97       	sbiw	r24, 0x01	; 1
    4c2e:	f1 f7       	brne	.-4      	; 0x4c2c <STEPPER_u8Rotate+0x1a28>
    4c30:	9e a7       	std	Y+46, r25	; 0x2e
    4c32:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4c34:	8f a5       	ldd	r24, Y+47	; 0x2f
    4c36:	98 a9       	ldd	r25, Y+48	; 0x30
    4c38:	01 97       	sbiw	r24, 0x01	; 1
    4c3a:	98 ab       	std	Y+48, r25	; 0x30
    4c3c:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4c3e:	8f a5       	ldd	r24, Y+47	; 0x2f
    4c40:	98 a9       	ldd	r25, Y+48	; 0x30
    4c42:	00 97       	sbiw	r24, 0x00	; 0
    4c44:	69 f7       	brne	.-38     	; 0x4c20 <STEPPER_u8Rotate+0x1a1c>
    4c46:	14 c0       	rjmp	.+40     	; 0x4c70 <STEPPER_u8Rotate+0x1a6c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4c48:	69 a9       	ldd	r22, Y+49	; 0x31
    4c4a:	7a a9       	ldd	r23, Y+50	; 0x32
    4c4c:	8b a9       	ldd	r24, Y+51	; 0x33
    4c4e:	9c a9       	ldd	r25, Y+52	; 0x34
    4c50:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4c54:	dc 01       	movw	r26, r24
    4c56:	cb 01       	movw	r24, r22
    4c58:	98 ab       	std	Y+48, r25	; 0x30
    4c5a:	8f a7       	std	Y+47, r24	; 0x2f
    4c5c:	8f a5       	ldd	r24, Y+47	; 0x2f
    4c5e:	98 a9       	ldd	r25, Y+48	; 0x30
    4c60:	9c a7       	std	Y+44, r25	; 0x2c
    4c62:	8b a7       	std	Y+43, r24	; 0x2b
    4c64:	8b a5       	ldd	r24, Y+43	; 0x2b
    4c66:	9c a5       	ldd	r25, Y+44	; 0x2c
    4c68:	01 97       	sbiw	r24, 0x01	; 1
    4c6a:	f1 f7       	brne	.-4      	; 0x4c68 <STEPPER_u8Rotate+0x1a64>
    4c6c:	9c a7       	std	Y+44, r25	; 0x2c
    4c6e:	8b a7       	std	Y+43, r24	; 0x2b
				_delay_ms(2);
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN4,DIO_u8Pin_HIGH);
    4c70:	fe 01       	movw	r30, r28
    4c72:	e6 51       	subi	r30, 0x16	; 22
    4c74:	ff 4f       	sbci	r31, 0xFF	; 255
    4c76:	01 90       	ld	r0, Z+
    4c78:	f0 81       	ld	r31, Z
    4c7a:	e0 2d       	mov	r30, r0
    4c7c:	80 81       	ld	r24, Z
    4c7e:	fe 01       	movw	r30, r28
    4c80:	e6 51       	subi	r30, 0x16	; 22
    4c82:	ff 4f       	sbci	r31, 0xFF	; 255
    4c84:	01 90       	ld	r0, Z+
    4c86:	f0 81       	ld	r31, Z
    4c88:	e0 2d       	mov	r30, r0
    4c8a:	94 81       	ldd	r25, Z+4	; 0x04
    4c8c:	69 2f       	mov	r22, r25
    4c8e:	41 e0       	ldi	r20, 0x01	; 1
    4c90:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN3,DIO_u8Pin_LOW);
    4c94:	fe 01       	movw	r30, r28
    4c96:	e6 51       	subi	r30, 0x16	; 22
    4c98:	ff 4f       	sbci	r31, 0xFF	; 255
    4c9a:	01 90       	ld	r0, Z+
    4c9c:	f0 81       	ld	r31, Z
    4c9e:	e0 2d       	mov	r30, r0
    4ca0:	80 81       	ld	r24, Z
    4ca2:	fe 01       	movw	r30, r28
    4ca4:	e6 51       	subi	r30, 0x16	; 22
    4ca6:	ff 4f       	sbci	r31, 0xFF	; 255
    4ca8:	01 90       	ld	r0, Z+
    4caa:	f0 81       	ld	r31, Z
    4cac:	e0 2d       	mov	r30, r0
    4cae:	93 81       	ldd	r25, Z+3	; 0x03
    4cb0:	69 2f       	mov	r22, r25
    4cb2:	40 e0       	ldi	r20, 0x00	; 0
    4cb4:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN2,DIO_u8Pin_HIGH);
    4cb8:	fe 01       	movw	r30, r28
    4cba:	e6 51       	subi	r30, 0x16	; 22
    4cbc:	ff 4f       	sbci	r31, 0xFF	; 255
    4cbe:	01 90       	ld	r0, Z+
    4cc0:	f0 81       	ld	r31, Z
    4cc2:	e0 2d       	mov	r30, r0
    4cc4:	80 81       	ld	r24, Z
    4cc6:	fe 01       	movw	r30, r28
    4cc8:	e6 51       	subi	r30, 0x16	; 22
    4cca:	ff 4f       	sbci	r31, 0xFF	; 255
    4ccc:	01 90       	ld	r0, Z+
    4cce:	f0 81       	ld	r31, Z
    4cd0:	e0 2d       	mov	r30, r0
    4cd2:	92 81       	ldd	r25, Z+2	; 0x02
    4cd4:	69 2f       	mov	r22, r25
    4cd6:	41 e0       	ldi	r20, 0x01	; 1
    4cd8:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN1,DIO_u8Pin_HIGH);
    4cdc:	fe 01       	movw	r30, r28
    4cde:	e6 51       	subi	r30, 0x16	; 22
    4ce0:	ff 4f       	sbci	r31, 0xFF	; 255
    4ce2:	01 90       	ld	r0, Z+
    4ce4:	f0 81       	ld	r31, Z
    4ce6:	e0 2d       	mov	r30, r0
    4ce8:	80 81       	ld	r24, Z
    4cea:	fe 01       	movw	r30, r28
    4cec:	e6 51       	subi	r30, 0x16	; 22
    4cee:	ff 4f       	sbci	r31, 0xFF	; 255
    4cf0:	01 90       	ld	r0, Z+
    4cf2:	f0 81       	ld	r31, Z
    4cf4:	e0 2d       	mov	r30, r0
    4cf6:	91 81       	ldd	r25, Z+1	; 0x01
    4cf8:	69 2f       	mov	r22, r25
    4cfa:	41 e0       	ldi	r20, 0x01	; 1
    4cfc:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
    4d00:	80 e0       	ldi	r24, 0x00	; 0
    4d02:	90 e0       	ldi	r25, 0x00	; 0
    4d04:	a0 e0       	ldi	r26, 0x00	; 0
    4d06:	b0 e4       	ldi	r27, 0x40	; 64
    4d08:	8f a3       	std	Y+39, r24	; 0x27
    4d0a:	98 a7       	std	Y+40, r25	; 0x28
    4d0c:	a9 a7       	std	Y+41, r26	; 0x29
    4d0e:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4d10:	6f a1       	ldd	r22, Y+39	; 0x27
    4d12:	78 a5       	ldd	r23, Y+40	; 0x28
    4d14:	89 a5       	ldd	r24, Y+41	; 0x29
    4d16:	9a a5       	ldd	r25, Y+42	; 0x2a
    4d18:	20 e0       	ldi	r18, 0x00	; 0
    4d1a:	30 e0       	ldi	r19, 0x00	; 0
    4d1c:	4a ef       	ldi	r20, 0xFA	; 250
    4d1e:	54 e4       	ldi	r21, 0x44	; 68
    4d20:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4d24:	dc 01       	movw	r26, r24
    4d26:	cb 01       	movw	r24, r22
    4d28:	8b a3       	std	Y+35, r24	; 0x23
    4d2a:	9c a3       	std	Y+36, r25	; 0x24
    4d2c:	ad a3       	std	Y+37, r26	; 0x25
    4d2e:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    4d30:	6b a1       	ldd	r22, Y+35	; 0x23
    4d32:	7c a1       	ldd	r23, Y+36	; 0x24
    4d34:	8d a1       	ldd	r24, Y+37	; 0x25
    4d36:	9e a1       	ldd	r25, Y+38	; 0x26
    4d38:	20 e0       	ldi	r18, 0x00	; 0
    4d3a:	30 e0       	ldi	r19, 0x00	; 0
    4d3c:	40 e8       	ldi	r20, 0x80	; 128
    4d3e:	5f e3       	ldi	r21, 0x3F	; 63
    4d40:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    4d44:	88 23       	and	r24, r24
    4d46:	2c f4       	brge	.+10     	; 0x4d52 <STEPPER_u8Rotate+0x1b4e>
		__ticks = 1;
    4d48:	81 e0       	ldi	r24, 0x01	; 1
    4d4a:	90 e0       	ldi	r25, 0x00	; 0
    4d4c:	9a a3       	std	Y+34, r25	; 0x22
    4d4e:	89 a3       	std	Y+33, r24	; 0x21
    4d50:	3f c0       	rjmp	.+126    	; 0x4dd0 <STEPPER_u8Rotate+0x1bcc>
	else if (__tmp > 65535)
    4d52:	6b a1       	ldd	r22, Y+35	; 0x23
    4d54:	7c a1       	ldd	r23, Y+36	; 0x24
    4d56:	8d a1       	ldd	r24, Y+37	; 0x25
    4d58:	9e a1       	ldd	r25, Y+38	; 0x26
    4d5a:	20 e0       	ldi	r18, 0x00	; 0
    4d5c:	3f ef       	ldi	r19, 0xFF	; 255
    4d5e:	4f e7       	ldi	r20, 0x7F	; 127
    4d60:	57 e4       	ldi	r21, 0x47	; 71
    4d62:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    4d66:	18 16       	cp	r1, r24
    4d68:	4c f5       	brge	.+82     	; 0x4dbc <STEPPER_u8Rotate+0x1bb8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4d6a:	6f a1       	ldd	r22, Y+39	; 0x27
    4d6c:	78 a5       	ldd	r23, Y+40	; 0x28
    4d6e:	89 a5       	ldd	r24, Y+41	; 0x29
    4d70:	9a a5       	ldd	r25, Y+42	; 0x2a
    4d72:	20 e0       	ldi	r18, 0x00	; 0
    4d74:	30 e0       	ldi	r19, 0x00	; 0
    4d76:	40 e2       	ldi	r20, 0x20	; 32
    4d78:	51 e4       	ldi	r21, 0x41	; 65
    4d7a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4d7e:	dc 01       	movw	r26, r24
    4d80:	cb 01       	movw	r24, r22
    4d82:	bc 01       	movw	r22, r24
    4d84:	cd 01       	movw	r24, r26
    4d86:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4d8a:	dc 01       	movw	r26, r24
    4d8c:	cb 01       	movw	r24, r22
    4d8e:	9a a3       	std	Y+34, r25	; 0x22
    4d90:	89 a3       	std	Y+33, r24	; 0x21
    4d92:	0f c0       	rjmp	.+30     	; 0x4db2 <STEPPER_u8Rotate+0x1bae>
    4d94:	88 ec       	ldi	r24, 0xC8	; 200
    4d96:	90 e0       	ldi	r25, 0x00	; 0
    4d98:	98 a3       	std	Y+32, r25	; 0x20
    4d9a:	8f 8f       	std	Y+31, r24	; 0x1f
    4d9c:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4d9e:	98 a1       	ldd	r25, Y+32	; 0x20
    4da0:	01 97       	sbiw	r24, 0x01	; 1
    4da2:	f1 f7       	brne	.-4      	; 0x4da0 <STEPPER_u8Rotate+0x1b9c>
    4da4:	98 a3       	std	Y+32, r25	; 0x20
    4da6:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4da8:	89 a1       	ldd	r24, Y+33	; 0x21
    4daa:	9a a1       	ldd	r25, Y+34	; 0x22
    4dac:	01 97       	sbiw	r24, 0x01	; 1
    4dae:	9a a3       	std	Y+34, r25	; 0x22
    4db0:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4db2:	89 a1       	ldd	r24, Y+33	; 0x21
    4db4:	9a a1       	ldd	r25, Y+34	; 0x22
    4db6:	00 97       	sbiw	r24, 0x00	; 0
    4db8:	69 f7       	brne	.-38     	; 0x4d94 <STEPPER_u8Rotate+0x1b90>
    4dba:	14 c0       	rjmp	.+40     	; 0x4de4 <STEPPER_u8Rotate+0x1be0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4dbc:	6b a1       	ldd	r22, Y+35	; 0x23
    4dbe:	7c a1       	ldd	r23, Y+36	; 0x24
    4dc0:	8d a1       	ldd	r24, Y+37	; 0x25
    4dc2:	9e a1       	ldd	r25, Y+38	; 0x26
    4dc4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4dc8:	dc 01       	movw	r26, r24
    4dca:	cb 01       	movw	r24, r22
    4dcc:	9a a3       	std	Y+34, r25	; 0x22
    4dce:	89 a3       	std	Y+33, r24	; 0x21
    4dd0:	89 a1       	ldd	r24, Y+33	; 0x21
    4dd2:	9a a1       	ldd	r25, Y+34	; 0x22
    4dd4:	9e 8f       	std	Y+30, r25	; 0x1e
    4dd6:	8d 8f       	std	Y+29, r24	; 0x1d
    4dd8:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4dda:	9e 8d       	ldd	r25, Y+30	; 0x1e
    4ddc:	01 97       	sbiw	r24, 0x01	; 1
    4dde:	f1 f7       	brne	.-4      	; 0x4ddc <STEPPER_u8Rotate+0x1bd8>
    4de0:	9e 8f       	std	Y+30, r25	; 0x1e
    4de2:	8d 8f       	std	Y+29, r24	; 0x1d
				_delay_ms(2);
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN4,DIO_u8Pin_HIGH);
    4de4:	fe 01       	movw	r30, r28
    4de6:	e6 51       	subi	r30, 0x16	; 22
    4de8:	ff 4f       	sbci	r31, 0xFF	; 255
    4dea:	01 90       	ld	r0, Z+
    4dec:	f0 81       	ld	r31, Z
    4dee:	e0 2d       	mov	r30, r0
    4df0:	80 81       	ld	r24, Z
    4df2:	fe 01       	movw	r30, r28
    4df4:	e6 51       	subi	r30, 0x16	; 22
    4df6:	ff 4f       	sbci	r31, 0xFF	; 255
    4df8:	01 90       	ld	r0, Z+
    4dfa:	f0 81       	ld	r31, Z
    4dfc:	e0 2d       	mov	r30, r0
    4dfe:	94 81       	ldd	r25, Z+4	; 0x04
    4e00:	69 2f       	mov	r22, r25
    4e02:	41 e0       	ldi	r20, 0x01	; 1
    4e04:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN3,DIO_u8Pin_HIGH);
    4e08:	fe 01       	movw	r30, r28
    4e0a:	e6 51       	subi	r30, 0x16	; 22
    4e0c:	ff 4f       	sbci	r31, 0xFF	; 255
    4e0e:	01 90       	ld	r0, Z+
    4e10:	f0 81       	ld	r31, Z
    4e12:	e0 2d       	mov	r30, r0
    4e14:	80 81       	ld	r24, Z
    4e16:	fe 01       	movw	r30, r28
    4e18:	e6 51       	subi	r30, 0x16	; 22
    4e1a:	ff 4f       	sbci	r31, 0xFF	; 255
    4e1c:	01 90       	ld	r0, Z+
    4e1e:	f0 81       	ld	r31, Z
    4e20:	e0 2d       	mov	r30, r0
    4e22:	93 81       	ldd	r25, Z+3	; 0x03
    4e24:	69 2f       	mov	r22, r25
    4e26:	41 e0       	ldi	r20, 0x01	; 1
    4e28:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN2,DIO_u8Pin_LOW);
    4e2c:	fe 01       	movw	r30, r28
    4e2e:	e6 51       	subi	r30, 0x16	; 22
    4e30:	ff 4f       	sbci	r31, 0xFF	; 255
    4e32:	01 90       	ld	r0, Z+
    4e34:	f0 81       	ld	r31, Z
    4e36:	e0 2d       	mov	r30, r0
    4e38:	80 81       	ld	r24, Z
    4e3a:	fe 01       	movw	r30, r28
    4e3c:	e6 51       	subi	r30, 0x16	; 22
    4e3e:	ff 4f       	sbci	r31, 0xFF	; 255
    4e40:	01 90       	ld	r0, Z+
    4e42:	f0 81       	ld	r31, Z
    4e44:	e0 2d       	mov	r30, r0
    4e46:	92 81       	ldd	r25, Z+2	; 0x02
    4e48:	69 2f       	mov	r22, r25
    4e4a:	40 e0       	ldi	r20, 0x00	; 0
    4e4c:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN1,DIO_u8Pin_HIGH);
    4e50:	fe 01       	movw	r30, r28
    4e52:	e6 51       	subi	r30, 0x16	; 22
    4e54:	ff 4f       	sbci	r31, 0xFF	; 255
    4e56:	01 90       	ld	r0, Z+
    4e58:	f0 81       	ld	r31, Z
    4e5a:	e0 2d       	mov	r30, r0
    4e5c:	80 81       	ld	r24, Z
    4e5e:	fe 01       	movw	r30, r28
    4e60:	e6 51       	subi	r30, 0x16	; 22
    4e62:	ff 4f       	sbci	r31, 0xFF	; 255
    4e64:	01 90       	ld	r0, Z+
    4e66:	f0 81       	ld	r31, Z
    4e68:	e0 2d       	mov	r30, r0
    4e6a:	91 81       	ldd	r25, Z+1	; 0x01
    4e6c:	69 2f       	mov	r22, r25
    4e6e:	41 e0       	ldi	r20, 0x01	; 1
    4e70:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
    4e74:	80 e0       	ldi	r24, 0x00	; 0
    4e76:	90 e0       	ldi	r25, 0x00	; 0
    4e78:	a0 e0       	ldi	r26, 0x00	; 0
    4e7a:	b0 e4       	ldi	r27, 0x40	; 64
    4e7c:	89 8f       	std	Y+25, r24	; 0x19
    4e7e:	9a 8f       	std	Y+26, r25	; 0x1a
    4e80:	ab 8f       	std	Y+27, r26	; 0x1b
    4e82:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4e84:	69 8d       	ldd	r22, Y+25	; 0x19
    4e86:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4e88:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4e8a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4e8c:	20 e0       	ldi	r18, 0x00	; 0
    4e8e:	30 e0       	ldi	r19, 0x00	; 0
    4e90:	4a ef       	ldi	r20, 0xFA	; 250
    4e92:	54 e4       	ldi	r21, 0x44	; 68
    4e94:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4e98:	dc 01       	movw	r26, r24
    4e9a:	cb 01       	movw	r24, r22
    4e9c:	8d 8b       	std	Y+21, r24	; 0x15
    4e9e:	9e 8b       	std	Y+22, r25	; 0x16
    4ea0:	af 8b       	std	Y+23, r26	; 0x17
    4ea2:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    4ea4:	6d 89       	ldd	r22, Y+21	; 0x15
    4ea6:	7e 89       	ldd	r23, Y+22	; 0x16
    4ea8:	8f 89       	ldd	r24, Y+23	; 0x17
    4eaa:	98 8d       	ldd	r25, Y+24	; 0x18
    4eac:	20 e0       	ldi	r18, 0x00	; 0
    4eae:	30 e0       	ldi	r19, 0x00	; 0
    4eb0:	40 e8       	ldi	r20, 0x80	; 128
    4eb2:	5f e3       	ldi	r21, 0x3F	; 63
    4eb4:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    4eb8:	88 23       	and	r24, r24
    4eba:	2c f4       	brge	.+10     	; 0x4ec6 <STEPPER_u8Rotate+0x1cc2>
		__ticks = 1;
    4ebc:	81 e0       	ldi	r24, 0x01	; 1
    4ebe:	90 e0       	ldi	r25, 0x00	; 0
    4ec0:	9c 8b       	std	Y+20, r25	; 0x14
    4ec2:	8b 8b       	std	Y+19, r24	; 0x13
    4ec4:	3f c0       	rjmp	.+126    	; 0x4f44 <STEPPER_u8Rotate+0x1d40>
	else if (__tmp > 65535)
    4ec6:	6d 89       	ldd	r22, Y+21	; 0x15
    4ec8:	7e 89       	ldd	r23, Y+22	; 0x16
    4eca:	8f 89       	ldd	r24, Y+23	; 0x17
    4ecc:	98 8d       	ldd	r25, Y+24	; 0x18
    4ece:	20 e0       	ldi	r18, 0x00	; 0
    4ed0:	3f ef       	ldi	r19, 0xFF	; 255
    4ed2:	4f e7       	ldi	r20, 0x7F	; 127
    4ed4:	57 e4       	ldi	r21, 0x47	; 71
    4ed6:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    4eda:	18 16       	cp	r1, r24
    4edc:	4c f5       	brge	.+82     	; 0x4f30 <STEPPER_u8Rotate+0x1d2c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4ede:	69 8d       	ldd	r22, Y+25	; 0x19
    4ee0:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4ee2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4ee4:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4ee6:	20 e0       	ldi	r18, 0x00	; 0
    4ee8:	30 e0       	ldi	r19, 0x00	; 0
    4eea:	40 e2       	ldi	r20, 0x20	; 32
    4eec:	51 e4       	ldi	r21, 0x41	; 65
    4eee:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4ef2:	dc 01       	movw	r26, r24
    4ef4:	cb 01       	movw	r24, r22
    4ef6:	bc 01       	movw	r22, r24
    4ef8:	cd 01       	movw	r24, r26
    4efa:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4efe:	dc 01       	movw	r26, r24
    4f00:	cb 01       	movw	r24, r22
    4f02:	9c 8b       	std	Y+20, r25	; 0x14
    4f04:	8b 8b       	std	Y+19, r24	; 0x13
    4f06:	0f c0       	rjmp	.+30     	; 0x4f26 <STEPPER_u8Rotate+0x1d22>
    4f08:	88 ec       	ldi	r24, 0xC8	; 200
    4f0a:	90 e0       	ldi	r25, 0x00	; 0
    4f0c:	9a 8b       	std	Y+18, r25	; 0x12
    4f0e:	89 8b       	std	Y+17, r24	; 0x11
    4f10:	89 89       	ldd	r24, Y+17	; 0x11
    4f12:	9a 89       	ldd	r25, Y+18	; 0x12
    4f14:	01 97       	sbiw	r24, 0x01	; 1
    4f16:	f1 f7       	brne	.-4      	; 0x4f14 <STEPPER_u8Rotate+0x1d10>
    4f18:	9a 8b       	std	Y+18, r25	; 0x12
    4f1a:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4f1c:	8b 89       	ldd	r24, Y+19	; 0x13
    4f1e:	9c 89       	ldd	r25, Y+20	; 0x14
    4f20:	01 97       	sbiw	r24, 0x01	; 1
    4f22:	9c 8b       	std	Y+20, r25	; 0x14
    4f24:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4f26:	8b 89       	ldd	r24, Y+19	; 0x13
    4f28:	9c 89       	ldd	r25, Y+20	; 0x14
    4f2a:	00 97       	sbiw	r24, 0x00	; 0
    4f2c:	69 f7       	brne	.-38     	; 0x4f08 <STEPPER_u8Rotate+0x1d04>
    4f2e:	14 c0       	rjmp	.+40     	; 0x4f58 <STEPPER_u8Rotate+0x1d54>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4f30:	6d 89       	ldd	r22, Y+21	; 0x15
    4f32:	7e 89       	ldd	r23, Y+22	; 0x16
    4f34:	8f 89       	ldd	r24, Y+23	; 0x17
    4f36:	98 8d       	ldd	r25, Y+24	; 0x18
    4f38:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4f3c:	dc 01       	movw	r26, r24
    4f3e:	cb 01       	movw	r24, r22
    4f40:	9c 8b       	std	Y+20, r25	; 0x14
    4f42:	8b 8b       	std	Y+19, r24	; 0x13
    4f44:	8b 89       	ldd	r24, Y+19	; 0x13
    4f46:	9c 89       	ldd	r25, Y+20	; 0x14
    4f48:	98 8b       	std	Y+16, r25	; 0x10
    4f4a:	8f 87       	std	Y+15, r24	; 0x0f
    4f4c:	8f 85       	ldd	r24, Y+15	; 0x0f
    4f4e:	98 89       	ldd	r25, Y+16	; 0x10
    4f50:	01 97       	sbiw	r24, 0x01	; 1
    4f52:	f1 f7       	brne	.-4      	; 0x4f50 <STEPPER_u8Rotate+0x1d4c>
    4f54:	98 8b       	std	Y+16, r25	; 0x10
    4f56:	8f 87       	std	Y+15, r24	; 0x0f
				_delay_ms(2);
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN4,DIO_u8Pin_HIGH);
    4f58:	fe 01       	movw	r30, r28
    4f5a:	e6 51       	subi	r30, 0x16	; 22
    4f5c:	ff 4f       	sbci	r31, 0xFF	; 255
    4f5e:	01 90       	ld	r0, Z+
    4f60:	f0 81       	ld	r31, Z
    4f62:	e0 2d       	mov	r30, r0
    4f64:	80 81       	ld	r24, Z
    4f66:	fe 01       	movw	r30, r28
    4f68:	e6 51       	subi	r30, 0x16	; 22
    4f6a:	ff 4f       	sbci	r31, 0xFF	; 255
    4f6c:	01 90       	ld	r0, Z+
    4f6e:	f0 81       	ld	r31, Z
    4f70:	e0 2d       	mov	r30, r0
    4f72:	94 81       	ldd	r25, Z+4	; 0x04
    4f74:	69 2f       	mov	r22, r25
    4f76:	41 e0       	ldi	r20, 0x01	; 1
    4f78:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN3,DIO_u8Pin_HIGH);
    4f7c:	fe 01       	movw	r30, r28
    4f7e:	e6 51       	subi	r30, 0x16	; 22
    4f80:	ff 4f       	sbci	r31, 0xFF	; 255
    4f82:	01 90       	ld	r0, Z+
    4f84:	f0 81       	ld	r31, Z
    4f86:	e0 2d       	mov	r30, r0
    4f88:	80 81       	ld	r24, Z
    4f8a:	fe 01       	movw	r30, r28
    4f8c:	e6 51       	subi	r30, 0x16	; 22
    4f8e:	ff 4f       	sbci	r31, 0xFF	; 255
    4f90:	01 90       	ld	r0, Z+
    4f92:	f0 81       	ld	r31, Z
    4f94:	e0 2d       	mov	r30, r0
    4f96:	93 81       	ldd	r25, Z+3	; 0x03
    4f98:	69 2f       	mov	r22, r25
    4f9a:	41 e0       	ldi	r20, 0x01	; 1
    4f9c:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN2,DIO_u8Pin_HIGH);
    4fa0:	fe 01       	movw	r30, r28
    4fa2:	e6 51       	subi	r30, 0x16	; 22
    4fa4:	ff 4f       	sbci	r31, 0xFF	; 255
    4fa6:	01 90       	ld	r0, Z+
    4fa8:	f0 81       	ld	r31, Z
    4faa:	e0 2d       	mov	r30, r0
    4fac:	80 81       	ld	r24, Z
    4fae:	fe 01       	movw	r30, r28
    4fb0:	e6 51       	subi	r30, 0x16	; 22
    4fb2:	ff 4f       	sbci	r31, 0xFF	; 255
    4fb4:	01 90       	ld	r0, Z+
    4fb6:	f0 81       	ld	r31, Z
    4fb8:	e0 2d       	mov	r30, r0
    4fba:	92 81       	ldd	r25, Z+2	; 0x02
    4fbc:	69 2f       	mov	r22, r25
    4fbe:	41 e0       	ldi	r20, 0x01	; 1
    4fc0:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN1,DIO_u8Pin_LOW);
    4fc4:	fe 01       	movw	r30, r28
    4fc6:	e6 51       	subi	r30, 0x16	; 22
    4fc8:	ff 4f       	sbci	r31, 0xFF	; 255
    4fca:	01 90       	ld	r0, Z+
    4fcc:	f0 81       	ld	r31, Z
    4fce:	e0 2d       	mov	r30, r0
    4fd0:	80 81       	ld	r24, Z
    4fd2:	fe 01       	movw	r30, r28
    4fd4:	e6 51       	subi	r30, 0x16	; 22
    4fd6:	ff 4f       	sbci	r31, 0xFF	; 255
    4fd8:	01 90       	ld	r0, Z+
    4fda:	f0 81       	ld	r31, Z
    4fdc:	e0 2d       	mov	r30, r0
    4fde:	91 81       	ldd	r25, Z+1	; 0x01
    4fe0:	69 2f       	mov	r22, r25
    4fe2:	40 e0       	ldi	r20, 0x00	; 0
    4fe4:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
    4fe8:	80 e0       	ldi	r24, 0x00	; 0
    4fea:	90 e0       	ldi	r25, 0x00	; 0
    4fec:	a0 e0       	ldi	r26, 0x00	; 0
    4fee:	b0 e4       	ldi	r27, 0x40	; 64
    4ff0:	8b 87       	std	Y+11, r24	; 0x0b
    4ff2:	9c 87       	std	Y+12, r25	; 0x0c
    4ff4:	ad 87       	std	Y+13, r26	; 0x0d
    4ff6:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4ff8:	6b 85       	ldd	r22, Y+11	; 0x0b
    4ffa:	7c 85       	ldd	r23, Y+12	; 0x0c
    4ffc:	8d 85       	ldd	r24, Y+13	; 0x0d
    4ffe:	9e 85       	ldd	r25, Y+14	; 0x0e
    5000:	20 e0       	ldi	r18, 0x00	; 0
    5002:	30 e0       	ldi	r19, 0x00	; 0
    5004:	4a ef       	ldi	r20, 0xFA	; 250
    5006:	54 e4       	ldi	r21, 0x44	; 68
    5008:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    500c:	dc 01       	movw	r26, r24
    500e:	cb 01       	movw	r24, r22
    5010:	8f 83       	std	Y+7, r24	; 0x07
    5012:	98 87       	std	Y+8, r25	; 0x08
    5014:	a9 87       	std	Y+9, r26	; 0x09
    5016:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    5018:	6f 81       	ldd	r22, Y+7	; 0x07
    501a:	78 85       	ldd	r23, Y+8	; 0x08
    501c:	89 85       	ldd	r24, Y+9	; 0x09
    501e:	9a 85       	ldd	r25, Y+10	; 0x0a
    5020:	20 e0       	ldi	r18, 0x00	; 0
    5022:	30 e0       	ldi	r19, 0x00	; 0
    5024:	40 e8       	ldi	r20, 0x80	; 128
    5026:	5f e3       	ldi	r21, 0x3F	; 63
    5028:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    502c:	88 23       	and	r24, r24
    502e:	2c f4       	brge	.+10     	; 0x503a <STEPPER_u8Rotate+0x1e36>
		__ticks = 1;
    5030:	81 e0       	ldi	r24, 0x01	; 1
    5032:	90 e0       	ldi	r25, 0x00	; 0
    5034:	9e 83       	std	Y+6, r25	; 0x06
    5036:	8d 83       	std	Y+5, r24	; 0x05
    5038:	3f c0       	rjmp	.+126    	; 0x50b8 <STEPPER_u8Rotate+0x1eb4>
	else if (__tmp > 65535)
    503a:	6f 81       	ldd	r22, Y+7	; 0x07
    503c:	78 85       	ldd	r23, Y+8	; 0x08
    503e:	89 85       	ldd	r24, Y+9	; 0x09
    5040:	9a 85       	ldd	r25, Y+10	; 0x0a
    5042:	20 e0       	ldi	r18, 0x00	; 0
    5044:	3f ef       	ldi	r19, 0xFF	; 255
    5046:	4f e7       	ldi	r20, 0x7F	; 127
    5048:	57 e4       	ldi	r21, 0x47	; 71
    504a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    504e:	18 16       	cp	r1, r24
    5050:	4c f5       	brge	.+82     	; 0x50a4 <STEPPER_u8Rotate+0x1ea0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5052:	6b 85       	ldd	r22, Y+11	; 0x0b
    5054:	7c 85       	ldd	r23, Y+12	; 0x0c
    5056:	8d 85       	ldd	r24, Y+13	; 0x0d
    5058:	9e 85       	ldd	r25, Y+14	; 0x0e
    505a:	20 e0       	ldi	r18, 0x00	; 0
    505c:	30 e0       	ldi	r19, 0x00	; 0
    505e:	40 e2       	ldi	r20, 0x20	; 32
    5060:	51 e4       	ldi	r21, 0x41	; 65
    5062:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5066:	dc 01       	movw	r26, r24
    5068:	cb 01       	movw	r24, r22
    506a:	bc 01       	movw	r22, r24
    506c:	cd 01       	movw	r24, r26
    506e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5072:	dc 01       	movw	r26, r24
    5074:	cb 01       	movw	r24, r22
    5076:	9e 83       	std	Y+6, r25	; 0x06
    5078:	8d 83       	std	Y+5, r24	; 0x05
    507a:	0f c0       	rjmp	.+30     	; 0x509a <STEPPER_u8Rotate+0x1e96>
    507c:	88 ec       	ldi	r24, 0xC8	; 200
    507e:	90 e0       	ldi	r25, 0x00	; 0
    5080:	9c 83       	std	Y+4, r25	; 0x04
    5082:	8b 83       	std	Y+3, r24	; 0x03
    5084:	8b 81       	ldd	r24, Y+3	; 0x03
    5086:	9c 81       	ldd	r25, Y+4	; 0x04
    5088:	01 97       	sbiw	r24, 0x01	; 1
    508a:	f1 f7       	brne	.-4      	; 0x5088 <STEPPER_u8Rotate+0x1e84>
    508c:	9c 83       	std	Y+4, r25	; 0x04
    508e:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5090:	8d 81       	ldd	r24, Y+5	; 0x05
    5092:	9e 81       	ldd	r25, Y+6	; 0x06
    5094:	01 97       	sbiw	r24, 0x01	; 1
    5096:	9e 83       	std	Y+6, r25	; 0x06
    5098:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    509a:	8d 81       	ldd	r24, Y+5	; 0x05
    509c:	9e 81       	ldd	r25, Y+6	; 0x06
    509e:	00 97       	sbiw	r24, 0x00	; 0
    50a0:	69 f7       	brne	.-38     	; 0x507c <STEPPER_u8Rotate+0x1e78>
    50a2:	14 c0       	rjmp	.+40     	; 0x50cc <STEPPER_u8Rotate+0x1ec8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    50a4:	6f 81       	ldd	r22, Y+7	; 0x07
    50a6:	78 85       	ldd	r23, Y+8	; 0x08
    50a8:	89 85       	ldd	r24, Y+9	; 0x09
    50aa:	9a 85       	ldd	r25, Y+10	; 0x0a
    50ac:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    50b0:	dc 01       	movw	r26, r24
    50b2:	cb 01       	movw	r24, r22
    50b4:	9e 83       	std	Y+6, r25	; 0x06
    50b6:	8d 83       	std	Y+5, r24	; 0x05
    50b8:	8d 81       	ldd	r24, Y+5	; 0x05
    50ba:	9e 81       	ldd	r25, Y+6	; 0x06
    50bc:	9a 83       	std	Y+2, r25	; 0x02
    50be:	89 83       	std	Y+1, r24	; 0x01
    50c0:	89 81       	ldd	r24, Y+1	; 0x01
    50c2:	9a 81       	ldd	r25, Y+2	; 0x02
    50c4:	01 97       	sbiw	r24, 0x01	; 1
    50c6:	f1 f7       	brne	.-4      	; 0x50c4 <STEPPER_u8Rotate+0x1ec0>
    50c8:	9a 83       	std	Y+2, r25	; 0x02
    50ca:	89 83       	std	Y+1, r24	; 0x01
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN2,DIO_u8Pin_HIGH);
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN3,DIO_u8Pin_HIGH);
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN4,DIO_u8Pin_LOW);
				_delay_ms(2);
			} break;
			case CW: for(Local_u32Counter=0;Local_u32Counter<Local_u32IterationsNum;Local_u32Counter++)
    50cc:	9e 01       	movw	r18, r28
    50ce:	2f 51       	subi	r18, 0x1F	; 31
    50d0:	3f 4f       	sbci	r19, 0xFF	; 255
    50d2:	fe 01       	movw	r30, r28
    50d4:	ef 51       	subi	r30, 0x1F	; 31
    50d6:	ff 4f       	sbci	r31, 0xFF	; 255
    50d8:	80 81       	ld	r24, Z
    50da:	91 81       	ldd	r25, Z+1	; 0x01
    50dc:	a2 81       	ldd	r26, Z+2	; 0x02
    50de:	b3 81       	ldd	r27, Z+3	; 0x03
    50e0:	01 96       	adiw	r24, 0x01	; 1
    50e2:	a1 1d       	adc	r26, r1
    50e4:	b1 1d       	adc	r27, r1
    50e6:	f9 01       	movw	r30, r18
    50e8:	80 83       	st	Z, r24
    50ea:	91 83       	std	Z+1, r25	; 0x01
    50ec:	a2 83       	std	Z+2, r26	; 0x02
    50ee:	b3 83       	std	Z+3, r27	; 0x03
    50f0:	fe 01       	movw	r30, r28
    50f2:	ef 51       	subi	r30, 0x1F	; 31
    50f4:	ff 4f       	sbci	r31, 0xFF	; 255
    50f6:	de 01       	movw	r26, r28
    50f8:	ab 51       	subi	r26, 0x1B	; 27
    50fa:	bf 4f       	sbci	r27, 0xFF	; 255
    50fc:	20 81       	ld	r18, Z
    50fe:	31 81       	ldd	r19, Z+1	; 0x01
    5100:	42 81       	ldd	r20, Z+2	; 0x02
    5102:	53 81       	ldd	r21, Z+3	; 0x03
    5104:	8d 91       	ld	r24, X+
    5106:	9d 91       	ld	r25, X+
    5108:	0d 90       	ld	r0, X+
    510a:	bc 91       	ld	r27, X
    510c:	a0 2d       	mov	r26, r0
    510e:	28 17       	cp	r18, r24
    5110:	39 07       	cpc	r19, r25
    5112:	4a 07       	cpc	r20, r26
    5114:	5b 07       	cpc	r21, r27
    5116:	08 f4       	brcc	.+2      	; 0x511a <STEPPER_u8Rotate+0x1f16>
    5118:	f1 cc       	rjmp	.-1566   	; 0x4afc <STEPPER_u8Rotate+0x18f8>
    511a:	05 c0       	rjmp	.+10     	; 0x5126 <STEPPER_u8Rotate+0x1f22>
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN3,DIO_u8Pin_HIGH);
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN2,DIO_u8Pin_HIGH);
				DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN1,DIO_u8Pin_LOW);
				_delay_ms(2);
			} break;
			default: Local_u8ErorState=WORNG_DIRECTION; break;
    511c:	fe 01       	movw	r30, r28
    511e:	e7 51       	subi	r30, 0x17	; 23
    5120:	ff 4f       	sbci	r31, 0xFF	; 255
    5122:	85 e0       	ldi	r24, 0x05	; 5
    5124:	80 83       	st	Z, r24
			}
		}
	}

	return Local_u8ErorState;
    5126:	fe 01       	movw	r30, r28
    5128:	e7 51       	subi	r30, 0x17	; 23
    512a:	ff 4f       	sbci	r31, 0xFF	; 255
    512c:	80 81       	ld	r24, Z
}
    512e:	ce 50       	subi	r28, 0x0E	; 14
    5130:	df 4f       	sbci	r29, 0xFF	; 255
    5132:	0f b6       	in	r0, 0x3f	; 63
    5134:	f8 94       	cli
    5136:	de bf       	out	0x3e, r29	; 62
    5138:	0f be       	out	0x3f, r0	; 63
    513a:	cd bf       	out	0x3d, r28	; 61
    513c:	cf 91       	pop	r28
    513e:	df 91       	pop	r29
    5140:	1f 91       	pop	r17
    5142:	0f 91       	pop	r16
    5144:	08 95       	ret

00005146 <STEPPER_u8Stop>:
u8 STEPPER_u8Stop(STEPPER_MOTOR* Copy_STEPPERMOTOR)
{
    5146:	df 93       	push	r29
    5148:	cf 93       	push	r28
    514a:	00 d0       	rcall	.+0      	; 0x514c <STEPPER_u8Stop+0x6>
    514c:	0f 92       	push	r0
    514e:	cd b7       	in	r28, 0x3d	; 61
    5150:	de b7       	in	r29, 0x3e	; 62
    5152:	9b 83       	std	Y+3, r25	; 0x03
    5154:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_u8ErorState=OK;
    5156:	19 82       	std	Y+1, r1	; 0x01
	if(Copy_STEPPERMOTOR==NULL)
    5158:	8a 81       	ldd	r24, Y+2	; 0x02
    515a:	9b 81       	ldd	r25, Y+3	; 0x03
    515c:	00 97       	sbiw	r24, 0x00	; 0
    515e:	19 f4       	brne	.+6      	; 0x5166 <STEPPER_u8Stop+0x20>
	{
		Local_u8ErorState=NULL_POINTER;
    5160:	82 e0       	ldi	r24, 0x02	; 2
    5162:	89 83       	std	Y+1, r24	; 0x01
    5164:	28 c0       	rjmp	.+80     	; 0x51b6 <STEPPER_u8Stop+0x70>
	}
	else
	{
		DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN1,DIO_u8Pin_HIGH);
    5166:	ea 81       	ldd	r30, Y+2	; 0x02
    5168:	fb 81       	ldd	r31, Y+3	; 0x03
    516a:	80 81       	ld	r24, Z
    516c:	ea 81       	ldd	r30, Y+2	; 0x02
    516e:	fb 81       	ldd	r31, Y+3	; 0x03
    5170:	91 81       	ldd	r25, Z+1	; 0x01
    5172:	69 2f       	mov	r22, r25
    5174:	41 e0       	ldi	r20, 0x01	; 1
    5176:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
		DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN1,DIO_u8Pin_HIGH);
    517a:	ea 81       	ldd	r30, Y+2	; 0x02
    517c:	fb 81       	ldd	r31, Y+3	; 0x03
    517e:	80 81       	ld	r24, Z
    5180:	ea 81       	ldd	r30, Y+2	; 0x02
    5182:	fb 81       	ldd	r31, Y+3	; 0x03
    5184:	91 81       	ldd	r25, Z+1	; 0x01
    5186:	69 2f       	mov	r22, r25
    5188:	41 e0       	ldi	r20, 0x01	; 1
    518a:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
		DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN1,DIO_u8Pin_HIGH);
    518e:	ea 81       	ldd	r30, Y+2	; 0x02
    5190:	fb 81       	ldd	r31, Y+3	; 0x03
    5192:	80 81       	ld	r24, Z
    5194:	ea 81       	ldd	r30, Y+2	; 0x02
    5196:	fb 81       	ldd	r31, Y+3	; 0x03
    5198:	91 81       	ldd	r25, Z+1	; 0x01
    519a:	69 2f       	mov	r22, r25
    519c:	41 e0       	ldi	r20, 0x01	; 1
    519e:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
		DIO_u8SetPinValue(Copy_STEPPERMOTOR->Stepper_Port,Copy_STEPPERMOTOR->Stepper_PIN1,DIO_u8Pin_HIGH);
    51a2:	ea 81       	ldd	r30, Y+2	; 0x02
    51a4:	fb 81       	ldd	r31, Y+3	; 0x03
    51a6:	80 81       	ld	r24, Z
    51a8:	ea 81       	ldd	r30, Y+2	; 0x02
    51aa:	fb 81       	ldd	r31, Y+3	; 0x03
    51ac:	91 81       	ldd	r25, Z+1	; 0x01
    51ae:	69 2f       	mov	r22, r25
    51b0:	41 e0       	ldi	r20, 0x01	; 1
    51b2:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
	}

	return Local_u8ErorState;
    51b6:	89 81       	ldd	r24, Y+1	; 0x01
}
    51b8:	0f 90       	pop	r0
    51ba:	0f 90       	pop	r0
    51bc:	0f 90       	pop	r0
    51be:	cf 91       	pop	r28
    51c0:	df 91       	pop	r29
    51c2:	08 95       	ret

000051c4 <KPD_u8GetPressedKey>:
#include "KEYPAD_config.h"
#include "KEYPAD_interface.h"
#include "KEYPAD_private.h"

u8 KPD_u8GetPressedKey(void)
{
    51c4:	df 93       	push	r29
    51c6:	cf 93       	push	r28
    51c8:	00 d0       	rcall	.+0      	; 0x51ca <KPD_u8GetPressedKey+0x6>
    51ca:	00 d0       	rcall	.+0      	; 0x51cc <KPD_u8GetPressedKey+0x8>
    51cc:	0f 92       	push	r0
    51ce:	cd b7       	in	r28, 0x3d	; 61
    51d0:	de b7       	in	r29, 0x3e	; 62
	u8 Local_u8PressedKey=KPD_NO_PRESSED_KEY, Local_u8ColumnIdx,Local_u8RowIdx,Local_u8PinState;
    51d2:	8f ef       	ldi	r24, 0xFF	; 255
    51d4:	8b 83       	std	Y+3, r24	; 0x03
	static u8 Local_u8KPDColumnArr[COLUMN_NUM]={KPD_COLUMN0_PIN,KPD_COLUMN1_PIN,KPD_COLUMN2_PIN,KPD_COLUMN3_PIN};
#elif COLUMN_NUM==3
	static u8 Local_u8KPDColumnArr[COLUMN_NUM]={KPD_COLUMN0_PIN,KPD_COLUMN1_PIN,KPD_COLUMN2_PIN};
#endif
	static u8 Local_u8KPDROWArr[ROW_NUM]={KPD_ROW0_PIN,KPD_ROW1_PIN,KPD_ROW2_PIN,KPD_ROW3_PIN};
	for(Local_u8ColumnIdx=0; Local_u8ColumnIdx<COLUMN_NUM;Local_u8ColumnIdx++)
    51d6:	1a 82       	std	Y+2, r1	; 0x02
    51d8:	5e c0       	rjmp	.+188    	; 0x5296 <KPD_u8GetPressedKey+0xd2>
	{
		/*Activate current column*/
		DIO_u8SetPinValue(KPD_PORT,Local_u8KPDColumnArr[Local_u8ColumnIdx],DIO_u8Pin_LOW);
    51da:	8a 81       	ldd	r24, Y+2	; 0x02
    51dc:	88 2f       	mov	r24, r24
    51de:	90 e0       	ldi	r25, 0x00	; 0
    51e0:	fc 01       	movw	r30, r24
    51e2:	ea 53       	subi	r30, 0x3A	; 58
    51e4:	ff 4f       	sbci	r31, 0xFF	; 255
    51e6:	90 81       	ld	r25, Z
    51e8:	81 e0       	ldi	r24, 0x01	; 1
    51ea:	69 2f       	mov	r22, r25
    51ec:	40 e0       	ldi	r20, 0x00	; 0
    51ee:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>

		for(Local_u8RowIdx=0;Local_u8RowIdx<ROW_NUM;Local_u8RowIdx++)
    51f2:	19 82       	std	Y+1, r1	; 0x01
    51f4:	3d c0       	rjmp	.+122    	; 0x5270 <KPD_u8GetPressedKey+0xac>
		{
			/*Read The Current row*/
			DIO_u8GetPinValue(KPD_PORT,Local_u8KPDROWArr[Local_u8RowIdx],&Local_u8PinState);
    51f6:	89 81       	ldd	r24, Y+1	; 0x01
    51f8:	88 2f       	mov	r24, r24
    51fa:	90 e0       	ldi	r25, 0x00	; 0
    51fc:	fc 01       	movw	r30, r24
    51fe:	ee 53       	subi	r30, 0x3E	; 62
    5200:	ff 4f       	sbci	r31, 0xFF	; 255
    5202:	90 81       	ld	r25, Z
    5204:	9e 01       	movw	r18, r28
    5206:	2c 5f       	subi	r18, 0xFC	; 252
    5208:	3f 4f       	sbci	r19, 0xFF	; 255
    520a:	81 e0       	ldi	r24, 0x01	; 1
    520c:	69 2f       	mov	r22, r25
    520e:	a9 01       	movw	r20, r18
    5210:	0e 94 87 31 	call	0x630e	; 0x630e <DIO_u8GetPinValue>
			/*Check if switch is pressed*/
			if(Local_u8PinState==DIO_u8Pin_LOW)
    5214:	8c 81       	ldd	r24, Y+4	; 0x04
    5216:	88 23       	and	r24, r24
    5218:	41 f5       	brne	.+80     	; 0x526a <KPD_u8GetPressedKey+0xa6>
			{
				Local_u8PressedKey=Local_u8KPDArr[Local_u8RowIdx][Local_u8ColumnIdx];
    521a:	89 81       	ldd	r24, Y+1	; 0x01
    521c:	28 2f       	mov	r18, r24
    521e:	30 e0       	ldi	r19, 0x00	; 0
    5220:	8a 81       	ldd	r24, Y+2	; 0x02
    5222:	48 2f       	mov	r20, r24
    5224:	50 e0       	ldi	r21, 0x00	; 0
    5226:	c9 01       	movw	r24, r18
    5228:	88 0f       	add	r24, r24
    522a:	99 1f       	adc	r25, r25
    522c:	82 0f       	add	r24, r18
    522e:	93 1f       	adc	r25, r19
    5230:	84 0f       	add	r24, r20
    5232:	95 1f       	adc	r25, r21
    5234:	fc 01       	movw	r30, r24
    5236:	e7 53       	subi	r30, 0x37	; 55
    5238:	ff 4f       	sbci	r31, 0xFF	; 255
    523a:	80 81       	ld	r24, Z
    523c:	8b 83       	std	Y+3, r24	; 0x03
    523e:	0f c0       	rjmp	.+30     	; 0x525e <KPD_u8GetPressedKey+0x9a>
				while(Local_u8PinState==DIO_u8Pin_LOW)
				{
					DIO_u8GetPinValue(KPD_PORT,Local_u8KPDROWArr[Local_u8RowIdx],&Local_u8PinState);
    5240:	89 81       	ldd	r24, Y+1	; 0x01
    5242:	88 2f       	mov	r24, r24
    5244:	90 e0       	ldi	r25, 0x00	; 0
    5246:	fc 01       	movw	r30, r24
    5248:	ee 53       	subi	r30, 0x3E	; 62
    524a:	ff 4f       	sbci	r31, 0xFF	; 255
    524c:	90 81       	ld	r25, Z
    524e:	9e 01       	movw	r18, r28
    5250:	2c 5f       	subi	r18, 0xFC	; 252
    5252:	3f 4f       	sbci	r19, 0xFF	; 255
    5254:	81 e0       	ldi	r24, 0x01	; 1
    5256:	69 2f       	mov	r22, r25
    5258:	a9 01       	movw	r20, r18
    525a:	0e 94 87 31 	call	0x630e	; 0x630e <DIO_u8GetPinValue>
			DIO_u8GetPinValue(KPD_PORT,Local_u8KPDROWArr[Local_u8RowIdx],&Local_u8PinState);
			/*Check if switch is pressed*/
			if(Local_u8PinState==DIO_u8Pin_LOW)
			{
				Local_u8PressedKey=Local_u8KPDArr[Local_u8RowIdx][Local_u8ColumnIdx];
				while(Local_u8PinState==DIO_u8Pin_LOW)
    525e:	8c 81       	ldd	r24, Y+4	; 0x04
    5260:	88 23       	and	r24, r24
    5262:	71 f3       	breq	.-36     	; 0x5240 <KPD_u8GetPressedKey+0x7c>
				{
					DIO_u8GetPinValue(KPD_PORT,Local_u8KPDROWArr[Local_u8RowIdx],&Local_u8PinState);
				}
				return Local_u8PressedKey;
    5264:	8b 81       	ldd	r24, Y+3	; 0x03
    5266:	8d 83       	std	Y+5, r24	; 0x05
    5268:	1c c0       	rjmp	.+56     	; 0x52a2 <KPD_u8GetPressedKey+0xde>
	for(Local_u8ColumnIdx=0; Local_u8ColumnIdx<COLUMN_NUM;Local_u8ColumnIdx++)
	{
		/*Activate current column*/
		DIO_u8SetPinValue(KPD_PORT,Local_u8KPDColumnArr[Local_u8ColumnIdx],DIO_u8Pin_LOW);

		for(Local_u8RowIdx=0;Local_u8RowIdx<ROW_NUM;Local_u8RowIdx++)
    526a:	89 81       	ldd	r24, Y+1	; 0x01
    526c:	8f 5f       	subi	r24, 0xFF	; 255
    526e:	89 83       	std	Y+1, r24	; 0x01
    5270:	89 81       	ldd	r24, Y+1	; 0x01
    5272:	84 30       	cpi	r24, 0x04	; 4
    5274:	08 f4       	brcc	.+2      	; 0x5278 <KPD_u8GetPressedKey+0xb4>
    5276:	bf cf       	rjmp	.-130    	; 0x51f6 <KPD_u8GetPressedKey+0x32>
				}
				return Local_u8PressedKey;
			}
		}
		/*Deactivate current column*/
		DIO_u8SetPinValue(KPD_PORT,Local_u8KPDColumnArr[Local_u8ColumnIdx],DIO_u8Pin_HIGH);
    5278:	8a 81       	ldd	r24, Y+2	; 0x02
    527a:	88 2f       	mov	r24, r24
    527c:	90 e0       	ldi	r25, 0x00	; 0
    527e:	fc 01       	movw	r30, r24
    5280:	ea 53       	subi	r30, 0x3A	; 58
    5282:	ff 4f       	sbci	r31, 0xFF	; 255
    5284:	90 81       	ld	r25, Z
    5286:	81 e0       	ldi	r24, 0x01	; 1
    5288:	69 2f       	mov	r22, r25
    528a:	41 e0       	ldi	r20, 0x01	; 1
    528c:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
	static u8 Local_u8KPDColumnArr[COLUMN_NUM]={KPD_COLUMN0_PIN,KPD_COLUMN1_PIN,KPD_COLUMN2_PIN,KPD_COLUMN3_PIN};
#elif COLUMN_NUM==3
	static u8 Local_u8KPDColumnArr[COLUMN_NUM]={KPD_COLUMN0_PIN,KPD_COLUMN1_PIN,KPD_COLUMN2_PIN};
#endif
	static u8 Local_u8KPDROWArr[ROW_NUM]={KPD_ROW0_PIN,KPD_ROW1_PIN,KPD_ROW2_PIN,KPD_ROW3_PIN};
	for(Local_u8ColumnIdx=0; Local_u8ColumnIdx<COLUMN_NUM;Local_u8ColumnIdx++)
    5290:	8a 81       	ldd	r24, Y+2	; 0x02
    5292:	8f 5f       	subi	r24, 0xFF	; 255
    5294:	8a 83       	std	Y+2, r24	; 0x02
    5296:	8a 81       	ldd	r24, Y+2	; 0x02
    5298:	83 30       	cpi	r24, 0x03	; 3
    529a:	08 f4       	brcc	.+2      	; 0x529e <KPD_u8GetPressedKey+0xda>
    529c:	9e cf       	rjmp	.-196    	; 0x51da <KPD_u8GetPressedKey+0x16>
			}
		}
		/*Deactivate current column*/
		DIO_u8SetPinValue(KPD_PORT,Local_u8KPDColumnArr[Local_u8ColumnIdx],DIO_u8Pin_HIGH);
	}
	return Local_u8PressedKey;
    529e:	8b 81       	ldd	r24, Y+3	; 0x03
    52a0:	8d 83       	std	Y+5, r24	; 0x05
    52a2:	8d 81       	ldd	r24, Y+5	; 0x05
}
    52a4:	0f 90       	pop	r0
    52a6:	0f 90       	pop	r0
    52a8:	0f 90       	pop	r0
    52aa:	0f 90       	pop	r0
    52ac:	0f 90       	pop	r0
    52ae:	cf 91       	pop	r28
    52b0:	df 91       	pop	r29
    52b2:	08 95       	ret

000052b4 <CLCD_void_Init>:
}

#elif CLCD_MODE==8

void CLCD_void_Init(void)
{
    52b4:	df 93       	push	r29
    52b6:	cf 93       	push	r28
    52b8:	cd b7       	in	r28, 0x3d	; 61
    52ba:	de b7       	in	r29, 0x3e	; 62
    52bc:	2e 97       	sbiw	r28, 0x0e	; 14
    52be:	0f b6       	in	r0, 0x3f	; 63
    52c0:	f8 94       	cli
    52c2:	de bf       	out	0x3e, r29	; 62
    52c4:	0f be       	out	0x3f, r0	; 63
    52c6:	cd bf       	out	0x3d, r28	; 61
    52c8:	80 e0       	ldi	r24, 0x00	; 0
    52ca:	90 e0       	ldi	r25, 0x00	; 0
    52cc:	a0 e2       	ldi	r26, 0x20	; 32
    52ce:	b2 e4       	ldi	r27, 0x42	; 66
    52d0:	8b 87       	std	Y+11, r24	; 0x0b
    52d2:	9c 87       	std	Y+12, r25	; 0x0c
    52d4:	ad 87       	std	Y+13, r26	; 0x0d
    52d6:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    52d8:	6b 85       	ldd	r22, Y+11	; 0x0b
    52da:	7c 85       	ldd	r23, Y+12	; 0x0c
    52dc:	8d 85       	ldd	r24, Y+13	; 0x0d
    52de:	9e 85       	ldd	r25, Y+14	; 0x0e
    52e0:	20 e0       	ldi	r18, 0x00	; 0
    52e2:	30 e0       	ldi	r19, 0x00	; 0
    52e4:	4a ef       	ldi	r20, 0xFA	; 250
    52e6:	54 e4       	ldi	r21, 0x44	; 68
    52e8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    52ec:	dc 01       	movw	r26, r24
    52ee:	cb 01       	movw	r24, r22
    52f0:	8f 83       	std	Y+7, r24	; 0x07
    52f2:	98 87       	std	Y+8, r25	; 0x08
    52f4:	a9 87       	std	Y+9, r26	; 0x09
    52f6:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    52f8:	6f 81       	ldd	r22, Y+7	; 0x07
    52fa:	78 85       	ldd	r23, Y+8	; 0x08
    52fc:	89 85       	ldd	r24, Y+9	; 0x09
    52fe:	9a 85       	ldd	r25, Y+10	; 0x0a
    5300:	20 e0       	ldi	r18, 0x00	; 0
    5302:	30 e0       	ldi	r19, 0x00	; 0
    5304:	40 e8       	ldi	r20, 0x80	; 128
    5306:	5f e3       	ldi	r21, 0x3F	; 63
    5308:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    530c:	88 23       	and	r24, r24
    530e:	2c f4       	brge	.+10     	; 0x531a <CLCD_void_Init+0x66>
		__ticks = 1;
    5310:	81 e0       	ldi	r24, 0x01	; 1
    5312:	90 e0       	ldi	r25, 0x00	; 0
    5314:	9e 83       	std	Y+6, r25	; 0x06
    5316:	8d 83       	std	Y+5, r24	; 0x05
    5318:	3f c0       	rjmp	.+126    	; 0x5398 <CLCD_void_Init+0xe4>
	else if (__tmp > 65535)
    531a:	6f 81       	ldd	r22, Y+7	; 0x07
    531c:	78 85       	ldd	r23, Y+8	; 0x08
    531e:	89 85       	ldd	r24, Y+9	; 0x09
    5320:	9a 85       	ldd	r25, Y+10	; 0x0a
    5322:	20 e0       	ldi	r18, 0x00	; 0
    5324:	3f ef       	ldi	r19, 0xFF	; 255
    5326:	4f e7       	ldi	r20, 0x7F	; 127
    5328:	57 e4       	ldi	r21, 0x47	; 71
    532a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    532e:	18 16       	cp	r1, r24
    5330:	4c f5       	brge	.+82     	; 0x5384 <CLCD_void_Init+0xd0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5332:	6b 85       	ldd	r22, Y+11	; 0x0b
    5334:	7c 85       	ldd	r23, Y+12	; 0x0c
    5336:	8d 85       	ldd	r24, Y+13	; 0x0d
    5338:	9e 85       	ldd	r25, Y+14	; 0x0e
    533a:	20 e0       	ldi	r18, 0x00	; 0
    533c:	30 e0       	ldi	r19, 0x00	; 0
    533e:	40 e2       	ldi	r20, 0x20	; 32
    5340:	51 e4       	ldi	r21, 0x41	; 65
    5342:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5346:	dc 01       	movw	r26, r24
    5348:	cb 01       	movw	r24, r22
    534a:	bc 01       	movw	r22, r24
    534c:	cd 01       	movw	r24, r26
    534e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5352:	dc 01       	movw	r26, r24
    5354:	cb 01       	movw	r24, r22
    5356:	9e 83       	std	Y+6, r25	; 0x06
    5358:	8d 83       	std	Y+5, r24	; 0x05
    535a:	0f c0       	rjmp	.+30     	; 0x537a <CLCD_void_Init+0xc6>
    535c:	88 ec       	ldi	r24, 0xC8	; 200
    535e:	90 e0       	ldi	r25, 0x00	; 0
    5360:	9c 83       	std	Y+4, r25	; 0x04
    5362:	8b 83       	std	Y+3, r24	; 0x03
    5364:	8b 81       	ldd	r24, Y+3	; 0x03
    5366:	9c 81       	ldd	r25, Y+4	; 0x04
    5368:	01 97       	sbiw	r24, 0x01	; 1
    536a:	f1 f7       	brne	.-4      	; 0x5368 <CLCD_void_Init+0xb4>
    536c:	9c 83       	std	Y+4, r25	; 0x04
    536e:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5370:	8d 81       	ldd	r24, Y+5	; 0x05
    5372:	9e 81       	ldd	r25, Y+6	; 0x06
    5374:	01 97       	sbiw	r24, 0x01	; 1
    5376:	9e 83       	std	Y+6, r25	; 0x06
    5378:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    537a:	8d 81       	ldd	r24, Y+5	; 0x05
    537c:	9e 81       	ldd	r25, Y+6	; 0x06
    537e:	00 97       	sbiw	r24, 0x00	; 0
    5380:	69 f7       	brne	.-38     	; 0x535c <CLCD_void_Init+0xa8>
    5382:	14 c0       	rjmp	.+40     	; 0x53ac <CLCD_void_Init+0xf8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5384:	6f 81       	ldd	r22, Y+7	; 0x07
    5386:	78 85       	ldd	r23, Y+8	; 0x08
    5388:	89 85       	ldd	r24, Y+9	; 0x09
    538a:	9a 85       	ldd	r25, Y+10	; 0x0a
    538c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5390:	dc 01       	movw	r26, r24
    5392:	cb 01       	movw	r24, r22
    5394:	9e 83       	std	Y+6, r25	; 0x06
    5396:	8d 83       	std	Y+5, r24	; 0x05
    5398:	8d 81       	ldd	r24, Y+5	; 0x05
    539a:	9e 81       	ldd	r25, Y+6	; 0x06
    539c:	9a 83       	std	Y+2, r25	; 0x02
    539e:	89 83       	std	Y+1, r24	; 0x01
    53a0:	89 81       	ldd	r24, Y+1	; 0x01
    53a2:	9a 81       	ldd	r25, Y+2	; 0x02
    53a4:	01 97       	sbiw	r24, 0x01	; 1
    53a6:	f1 f7       	brne	.-4      	; 0x53a4 <CLCD_void_Init+0xf0>
    53a8:	9a 83       	std	Y+2, r25	; 0x02
    53aa:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(40);
	/*Function set command: 2 lines and 5*8 font size*/
	CLCD_voidSendCommand(0b00111000);
    53ac:	88 e3       	ldi	r24, 0x38	; 56
    53ae:	0e 94 e8 29 	call	0x53d0	; 0x53d0 <CLCD_voidSendCommand>
	/*Display on off control: display enable , disable cursor and no blink cursor*/
	CLCD_voidSendCommand(0b00001100);
    53b2:	8c e0       	ldi	r24, 0x0C	; 12
    53b4:	0e 94 e8 29 	call	0x53d0	; 0x53d0 <CLCD_voidSendCommand>
	/*clear display*/
	CLCD_voidSendCommand(1);
    53b8:	81 e0       	ldi	r24, 0x01	; 1
    53ba:	0e 94 e8 29 	call	0x53d0	; 0x53d0 <CLCD_voidSendCommand>
}
    53be:	2e 96       	adiw	r28, 0x0e	; 14
    53c0:	0f b6       	in	r0, 0x3f	; 63
    53c2:	f8 94       	cli
    53c4:	de bf       	out	0x3e, r29	; 62
    53c6:	0f be       	out	0x3f, r0	; 63
    53c8:	cd bf       	out	0x3d, r28	; 61
    53ca:	cf 91       	pop	r28
    53cc:	df 91       	pop	r29
    53ce:	08 95       	ret

000053d0 <CLCD_voidSendCommand>:
void CLCD_voidSendCommand(u8 Copy_u8Command)
{
    53d0:	df 93       	push	r29
    53d2:	cf 93       	push	r28
    53d4:	cd b7       	in	r28, 0x3d	; 61
    53d6:	de b7       	in	r29, 0x3e	; 62
    53d8:	2f 97       	sbiw	r28, 0x0f	; 15
    53da:	0f b6       	in	r0, 0x3f	; 63
    53dc:	f8 94       	cli
    53de:	de bf       	out	0x3e, r29	; 62
    53e0:	0f be       	out	0x3f, r0	; 63
    53e2:	cd bf       	out	0x3d, r28	; 61
    53e4:	8f 87       	std	Y+15, r24	; 0x0f
	DIO_u8SetPinValue(CLCD_CTRL_PORT , CLCD_RS_PIN , DIO_u8Pin_LOW);
    53e6:	83 e0       	ldi	r24, 0x03	; 3
    53e8:	62 e0       	ldi	r22, 0x02	; 2
    53ea:	40 e0       	ldi	r20, 0x00	; 0
    53ec:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
	DIO_u8SetPinValue(CLCD_CTRL_PORT , CLCD_RW_PIN , DIO_u8Pin_LOW);
    53f0:	83 e0       	ldi	r24, 0x03	; 3
    53f2:	61 e0       	ldi	r22, 0x01	; 1
    53f4:	40 e0       	ldi	r20, 0x00	; 0
    53f6:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
	DIO_u8SetPortValue(CLCD_DATA_PORT,Copy_u8Command);
    53fa:	82 e0       	ldi	r24, 0x02	; 2
    53fc:	6f 85       	ldd	r22, Y+15	; 0x0f
    53fe:	0e 94 b4 30 	call	0x6168	; 0x6168 <DIO_u8SetPortValue>
	DIO_u8SetPinValue(CLCD_CTRL_PORT , CLCD_E_PIN , DIO_u8Pin_HIGH);
    5402:	83 e0       	ldi	r24, 0x03	; 3
    5404:	60 e0       	ldi	r22, 0x00	; 0
    5406:	41 e0       	ldi	r20, 0x01	; 1
    5408:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
    540c:	80 e0       	ldi	r24, 0x00	; 0
    540e:	90 e0       	ldi	r25, 0x00	; 0
    5410:	a0 e0       	ldi	r26, 0x00	; 0
    5412:	b0 e4       	ldi	r27, 0x40	; 64
    5414:	8b 87       	std	Y+11, r24	; 0x0b
    5416:	9c 87       	std	Y+12, r25	; 0x0c
    5418:	ad 87       	std	Y+13, r26	; 0x0d
    541a:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    541c:	6b 85       	ldd	r22, Y+11	; 0x0b
    541e:	7c 85       	ldd	r23, Y+12	; 0x0c
    5420:	8d 85       	ldd	r24, Y+13	; 0x0d
    5422:	9e 85       	ldd	r25, Y+14	; 0x0e
    5424:	20 e0       	ldi	r18, 0x00	; 0
    5426:	30 e0       	ldi	r19, 0x00	; 0
    5428:	4a ef       	ldi	r20, 0xFA	; 250
    542a:	54 e4       	ldi	r21, 0x44	; 68
    542c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5430:	dc 01       	movw	r26, r24
    5432:	cb 01       	movw	r24, r22
    5434:	8f 83       	std	Y+7, r24	; 0x07
    5436:	98 87       	std	Y+8, r25	; 0x08
    5438:	a9 87       	std	Y+9, r26	; 0x09
    543a:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    543c:	6f 81       	ldd	r22, Y+7	; 0x07
    543e:	78 85       	ldd	r23, Y+8	; 0x08
    5440:	89 85       	ldd	r24, Y+9	; 0x09
    5442:	9a 85       	ldd	r25, Y+10	; 0x0a
    5444:	20 e0       	ldi	r18, 0x00	; 0
    5446:	30 e0       	ldi	r19, 0x00	; 0
    5448:	40 e8       	ldi	r20, 0x80	; 128
    544a:	5f e3       	ldi	r21, 0x3F	; 63
    544c:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    5450:	88 23       	and	r24, r24
    5452:	2c f4       	brge	.+10     	; 0x545e <CLCD_voidSendCommand+0x8e>
		__ticks = 1;
    5454:	81 e0       	ldi	r24, 0x01	; 1
    5456:	90 e0       	ldi	r25, 0x00	; 0
    5458:	9e 83       	std	Y+6, r25	; 0x06
    545a:	8d 83       	std	Y+5, r24	; 0x05
    545c:	3f c0       	rjmp	.+126    	; 0x54dc <CLCD_voidSendCommand+0x10c>
	else if (__tmp > 65535)
    545e:	6f 81       	ldd	r22, Y+7	; 0x07
    5460:	78 85       	ldd	r23, Y+8	; 0x08
    5462:	89 85       	ldd	r24, Y+9	; 0x09
    5464:	9a 85       	ldd	r25, Y+10	; 0x0a
    5466:	20 e0       	ldi	r18, 0x00	; 0
    5468:	3f ef       	ldi	r19, 0xFF	; 255
    546a:	4f e7       	ldi	r20, 0x7F	; 127
    546c:	57 e4       	ldi	r21, 0x47	; 71
    546e:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    5472:	18 16       	cp	r1, r24
    5474:	4c f5       	brge	.+82     	; 0x54c8 <CLCD_voidSendCommand+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5476:	6b 85       	ldd	r22, Y+11	; 0x0b
    5478:	7c 85       	ldd	r23, Y+12	; 0x0c
    547a:	8d 85       	ldd	r24, Y+13	; 0x0d
    547c:	9e 85       	ldd	r25, Y+14	; 0x0e
    547e:	20 e0       	ldi	r18, 0x00	; 0
    5480:	30 e0       	ldi	r19, 0x00	; 0
    5482:	40 e2       	ldi	r20, 0x20	; 32
    5484:	51 e4       	ldi	r21, 0x41	; 65
    5486:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    548a:	dc 01       	movw	r26, r24
    548c:	cb 01       	movw	r24, r22
    548e:	bc 01       	movw	r22, r24
    5490:	cd 01       	movw	r24, r26
    5492:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5496:	dc 01       	movw	r26, r24
    5498:	cb 01       	movw	r24, r22
    549a:	9e 83       	std	Y+6, r25	; 0x06
    549c:	8d 83       	std	Y+5, r24	; 0x05
    549e:	0f c0       	rjmp	.+30     	; 0x54be <CLCD_voidSendCommand+0xee>
    54a0:	88 ec       	ldi	r24, 0xC8	; 200
    54a2:	90 e0       	ldi	r25, 0x00	; 0
    54a4:	9c 83       	std	Y+4, r25	; 0x04
    54a6:	8b 83       	std	Y+3, r24	; 0x03
    54a8:	8b 81       	ldd	r24, Y+3	; 0x03
    54aa:	9c 81       	ldd	r25, Y+4	; 0x04
    54ac:	01 97       	sbiw	r24, 0x01	; 1
    54ae:	f1 f7       	brne	.-4      	; 0x54ac <CLCD_voidSendCommand+0xdc>
    54b0:	9c 83       	std	Y+4, r25	; 0x04
    54b2:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    54b4:	8d 81       	ldd	r24, Y+5	; 0x05
    54b6:	9e 81       	ldd	r25, Y+6	; 0x06
    54b8:	01 97       	sbiw	r24, 0x01	; 1
    54ba:	9e 83       	std	Y+6, r25	; 0x06
    54bc:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    54be:	8d 81       	ldd	r24, Y+5	; 0x05
    54c0:	9e 81       	ldd	r25, Y+6	; 0x06
    54c2:	00 97       	sbiw	r24, 0x00	; 0
    54c4:	69 f7       	brne	.-38     	; 0x54a0 <CLCD_voidSendCommand+0xd0>
    54c6:	14 c0       	rjmp	.+40     	; 0x54f0 <CLCD_voidSendCommand+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    54c8:	6f 81       	ldd	r22, Y+7	; 0x07
    54ca:	78 85       	ldd	r23, Y+8	; 0x08
    54cc:	89 85       	ldd	r24, Y+9	; 0x09
    54ce:	9a 85       	ldd	r25, Y+10	; 0x0a
    54d0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    54d4:	dc 01       	movw	r26, r24
    54d6:	cb 01       	movw	r24, r22
    54d8:	9e 83       	std	Y+6, r25	; 0x06
    54da:	8d 83       	std	Y+5, r24	; 0x05
    54dc:	8d 81       	ldd	r24, Y+5	; 0x05
    54de:	9e 81       	ldd	r25, Y+6	; 0x06
    54e0:	9a 83       	std	Y+2, r25	; 0x02
    54e2:	89 83       	std	Y+1, r24	; 0x01
    54e4:	89 81       	ldd	r24, Y+1	; 0x01
    54e6:	9a 81       	ldd	r25, Y+2	; 0x02
    54e8:	01 97       	sbiw	r24, 0x01	; 1
    54ea:	f1 f7       	brne	.-4      	; 0x54e8 <CLCD_voidSendCommand+0x118>
    54ec:	9a 83       	std	Y+2, r25	; 0x02
    54ee:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	DIO_u8SetPinValue(CLCD_CTRL_PORT , CLCD_E_PIN , DIO_u8Pin_LOW);
    54f0:	83 e0       	ldi	r24, 0x03	; 3
    54f2:	60 e0       	ldi	r22, 0x00	; 0
    54f4:	40 e0       	ldi	r20, 0x00	; 0
    54f6:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
}
    54fa:	2f 96       	adiw	r28, 0x0f	; 15
    54fc:	0f b6       	in	r0, 0x3f	; 63
    54fe:	f8 94       	cli
    5500:	de bf       	out	0x3e, r29	; 62
    5502:	0f be       	out	0x3f, r0	; 63
    5504:	cd bf       	out	0x3d, r28	; 61
    5506:	cf 91       	pop	r28
    5508:	df 91       	pop	r29
    550a:	08 95       	ret

0000550c <CLCD_voidSendData>:

void CLCD_voidSendData(u8 Copy_u8Data)
{
    550c:	df 93       	push	r29
    550e:	cf 93       	push	r28
    5510:	cd b7       	in	r28, 0x3d	; 61
    5512:	de b7       	in	r29, 0x3e	; 62
    5514:	2f 97       	sbiw	r28, 0x0f	; 15
    5516:	0f b6       	in	r0, 0x3f	; 63
    5518:	f8 94       	cli
    551a:	de bf       	out	0x3e, r29	; 62
    551c:	0f be       	out	0x3f, r0	; 63
    551e:	cd bf       	out	0x3d, r28	; 61
    5520:	8f 87       	std	Y+15, r24	; 0x0f
	/*if(Local_u8StringCounter==0x10)
	{
		CLCD_voidGoToXY(1,0);
	}*/
	DIO_u8SetPinValue(CLCD_CTRL_PORT , CLCD_RS_PIN , DIO_u8Pin_HIGH);
    5522:	83 e0       	ldi	r24, 0x03	; 3
    5524:	62 e0       	ldi	r22, 0x02	; 2
    5526:	41 e0       	ldi	r20, 0x01	; 1
    5528:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
	DIO_u8SetPinValue(CLCD_CTRL_PORT , CLCD_RW_PIN , DIO_u8Pin_LOW);
    552c:	83 e0       	ldi	r24, 0x03	; 3
    552e:	61 e0       	ldi	r22, 0x01	; 1
    5530:	40 e0       	ldi	r20, 0x00	; 0
    5532:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
	DIO_u8SetPortValue(CLCD_DATA_PORT,Copy_u8Data);
    5536:	82 e0       	ldi	r24, 0x02	; 2
    5538:	6f 85       	ldd	r22, Y+15	; 0x0f
    553a:	0e 94 b4 30 	call	0x6168	; 0x6168 <DIO_u8SetPortValue>
	DIO_u8SetPinValue(CLCD_CTRL_PORT , CLCD_E_PIN , DIO_u8Pin_HIGH);
    553e:	83 e0       	ldi	r24, 0x03	; 3
    5540:	60 e0       	ldi	r22, 0x00	; 0
    5542:	41 e0       	ldi	r20, 0x01	; 1
    5544:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
    5548:	80 e0       	ldi	r24, 0x00	; 0
    554a:	90 e0       	ldi	r25, 0x00	; 0
    554c:	a0 e0       	ldi	r26, 0x00	; 0
    554e:	b0 e4       	ldi	r27, 0x40	; 64
    5550:	8b 87       	std	Y+11, r24	; 0x0b
    5552:	9c 87       	std	Y+12, r25	; 0x0c
    5554:	ad 87       	std	Y+13, r26	; 0x0d
    5556:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5558:	6b 85       	ldd	r22, Y+11	; 0x0b
    555a:	7c 85       	ldd	r23, Y+12	; 0x0c
    555c:	8d 85       	ldd	r24, Y+13	; 0x0d
    555e:	9e 85       	ldd	r25, Y+14	; 0x0e
    5560:	20 e0       	ldi	r18, 0x00	; 0
    5562:	30 e0       	ldi	r19, 0x00	; 0
    5564:	4a ef       	ldi	r20, 0xFA	; 250
    5566:	54 e4       	ldi	r21, 0x44	; 68
    5568:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    556c:	dc 01       	movw	r26, r24
    556e:	cb 01       	movw	r24, r22
    5570:	8f 83       	std	Y+7, r24	; 0x07
    5572:	98 87       	std	Y+8, r25	; 0x08
    5574:	a9 87       	std	Y+9, r26	; 0x09
    5576:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    5578:	6f 81       	ldd	r22, Y+7	; 0x07
    557a:	78 85       	ldd	r23, Y+8	; 0x08
    557c:	89 85       	ldd	r24, Y+9	; 0x09
    557e:	9a 85       	ldd	r25, Y+10	; 0x0a
    5580:	20 e0       	ldi	r18, 0x00	; 0
    5582:	30 e0       	ldi	r19, 0x00	; 0
    5584:	40 e8       	ldi	r20, 0x80	; 128
    5586:	5f e3       	ldi	r21, 0x3F	; 63
    5588:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    558c:	88 23       	and	r24, r24
    558e:	2c f4       	brge	.+10     	; 0x559a <CLCD_voidSendData+0x8e>
		__ticks = 1;
    5590:	81 e0       	ldi	r24, 0x01	; 1
    5592:	90 e0       	ldi	r25, 0x00	; 0
    5594:	9e 83       	std	Y+6, r25	; 0x06
    5596:	8d 83       	std	Y+5, r24	; 0x05
    5598:	3f c0       	rjmp	.+126    	; 0x5618 <CLCD_voidSendData+0x10c>
	else if (__tmp > 65535)
    559a:	6f 81       	ldd	r22, Y+7	; 0x07
    559c:	78 85       	ldd	r23, Y+8	; 0x08
    559e:	89 85       	ldd	r24, Y+9	; 0x09
    55a0:	9a 85       	ldd	r25, Y+10	; 0x0a
    55a2:	20 e0       	ldi	r18, 0x00	; 0
    55a4:	3f ef       	ldi	r19, 0xFF	; 255
    55a6:	4f e7       	ldi	r20, 0x7F	; 127
    55a8:	57 e4       	ldi	r21, 0x47	; 71
    55aa:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    55ae:	18 16       	cp	r1, r24
    55b0:	4c f5       	brge	.+82     	; 0x5604 <CLCD_voidSendData+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    55b2:	6b 85       	ldd	r22, Y+11	; 0x0b
    55b4:	7c 85       	ldd	r23, Y+12	; 0x0c
    55b6:	8d 85       	ldd	r24, Y+13	; 0x0d
    55b8:	9e 85       	ldd	r25, Y+14	; 0x0e
    55ba:	20 e0       	ldi	r18, 0x00	; 0
    55bc:	30 e0       	ldi	r19, 0x00	; 0
    55be:	40 e2       	ldi	r20, 0x20	; 32
    55c0:	51 e4       	ldi	r21, 0x41	; 65
    55c2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    55c6:	dc 01       	movw	r26, r24
    55c8:	cb 01       	movw	r24, r22
    55ca:	bc 01       	movw	r22, r24
    55cc:	cd 01       	movw	r24, r26
    55ce:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    55d2:	dc 01       	movw	r26, r24
    55d4:	cb 01       	movw	r24, r22
    55d6:	9e 83       	std	Y+6, r25	; 0x06
    55d8:	8d 83       	std	Y+5, r24	; 0x05
    55da:	0f c0       	rjmp	.+30     	; 0x55fa <CLCD_voidSendData+0xee>
    55dc:	88 ec       	ldi	r24, 0xC8	; 200
    55de:	90 e0       	ldi	r25, 0x00	; 0
    55e0:	9c 83       	std	Y+4, r25	; 0x04
    55e2:	8b 83       	std	Y+3, r24	; 0x03
    55e4:	8b 81       	ldd	r24, Y+3	; 0x03
    55e6:	9c 81       	ldd	r25, Y+4	; 0x04
    55e8:	01 97       	sbiw	r24, 0x01	; 1
    55ea:	f1 f7       	brne	.-4      	; 0x55e8 <CLCD_voidSendData+0xdc>
    55ec:	9c 83       	std	Y+4, r25	; 0x04
    55ee:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    55f0:	8d 81       	ldd	r24, Y+5	; 0x05
    55f2:	9e 81       	ldd	r25, Y+6	; 0x06
    55f4:	01 97       	sbiw	r24, 0x01	; 1
    55f6:	9e 83       	std	Y+6, r25	; 0x06
    55f8:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    55fa:	8d 81       	ldd	r24, Y+5	; 0x05
    55fc:	9e 81       	ldd	r25, Y+6	; 0x06
    55fe:	00 97       	sbiw	r24, 0x00	; 0
    5600:	69 f7       	brne	.-38     	; 0x55dc <CLCD_voidSendData+0xd0>
    5602:	14 c0       	rjmp	.+40     	; 0x562c <CLCD_voidSendData+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5604:	6f 81       	ldd	r22, Y+7	; 0x07
    5606:	78 85       	ldd	r23, Y+8	; 0x08
    5608:	89 85       	ldd	r24, Y+9	; 0x09
    560a:	9a 85       	ldd	r25, Y+10	; 0x0a
    560c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5610:	dc 01       	movw	r26, r24
    5612:	cb 01       	movw	r24, r22
    5614:	9e 83       	std	Y+6, r25	; 0x06
    5616:	8d 83       	std	Y+5, r24	; 0x05
    5618:	8d 81       	ldd	r24, Y+5	; 0x05
    561a:	9e 81       	ldd	r25, Y+6	; 0x06
    561c:	9a 83       	std	Y+2, r25	; 0x02
    561e:	89 83       	std	Y+1, r24	; 0x01
    5620:	89 81       	ldd	r24, Y+1	; 0x01
    5622:	9a 81       	ldd	r25, Y+2	; 0x02
    5624:	01 97       	sbiw	r24, 0x01	; 1
    5626:	f1 f7       	brne	.-4      	; 0x5624 <CLCD_voidSendData+0x118>
    5628:	9a 83       	std	Y+2, r25	; 0x02
    562a:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	DIO_u8SetPinValue(CLCD_CTRL_PORT , CLCD_E_PIN , DIO_u8Pin_LOW);
    562c:	83 e0       	ldi	r24, 0x03	; 3
    562e:	60 e0       	ldi	r22, 0x00	; 0
    5630:	40 e0       	ldi	r20, 0x00	; 0
    5632:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
	//Local_u8StringCounter++;
}
    5636:	2f 96       	adiw	r28, 0x0f	; 15
    5638:	0f b6       	in	r0, 0x3f	; 63
    563a:	f8 94       	cli
    563c:	de bf       	out	0x3e, r29	; 62
    563e:	0f be       	out	0x3f, r0	; 63
    5640:	cd bf       	out	0x3d, r28	; 61
    5642:	cf 91       	pop	r28
    5644:	df 91       	pop	r29
    5646:	08 95       	ret

00005648 <CLCD_voidSendString>:

#endif
void CLCD_voidSendString(const char *Copy_Pcstring)
{
    5648:	df 93       	push	r29
    564a:	cf 93       	push	r28
    564c:	00 d0       	rcall	.+0      	; 0x564e <CLCD_voidSendString+0x6>
    564e:	00 d0       	rcall	.+0      	; 0x5650 <CLCD_voidSendString+0x8>
    5650:	00 d0       	rcall	.+0      	; 0x5652 <CLCD_voidSendString+0xa>
    5652:	cd b7       	in	r28, 0x3d	; 61
    5654:	de b7       	in	r29, 0x3e	; 62
    5656:	9e 83       	std	Y+6, r25	; 0x06
    5658:	8d 83       	std	Y+5, r24	; 0x05
	u32 Local_u8Counter=0;
    565a:	19 82       	std	Y+1, r1	; 0x01
    565c:	1a 82       	std	Y+2, r1	; 0x02
    565e:	1b 82       	std	Y+3, r1	; 0x03
    5660:	1c 82       	std	Y+4, r1	; 0x04
    5662:	15 c0       	rjmp	.+42     	; 0x568e <CLCD_voidSendString+0x46>
	while(Copy_Pcstring[Local_u8Counter] != '\0')
	{
		CLCD_voidSendData(Copy_Pcstring[Local_u8Counter]);
    5664:	29 81       	ldd	r18, Y+1	; 0x01
    5666:	3a 81       	ldd	r19, Y+2	; 0x02
    5668:	8d 81       	ldd	r24, Y+5	; 0x05
    566a:	9e 81       	ldd	r25, Y+6	; 0x06
    566c:	fc 01       	movw	r30, r24
    566e:	e2 0f       	add	r30, r18
    5670:	f3 1f       	adc	r31, r19
    5672:	80 81       	ld	r24, Z
    5674:	0e 94 86 2a 	call	0x550c	; 0x550c <CLCD_voidSendData>
		Local_u8Counter++;
    5678:	89 81       	ldd	r24, Y+1	; 0x01
    567a:	9a 81       	ldd	r25, Y+2	; 0x02
    567c:	ab 81       	ldd	r26, Y+3	; 0x03
    567e:	bc 81       	ldd	r27, Y+4	; 0x04
    5680:	01 96       	adiw	r24, 0x01	; 1
    5682:	a1 1d       	adc	r26, r1
    5684:	b1 1d       	adc	r27, r1
    5686:	89 83       	std	Y+1, r24	; 0x01
    5688:	9a 83       	std	Y+2, r25	; 0x02
    568a:	ab 83       	std	Y+3, r26	; 0x03
    568c:	bc 83       	std	Y+4, r27	; 0x04

#endif
void CLCD_voidSendString(const char *Copy_Pcstring)
{
	u32 Local_u8Counter=0;
	while(Copy_Pcstring[Local_u8Counter] != '\0')
    568e:	29 81       	ldd	r18, Y+1	; 0x01
    5690:	3a 81       	ldd	r19, Y+2	; 0x02
    5692:	8d 81       	ldd	r24, Y+5	; 0x05
    5694:	9e 81       	ldd	r25, Y+6	; 0x06
    5696:	fc 01       	movw	r30, r24
    5698:	e2 0f       	add	r30, r18
    569a:	f3 1f       	adc	r31, r19
    569c:	80 81       	ld	r24, Z
    569e:	88 23       	and	r24, r24
    56a0:	09 f7       	brne	.-62     	; 0x5664 <CLCD_voidSendString+0x1c>
	{
		CLCD_voidSendData(Copy_Pcstring[Local_u8Counter]);
		Local_u8Counter++;
	}
}
    56a2:	26 96       	adiw	r28, 0x06	; 6
    56a4:	0f b6       	in	r0, 0x3f	; 63
    56a6:	f8 94       	cli
    56a8:	de bf       	out	0x3e, r29	; 62
    56aa:	0f be       	out	0x3f, r0	; 63
    56ac:	cd bf       	out	0x3d, r28	; 61
    56ae:	cf 91       	pop	r28
    56b0:	df 91       	pop	r29
    56b2:	08 95       	ret

000056b4 <CLCD_voidGoToXY>:

void CLCD_voidGoToXY(u8 copy_u8XPos, u8 copy_u8YPos)
{
    56b4:	df 93       	push	r29
    56b6:	cf 93       	push	r28
    56b8:	00 d0       	rcall	.+0      	; 0x56ba <CLCD_voidGoToXY+0x6>
    56ba:	0f 92       	push	r0
    56bc:	cd b7       	in	r28, 0x3d	; 61
    56be:	de b7       	in	r29, 0x3e	; 62
    56c0:	8a 83       	std	Y+2, r24	; 0x02
    56c2:	6b 83       	std	Y+3, r22	; 0x03
	//Local_u8StringCounter=copy_u8YPos;
	u8 Local_u8Address;
	if(copy_u8XPos==0)
    56c4:	8a 81       	ldd	r24, Y+2	; 0x02
    56c6:	88 23       	and	r24, r24
    56c8:	19 f4       	brne	.+6      	; 0x56d0 <CLCD_voidGoToXY+0x1c>
	{
		Local_u8Address=copy_u8YPos;
    56ca:	8b 81       	ldd	r24, Y+3	; 0x03
    56cc:	89 83       	std	Y+1, r24	; 0x01
    56ce:	06 c0       	rjmp	.+12     	; 0x56dc <CLCD_voidGoToXY+0x28>
	}
	else if(copy_u8XPos==1)
    56d0:	8a 81       	ldd	r24, Y+2	; 0x02
    56d2:	81 30       	cpi	r24, 0x01	; 1
    56d4:	19 f4       	brne	.+6      	; 0x56dc <CLCD_voidGoToXY+0x28>
	{
		Local_u8Address=copy_u8YPos+0x40;
    56d6:	8b 81       	ldd	r24, Y+3	; 0x03
    56d8:	80 5c       	subi	r24, 0xC0	; 192
    56da:	89 83       	std	Y+1, r24	; 0x01
	}
	CLCD_voidSendCommand(0x80+Local_u8Address);
    56dc:	89 81       	ldd	r24, Y+1	; 0x01
    56de:	80 58       	subi	r24, 0x80	; 128
    56e0:	0e 94 e8 29 	call	0x53d0	; 0x53d0 <CLCD_voidSendCommand>
}
    56e4:	0f 90       	pop	r0
    56e6:	0f 90       	pop	r0
    56e8:	0f 90       	pop	r0
    56ea:	cf 91       	pop	r28
    56ec:	df 91       	pop	r29
    56ee:	08 95       	ret

000056f0 <CLCD_voidCLR>:

void CLCD_voidCLR(void)
{
    56f0:	df 93       	push	r29
    56f2:	cf 93       	push	r28
    56f4:	cd b7       	in	r28, 0x3d	; 61
    56f6:	de b7       	in	r29, 0x3e	; 62
	CLCD_voidSendCommand(1);
    56f8:	81 e0       	ldi	r24, 0x01	; 1
    56fa:	0e 94 e8 29 	call	0x53d0	; 0x53d0 <CLCD_voidSendCommand>
	//Local_u8StringCounter=0;
}
    56fe:	cf 91       	pop	r28
    5700:	df 91       	pop	r29
    5702:	08 95       	ret

00005704 <CLCD_void_WriteSpecialCharacter>:

void CLCD_void_WriteSpecialCharacter(u8* Copy_pu8Pattern , u8 Copy_u8PatternNumber , u8 Copy_u8XPos , u8 Copy_u8YPos)
{
    5704:	df 93       	push	r29
    5706:	cf 93       	push	r28
    5708:	cd b7       	in	r28, 0x3d	; 61
    570a:	de b7       	in	r29, 0x3e	; 62
    570c:	27 97       	sbiw	r28, 0x07	; 7
    570e:	0f b6       	in	r0, 0x3f	; 63
    5710:	f8 94       	cli
    5712:	de bf       	out	0x3e, r29	; 62
    5714:	0f be       	out	0x3f, r0	; 63
    5716:	cd bf       	out	0x3d, r28	; 61
    5718:	9c 83       	std	Y+4, r25	; 0x04
    571a:	8b 83       	std	Y+3, r24	; 0x03
    571c:	6d 83       	std	Y+5, r22	; 0x05
    571e:	4e 83       	std	Y+6, r20	; 0x06
    5720:	2f 83       	std	Y+7, r18	; 0x07
	u8 Local_u8Counter=0;
    5722:	1a 82       	std	Y+2, r1	; 0x02
	u8 Local_u8CGRAMAddress=Copy_u8PatternNumber*8;
    5724:	8d 81       	ldd	r24, Y+5	; 0x05
    5726:	88 2f       	mov	r24, r24
    5728:	90 e0       	ldi	r25, 0x00	; 0
    572a:	88 0f       	add	r24, r24
    572c:	99 1f       	adc	r25, r25
    572e:	88 0f       	add	r24, r24
    5730:	99 1f       	adc	r25, r25
    5732:	88 0f       	add	r24, r24
    5734:	99 1f       	adc	r25, r25
    5736:	89 83       	std	Y+1, r24	; 0x01
	CLCD_voidSendCommand(Local_u8CGRAMAddress+0x40);
    5738:	89 81       	ldd	r24, Y+1	; 0x01
    573a:	80 5c       	subi	r24, 0xC0	; 192
    573c:	0e 94 e8 29 	call	0x53d0	; 0x53d0 <CLCD_voidSendCommand>
	for(Local_u8Counter=0;Local_u8Counter<8;Local_u8Counter++)
    5740:	1a 82       	std	Y+2, r1	; 0x02
    5742:	0e c0       	rjmp	.+28     	; 0x5760 <CLCD_void_WriteSpecialCharacter+0x5c>
	{
		CLCD_voidSendData(Copy_pu8Pattern[Local_u8Counter]);
    5744:	8a 81       	ldd	r24, Y+2	; 0x02
    5746:	28 2f       	mov	r18, r24
    5748:	30 e0       	ldi	r19, 0x00	; 0
    574a:	8b 81       	ldd	r24, Y+3	; 0x03
    574c:	9c 81       	ldd	r25, Y+4	; 0x04
    574e:	fc 01       	movw	r30, r24
    5750:	e2 0f       	add	r30, r18
    5752:	f3 1f       	adc	r31, r19
    5754:	80 81       	ld	r24, Z
    5756:	0e 94 86 2a 	call	0x550c	; 0x550c <CLCD_voidSendData>
void CLCD_void_WriteSpecialCharacter(u8* Copy_pu8Pattern , u8 Copy_u8PatternNumber , u8 Copy_u8XPos , u8 Copy_u8YPos)
{
	u8 Local_u8Counter=0;
	u8 Local_u8CGRAMAddress=Copy_u8PatternNumber*8;
	CLCD_voidSendCommand(Local_u8CGRAMAddress+0x40);
	for(Local_u8Counter=0;Local_u8Counter<8;Local_u8Counter++)
    575a:	8a 81       	ldd	r24, Y+2	; 0x02
    575c:	8f 5f       	subi	r24, 0xFF	; 255
    575e:	8a 83       	std	Y+2, r24	; 0x02
    5760:	8a 81       	ldd	r24, Y+2	; 0x02
    5762:	88 30       	cpi	r24, 0x08	; 8
    5764:	78 f3       	brcs	.-34     	; 0x5744 <CLCD_void_WriteSpecialCharacter+0x40>
	{
		CLCD_voidSendData(Copy_pu8Pattern[Local_u8Counter]);
	}
	CLCD_voidGoToXY(Copy_u8XPos,Copy_u8YPos);
    5766:	8e 81       	ldd	r24, Y+6	; 0x06
    5768:	6f 81       	ldd	r22, Y+7	; 0x07
    576a:	0e 94 5a 2b 	call	0x56b4	; 0x56b4 <CLCD_voidGoToXY>
	CLCD_voidSendData(Copy_u8PatternNumber);
    576e:	8d 81       	ldd	r24, Y+5	; 0x05
    5770:	0e 94 86 2a 	call	0x550c	; 0x550c <CLCD_voidSendData>
}
    5774:	27 96       	adiw	r28, 0x07	; 7
    5776:	0f b6       	in	r0, 0x3f	; 63
    5778:	f8 94       	cli
    577a:	de bf       	out	0x3e, r29	; 62
    577c:	0f be       	out	0x3f, r0	; 63
    577e:	cd bf       	out	0x3d, r28	; 61
    5780:	cf 91       	pop	r28
    5782:	df 91       	pop	r29
    5784:	08 95       	ret

00005786 <CLCD_void_SendNumber>:

void CLCD_void_SendNumber(s32 Copy_s32Number)
{
    5786:	df 93       	push	r29
    5788:	cf 93       	push	r28
    578a:	cd b7       	in	r28, 0x3d	; 61
    578c:	de b7       	in	r29, 0x3e	; 62
    578e:	6f 97       	sbiw	r28, 0x1f	; 31
    5790:	0f b6       	in	r0, 0x3f	; 63
    5792:	f8 94       	cli
    5794:	de bf       	out	0x3e, r29	; 62
    5796:	0f be       	out	0x3f, r0	; 63
    5798:	cd bf       	out	0x3d, r28	; 61
    579a:	6c 8f       	std	Y+28, r22	; 0x1c
    579c:	7d 8f       	std	Y+29, r23	; 0x1d
    579e:	8e 8f       	std	Y+30, r24	; 0x1e
    57a0:	9f 8f       	std	Y+31, r25	; 0x1f
	s8 Local_u8String[20];
	u8 Local_u8NumLength=0,Local_u8Rem,Local_u8Counter;
    57a2:	1f 82       	std	Y+7, r1	; 0x07
	u32 Local_u32Num=Copy_s32Number;
    57a4:	8c 8d       	ldd	r24, Y+28	; 0x1c
    57a6:	9d 8d       	ldd	r25, Y+29	; 0x1d
    57a8:	ae 8d       	ldd	r26, Y+30	; 0x1e
    57aa:	bf 8d       	ldd	r27, Y+31	; 0x1f
    57ac:	89 83       	std	Y+1, r24	; 0x01
    57ae:	9a 83       	std	Y+2, r25	; 0x02
    57b0:	ab 83       	std	Y+3, r26	; 0x03
    57b2:	bc 83       	std	Y+4, r27	; 0x04
	if(Copy_s32Number==0)
    57b4:	8c 8d       	ldd	r24, Y+28	; 0x1c
    57b6:	9d 8d       	ldd	r25, Y+29	; 0x1d
    57b8:	ae 8d       	ldd	r26, Y+30	; 0x1e
    57ba:	bf 8d       	ldd	r27, Y+31	; 0x1f
    57bc:	00 97       	sbiw	r24, 0x00	; 0
    57be:	a1 05       	cpc	r26, r1
    57c0:	b1 05       	cpc	r27, r1
    57c2:	21 f4       	brne	.+8      	; 0x57cc <CLCD_void_SendNumber+0x46>
	{
		Local_u8String[0]='0';
    57c4:	80 e3       	ldi	r24, 0x30	; 48
    57c6:	88 87       	std	Y+8, r24	; 0x08
		Local_u8String[1]='\0';
    57c8:	19 86       	std	Y+9, r1	; 0x09
    57ca:	7c c0       	rjmp	.+248    	; 0x58c4 <CLCD_void_SendNumber+0x13e>
	}
	else
	{
		if(Copy_s32Number<0)
    57cc:	8c 8d       	ldd	r24, Y+28	; 0x1c
    57ce:	9d 8d       	ldd	r25, Y+29	; 0x1d
    57d0:	ae 8d       	ldd	r26, Y+30	; 0x1e
    57d2:	bf 8d       	ldd	r27, Y+31	; 0x1f
    57d4:	bb 23       	and	r27, r27
    57d6:	44 f5       	brge	.+80     	; 0x5828 <CLCD_void_SendNumber+0xa2>
		{
			CLCD_voidSendData('-');
    57d8:	8d e2       	ldi	r24, 0x2D	; 45
    57da:	0e 94 86 2a 	call	0x550c	; 0x550c <CLCD_voidSendData>
			Copy_s32Number*=-1;
    57de:	8c 8d       	ldd	r24, Y+28	; 0x1c
    57e0:	9d 8d       	ldd	r25, Y+29	; 0x1d
    57e2:	ae 8d       	ldd	r26, Y+30	; 0x1e
    57e4:	bf 8d       	ldd	r27, Y+31	; 0x1f
    57e6:	b0 95       	com	r27
    57e8:	a0 95       	com	r26
    57ea:	90 95       	com	r25
    57ec:	81 95       	neg	r24
    57ee:	9f 4f       	sbci	r25, 0xFF	; 255
    57f0:	af 4f       	sbci	r26, 0xFF	; 255
    57f2:	bf 4f       	sbci	r27, 0xFF	; 255
    57f4:	8c 8f       	std	Y+28, r24	; 0x1c
    57f6:	9d 8f       	std	Y+29, r25	; 0x1d
    57f8:	ae 8f       	std	Y+30, r26	; 0x1e
    57fa:	bf 8f       	std	Y+31, r27	; 0x1f
    57fc:	15 c0       	rjmp	.+42     	; 0x5828 <CLCD_void_SendNumber+0xa2>
		}
		while(Local_u32Num!=0)
		{
			Local_u8NumLength++;
    57fe:	8f 81       	ldd	r24, Y+7	; 0x07
    5800:	8f 5f       	subi	r24, 0xFF	; 255
    5802:	8f 83       	std	Y+7, r24	; 0x07
			Local_u32Num/=10;
    5804:	89 81       	ldd	r24, Y+1	; 0x01
    5806:	9a 81       	ldd	r25, Y+2	; 0x02
    5808:	ab 81       	ldd	r26, Y+3	; 0x03
    580a:	bc 81       	ldd	r27, Y+4	; 0x04
    580c:	2a e0       	ldi	r18, 0x0A	; 10
    580e:	30 e0       	ldi	r19, 0x00	; 0
    5810:	40 e0       	ldi	r20, 0x00	; 0
    5812:	50 e0       	ldi	r21, 0x00	; 0
    5814:	bc 01       	movw	r22, r24
    5816:	cd 01       	movw	r24, r26
    5818:	0e 94 b1 35 	call	0x6b62	; 0x6b62 <__udivmodsi4>
    581c:	da 01       	movw	r26, r20
    581e:	c9 01       	movw	r24, r18
    5820:	89 83       	std	Y+1, r24	; 0x01
    5822:	9a 83       	std	Y+2, r25	; 0x02
    5824:	ab 83       	std	Y+3, r26	; 0x03
    5826:	bc 83       	std	Y+4, r27	; 0x04
		if(Copy_s32Number<0)
		{
			CLCD_voidSendData('-');
			Copy_s32Number*=-1;
		}
		while(Local_u32Num!=0)
    5828:	89 81       	ldd	r24, Y+1	; 0x01
    582a:	9a 81       	ldd	r25, Y+2	; 0x02
    582c:	ab 81       	ldd	r26, Y+3	; 0x03
    582e:	bc 81       	ldd	r27, Y+4	; 0x04
    5830:	00 97       	sbiw	r24, 0x00	; 0
    5832:	a1 05       	cpc	r26, r1
    5834:	b1 05       	cpc	r27, r1
    5836:	19 f7       	brne	.-58     	; 0x57fe <CLCD_void_SendNumber+0x78>
		{
			Local_u8NumLength++;
			Local_u32Num/=10;
		}
		for(Local_u8Counter=0;Local_u8Counter<Local_u8NumLength;Local_u8Counter++)
    5838:	1d 82       	std	Y+5, r1	; 0x05
    583a:	37 c0       	rjmp	.+110    	; 0x58aa <CLCD_void_SendNumber+0x124>
		{
			Local_u8Rem=Copy_s32Number%10;
    583c:	8c 8d       	ldd	r24, Y+28	; 0x1c
    583e:	9d 8d       	ldd	r25, Y+29	; 0x1d
    5840:	ae 8d       	ldd	r26, Y+30	; 0x1e
    5842:	bf 8d       	ldd	r27, Y+31	; 0x1f
    5844:	2a e0       	ldi	r18, 0x0A	; 10
    5846:	30 e0       	ldi	r19, 0x00	; 0
    5848:	40 e0       	ldi	r20, 0x00	; 0
    584a:	50 e0       	ldi	r21, 0x00	; 0
    584c:	bc 01       	movw	r22, r24
    584e:	cd 01       	movw	r24, r26
    5850:	0e 94 d3 35 	call	0x6ba6	; 0x6ba6 <__divmodsi4>
    5854:	dc 01       	movw	r26, r24
    5856:	cb 01       	movw	r24, r22
    5858:	8e 83       	std	Y+6, r24	; 0x06
			Copy_s32Number/=10;
    585a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    585c:	9d 8d       	ldd	r25, Y+29	; 0x1d
    585e:	ae 8d       	ldd	r26, Y+30	; 0x1e
    5860:	bf 8d       	ldd	r27, Y+31	; 0x1f
    5862:	2a e0       	ldi	r18, 0x0A	; 10
    5864:	30 e0       	ldi	r19, 0x00	; 0
    5866:	40 e0       	ldi	r20, 0x00	; 0
    5868:	50 e0       	ldi	r21, 0x00	; 0
    586a:	bc 01       	movw	r22, r24
    586c:	cd 01       	movw	r24, r26
    586e:	0e 94 d3 35 	call	0x6ba6	; 0x6ba6 <__divmodsi4>
    5872:	da 01       	movw	r26, r20
    5874:	c9 01       	movw	r24, r18
    5876:	8c 8f       	std	Y+28, r24	; 0x1c
    5878:	9d 8f       	std	Y+29, r25	; 0x1d
    587a:	ae 8f       	std	Y+30, r26	; 0x1e
    587c:	bf 8f       	std	Y+31, r27	; 0x1f
			Local_u8String[Local_u8NumLength-(Local_u8Counter+1)]=Local_u8Rem+'0';
    587e:	8f 81       	ldd	r24, Y+7	; 0x07
    5880:	28 2f       	mov	r18, r24
    5882:	30 e0       	ldi	r19, 0x00	; 0
    5884:	8d 81       	ldd	r24, Y+5	; 0x05
    5886:	88 2f       	mov	r24, r24
    5888:	90 e0       	ldi	r25, 0x00	; 0
    588a:	80 95       	com	r24
    588c:	90 95       	com	r25
    588e:	28 0f       	add	r18, r24
    5890:	39 1f       	adc	r19, r25
    5892:	8e 81       	ldd	r24, Y+6	; 0x06
    5894:	80 5d       	subi	r24, 0xD0	; 208
    5896:	48 2f       	mov	r20, r24
    5898:	ce 01       	movw	r24, r28
    589a:	08 96       	adiw	r24, 0x08	; 8
    589c:	fc 01       	movw	r30, r24
    589e:	e2 0f       	add	r30, r18
    58a0:	f3 1f       	adc	r31, r19
    58a2:	40 83       	st	Z, r20
		while(Local_u32Num!=0)
		{
			Local_u8NumLength++;
			Local_u32Num/=10;
		}
		for(Local_u8Counter=0;Local_u8Counter<Local_u8NumLength;Local_u8Counter++)
    58a4:	8d 81       	ldd	r24, Y+5	; 0x05
    58a6:	8f 5f       	subi	r24, 0xFF	; 255
    58a8:	8d 83       	std	Y+5, r24	; 0x05
    58aa:	9d 81       	ldd	r25, Y+5	; 0x05
    58ac:	8f 81       	ldd	r24, Y+7	; 0x07
    58ae:	98 17       	cp	r25, r24
    58b0:	28 f2       	brcs	.-118    	; 0x583c <CLCD_void_SendNumber+0xb6>
		{
			Local_u8Rem=Copy_s32Number%10;
			Copy_s32Number/=10;
			Local_u8String[Local_u8NumLength-(Local_u8Counter+1)]=Local_u8Rem+'0';
		}
		Local_u8String[Local_u8NumLength]='\0';
    58b2:	8f 81       	ldd	r24, Y+7	; 0x07
    58b4:	28 2f       	mov	r18, r24
    58b6:	30 e0       	ldi	r19, 0x00	; 0
    58b8:	ce 01       	movw	r24, r28
    58ba:	08 96       	adiw	r24, 0x08	; 8
    58bc:	fc 01       	movw	r30, r24
    58be:	e2 0f       	add	r30, r18
    58c0:	f3 1f       	adc	r31, r19
    58c2:	10 82       	st	Z, r1
	}
	CLCD_voidSendString(Local_u8String);
    58c4:	ce 01       	movw	r24, r28
    58c6:	08 96       	adiw	r24, 0x08	; 8
    58c8:	0e 94 24 2b 	call	0x5648	; 0x5648 <CLCD_voidSendString>
}
    58cc:	6f 96       	adiw	r28, 0x1f	; 31
    58ce:	0f b6       	in	r0, 0x3f	; 63
    58d0:	f8 94       	cli
    58d2:	de bf       	out	0x3e, r29	; 62
    58d4:	0f be       	out	0x3f, r0	; 63
    58d6:	cd bf       	out	0x3d, r28	; 61
    58d8:	cf 91       	pop	r28
    58da:	df 91       	pop	r29
    58dc:	08 95       	ret

000058de <TIMER0_voidInit>:
#include "TIMER_interface.h"
#include "TIMER_private.h"
#include "TIMER_register.h"

void TIMER0_voidInit(void)
{
    58de:	df 93       	push	r29
    58e0:	cf 93       	push	r28
    58e2:	cd b7       	in	r28, 0x3d	; 61
    58e4:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(TCCR0,TCCR0_WGM01);
	CLR_BIT(TCCR0,TCCR0_WGM00);
	/*Output Compare Match Interrupt Enable*/
	SET_BIT(TIMSK,TIMSK_OCIE0);
#elif TIMER0_GENERATION_MODE == TIMER0_FAST_PWM_MODE
	SET_BIT(TCCR0,TCCR0_WGM01);
    58e6:	a3 e5       	ldi	r26, 0x53	; 83
    58e8:	b0 e0       	ldi	r27, 0x00	; 0
    58ea:	e3 e5       	ldi	r30, 0x53	; 83
    58ec:	f0 e0       	ldi	r31, 0x00	; 0
    58ee:	80 81       	ld	r24, Z
    58f0:	88 60       	ori	r24, 0x08	; 8
    58f2:	8c 93       	st	X, r24
	SET_BIT(TCCR0,TCCR0_WGM00);
    58f4:	a3 e5       	ldi	r26, 0x53	; 83
    58f6:	b0 e0       	ldi	r27, 0x00	; 0
    58f8:	e3 e5       	ldi	r30, 0x53	; 83
    58fa:	f0 e0       	ldi	r31, 0x00	; 0
    58fc:	80 81       	ld	r24, Z
    58fe:	80 64       	ori	r24, 0x40	; 64
    5900:	8c 93       	st	X, r24
#else
#error "Wrong Generation mode"
#endif
	/*Compare match output mode*/
	TCCR0&=COMP_OPMODE_MASK;
    5902:	a3 e5       	ldi	r26, 0x53	; 83
    5904:	b0 e0       	ldi	r27, 0x00	; 0
    5906:	e3 e5       	ldi	r30, 0x53	; 83
    5908:	f0 e0       	ldi	r31, 0x00	; 0
    590a:	80 81       	ld	r24, Z
    590c:	8f 7c       	andi	r24, 0xCF	; 207
    590e:	8c 93       	st	X, r24
	TCCR0|=TIMER0_COMPARE_OUTPUT_MODE;
    5910:	a3 e5       	ldi	r26, 0x53	; 83
    5912:	b0 e0       	ldi	r27, 0x00	; 0
    5914:	e3 e5       	ldi	r30, 0x53	; 83
    5916:	f0 e0       	ldi	r31, 0x00	; 0
    5918:	80 81       	ld	r24, Z
    591a:	80 62       	ori	r24, 0x20	; 32
    591c:	8c 93       	st	X, r24
	/*Prescaler*/
	TCCR0&=TIMER_PRESCALER_MASK;
    591e:	a3 e5       	ldi	r26, 0x53	; 83
    5920:	b0 e0       	ldi	r27, 0x00	; 0
    5922:	e3 e5       	ldi	r30, 0x53	; 83
    5924:	f0 e0       	ldi	r31, 0x00	; 0
    5926:	80 81       	ld	r24, Z
    5928:	88 7f       	andi	r24, 0xF8	; 248
    592a:	8c 93       	st	X, r24
	TCCR0|=TIMER0_PRESCALER;
    592c:	a3 e5       	ldi	r26, 0x53	; 83
    592e:	b0 e0       	ldi	r27, 0x00	; 0
    5930:	e3 e5       	ldi	r30, 0x53	; 83
    5932:	f0 e0       	ldi	r31, 0x00	; 0
    5934:	80 81       	ld	r24, Z
    5936:	82 60       	ori	r24, 0x02	; 2
    5938:	8c 93       	st	X, r24
}
    593a:	cf 91       	pop	r28
    593c:	df 91       	pop	r29
    593e:	08 95       	ret

00005940 <TIMER0_voidSetCompMatchValue>:

void TIMER0_voidSetCompMatchValue(u8 Copy_u8Value)
{
    5940:	df 93       	push	r29
    5942:	cf 93       	push	r28
    5944:	0f 92       	push	r0
    5946:	cd b7       	in	r28, 0x3d	; 61
    5948:	de b7       	in	r29, 0x3e	; 62
    594a:	89 83       	std	Y+1, r24	; 0x01
	OCR0 = Copy_u8Value;
    594c:	ec e5       	ldi	r30, 0x5C	; 92
    594e:	f0 e0       	ldi	r31, 0x00	; 0
    5950:	89 81       	ldd	r24, Y+1	; 0x01
    5952:	80 83       	st	Z, r24
}
    5954:	0f 90       	pop	r0
    5956:	cf 91       	pop	r28
    5958:	df 91       	pop	r29
    595a:	08 95       	ret

0000595c <TIMER2_voidInit>:

void TIMER2_voidInit(void)
{
    595c:	df 93       	push	r29
    595e:	cf 93       	push	r28
    5960:	cd b7       	in	r28, 0x3d	; 61
    5962:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(TCCR2,TCCR2_WGM21);
	CLR_BIT(TCCR2,TCCR2_WGM20);
	/*Output Compare Match Interrupt Enable*/
	SET_BIT(TIMSK,TIMSK_OCIE2);
#elif TIMER2_GENERATION_MODE == TIMER2_FAST_PWM_MODE
	SET_BIT(TCCR2,TCCR2_WGM21);
    5964:	a5 e4       	ldi	r26, 0x45	; 69
    5966:	b0 e0       	ldi	r27, 0x00	; 0
    5968:	e5 e4       	ldi	r30, 0x45	; 69
    596a:	f0 e0       	ldi	r31, 0x00	; 0
    596c:	80 81       	ld	r24, Z
    596e:	88 60       	ori	r24, 0x08	; 8
    5970:	8c 93       	st	X, r24
	SET_BIT(TCCR2,TCCR2_WGM20);
    5972:	a5 e4       	ldi	r26, 0x45	; 69
    5974:	b0 e0       	ldi	r27, 0x00	; 0
    5976:	e5 e4       	ldi	r30, 0x45	; 69
    5978:	f0 e0       	ldi	r31, 0x00	; 0
    597a:	80 81       	ld	r24, Z
    597c:	80 64       	ori	r24, 0x40	; 64
    597e:	8c 93       	st	X, r24
#else
#error "Wrong Generation mode"
#endif
	/*Compare match output mode*/
	TCCR2&=COMP_OPMODE_MASK;
    5980:	a5 e4       	ldi	r26, 0x45	; 69
    5982:	b0 e0       	ldi	r27, 0x00	; 0
    5984:	e5 e4       	ldi	r30, 0x45	; 69
    5986:	f0 e0       	ldi	r31, 0x00	; 0
    5988:	80 81       	ld	r24, Z
    598a:	8f 7c       	andi	r24, 0xCF	; 207
    598c:	8c 93       	st	X, r24
	TCCR2|=TIMER2_COMPARE_OUTPUT_MODE;
    598e:	a5 e4       	ldi	r26, 0x45	; 69
    5990:	b0 e0       	ldi	r27, 0x00	; 0
    5992:	e5 e4       	ldi	r30, 0x45	; 69
    5994:	f0 e0       	ldi	r31, 0x00	; 0
    5996:	80 81       	ld	r24, Z
    5998:	80 62       	ori	r24, 0x20	; 32
    599a:	8c 93       	st	X, r24
	/*Prescaler*/
	TCCR2&=TIMER_PRESCALER_MASK;
    599c:	a5 e4       	ldi	r26, 0x45	; 69
    599e:	b0 e0       	ldi	r27, 0x00	; 0
    59a0:	e5 e4       	ldi	r30, 0x45	; 69
    59a2:	f0 e0       	ldi	r31, 0x00	; 0
    59a4:	80 81       	ld	r24, Z
    59a6:	88 7f       	andi	r24, 0xF8	; 248
    59a8:	8c 93       	st	X, r24
	TCCR2|=TIMER2_PRESCALER;
    59aa:	a5 e4       	ldi	r26, 0x45	; 69
    59ac:	b0 e0       	ldi	r27, 0x00	; 0
    59ae:	e5 e4       	ldi	r30, 0x45	; 69
    59b0:	f0 e0       	ldi	r31, 0x00	; 0
    59b2:	80 81       	ld	r24, Z
    59b4:	83 60       	ori	r24, 0x03	; 3
    59b6:	8c 93       	st	X, r24
}
    59b8:	cf 91       	pop	r28
    59ba:	df 91       	pop	r29
    59bc:	08 95       	ret

000059be <TIMER2_voidSetCompMatchValue>:

void TIMER2_voidSetCompMatchValue(u8 Copy_u8Value)
{
    59be:	df 93       	push	r29
    59c0:	cf 93       	push	r28
    59c2:	0f 92       	push	r0
    59c4:	cd b7       	in	r28, 0x3d	; 61
    59c6:	de b7       	in	r29, 0x3e	; 62
    59c8:	89 83       	std	Y+1, r24	; 0x01
	OCR2=Copy_u8Value;
    59ca:	e3 e4       	ldi	r30, 0x43	; 67
    59cc:	f0 e0       	ldi	r31, 0x00	; 0
    59ce:	89 81       	ldd	r24, Y+1	; 0x01
    59d0:	80 83       	st	Z, r24
}
    59d2:	0f 90       	pop	r0
    59d4:	cf 91       	pop	r28
    59d6:	df 91       	pop	r29
    59d8:	08 95       	ret

000059da <ADC_voidInit>:
static u16 *ADC_pu16ChainResultArr=NULL;
static u8 ADC_u8ChainConversionIndex=0;
static u8 ADC_u8ISRSource;

void ADC_voidInit(void)
{
    59da:	df 93       	push	r29
    59dc:	cf 93       	push	r28
    59de:	cd b7       	in	r28, 0x3d	; 61
    59e0:	de b7       	in	r29, 0x3e	; 62
	/*AVCC as reference voltage*/
#if ADC_REF_VOLTAGE==AREF
	CLR_BIT(ADMUX,ADMUX_REFS0);
    59e2:	a7 e2       	ldi	r26, 0x27	; 39
    59e4:	b0 e0       	ldi	r27, 0x00	; 0
    59e6:	e7 e2       	ldi	r30, 0x27	; 39
    59e8:	f0 e0       	ldi	r31, 0x00	; 0
    59ea:	80 81       	ld	r24, Z
    59ec:	8f 7b       	andi	r24, 0xBF	; 191
    59ee:	8c 93       	st	X, r24
	CLR_BIT(ADMUX,ADMUX_REFS1);
    59f0:	a7 e2       	ldi	r26, 0x27	; 39
    59f2:	b0 e0       	ldi	r27, 0x00	; 0
    59f4:	e7 e2       	ldi	r30, 0x27	; 39
    59f6:	f0 e0       	ldi	r31, 0x00	; 0
    59f8:	80 81       	ld	r24, Z
    59fa:	8f 77       	andi	r24, 0x7F	; 127
    59fc:	8c 93       	st	X, r24
#else
#error "Wrong Voltage Reference"
#endif
#if ADC_RES==EIGHT_BIT
	/*Activate left adjust result*/
	SET_BIT(ADMUX,ADMUX_ADLAR);
    59fe:	a7 e2       	ldi	r26, 0x27	; 39
    5a00:	b0 e0       	ldi	r27, 0x00	; 0
    5a02:	e7 e2       	ldi	r30, 0x27	; 39
    5a04:	f0 e0       	ldi	r31, 0x00	; 0
    5a06:	80 81       	ld	r24, Z
    5a08:	80 62       	ori	r24, 0x20	; 32
    5a0a:	8c 93       	st	X, r24
	CLR_BIT(ADMUX,ADMUX_ADLAR);
#else
#error "Wrong Resolution"
#endif
	/*SET pre-scaler to divide by 128*/
	ADCSRA&=PRE_SCALERMASK;
    5a0c:	a6 e2       	ldi	r26, 0x26	; 38
    5a0e:	b0 e0       	ldi	r27, 0x00	; 0
    5a10:	e6 e2       	ldi	r30, 0x26	; 38
    5a12:	f0 e0       	ldi	r31, 0x00	; 0
    5a14:	80 81       	ld	r24, Z
    5a16:	88 7f       	andi	r24, 0xF8	; 248
    5a18:	8c 93       	st	X, r24
	ADCSRA|=ADC_PRE_SCALER;
    5a1a:	a6 e2       	ldi	r26, 0x26	; 38
    5a1c:	b0 e0       	ldi	r27, 0x00	; 0
    5a1e:	e6 e2       	ldi	r30, 0x26	; 38
    5a20:	f0 e0       	ldi	r31, 0x00	; 0
    5a22:	80 81       	ld	r24, Z
    5a24:	87 60       	ori	r24, 0x07	; 7
    5a26:	8c 93       	st	X, r24
	/*Enable ADC*/
	SET_BIT(ADCSRA,ADCSRA_ADEN);
    5a28:	a6 e2       	ldi	r26, 0x26	; 38
    5a2a:	b0 e0       	ldi	r27, 0x00	; 0
    5a2c:	e6 e2       	ldi	r30, 0x26	; 38
    5a2e:	f0 e0       	ldi	r31, 0x00	; 0
    5a30:	80 81       	ld	r24, Z
    5a32:	80 68       	ori	r24, 0x80	; 128
    5a34:	8c 93       	st	X, r24
	SFIOR&=SOURCE_MASK;
	SFIOR|=(AUTO_TRIGGER_SOURCE<<5);
	/*Start conversion*/
	SET_BIT(ADCSRA,ADCSRA_ADSC);
#elif ADC_CONVERSION_MODE==SINGLE_MODE
	CLR_BIT(ADCSRA,ADCSRA_ADATE);
    5a36:	a6 e2       	ldi	r26, 0x26	; 38
    5a38:	b0 e0       	ldi	r27, 0x00	; 0
    5a3a:	e6 e2       	ldi	r30, 0x26	; 38
    5a3c:	f0 e0       	ldi	r31, 0x00	; 0
    5a3e:	80 81       	ld	r24, Z
    5a40:	8f 7d       	andi	r24, 0xDF	; 223
    5a42:	8c 93       	st	X, r24
#else
#error "Wrong Conversion Mode"
#endif
}
    5a44:	cf 91       	pop	r28
    5a46:	df 91       	pop	r29
    5a48:	08 95       	ret

00005a4a <ADC_u16StartConversionSynch>:

u16 ADC_u16StartConversionSynch(u8 Copy_u8Channel,u16* Copy_pu16Reading)
{
    5a4a:	df 93       	push	r29
    5a4c:	cf 93       	push	r28
    5a4e:	cd b7       	in	r28, 0x3d	; 61
    5a50:	de b7       	in	r29, 0x3e	; 62
    5a52:	28 97       	sbiw	r28, 0x08	; 8
    5a54:	0f b6       	in	r0, 0x3f	; 63
    5a56:	f8 94       	cli
    5a58:	de bf       	out	0x3e, r29	; 62
    5a5a:	0f be       	out	0x3f, r0	; 63
    5a5c:	cd bf       	out	0x3d, r28	; 61
    5a5e:	8e 83       	std	Y+6, r24	; 0x06
    5a60:	78 87       	std	Y+8, r23	; 0x08
    5a62:	6f 83       	std	Y+7, r22	; 0x07
	u32 Local_u32Counter=0;
    5a64:	1a 82       	std	Y+2, r1	; 0x02
    5a66:	1b 82       	std	Y+3, r1	; 0x03
    5a68:	1c 82       	std	Y+4, r1	; 0x04
    5a6a:	1d 82       	std	Y+5, r1	; 0x05
	u8 Local_u8ErrorState=OK;
    5a6c:	19 82       	std	Y+1, r1	; 0x01
	if(ADC_u8BusyState==IDLE)
    5a6e:	80 91 5b 07 	lds	r24, 0x075B
    5a72:	88 23       	and	r24, r24
    5a74:	09 f0       	breq	.+2      	; 0x5a78 <ADC_u16StartConversionSynch+0x2e>
    5a76:	5e c0       	rjmp	.+188    	; 0x5b34 <ADC_u16StartConversionSynch+0xea>
	{
		/*ADC is now Busy*/
		ADC_u8BusyState=BUSY;
    5a78:	81 e0       	ldi	r24, 0x01	; 1
    5a7a:	80 93 5b 07 	sts	0x075B, r24
		/*Clear The MUX bits in ADmux register*/
		ADMUX &=ADMUX_MASK;
    5a7e:	a7 e2       	ldi	r26, 0x27	; 39
    5a80:	b0 e0       	ldi	r27, 0x00	; 0
    5a82:	e7 e2       	ldi	r30, 0x27	; 39
    5a84:	f0 e0       	ldi	r31, 0x00	; 0
    5a86:	80 81       	ld	r24, Z
    5a88:	80 7e       	andi	r24, 0xE0	; 224
    5a8a:	8c 93       	st	X, r24
		/*Set the required channel into the MUX bits*/
		ADMUX|=Copy_u8Channel;
    5a8c:	a7 e2       	ldi	r26, 0x27	; 39
    5a8e:	b0 e0       	ldi	r27, 0x00	; 0
    5a90:	e7 e2       	ldi	r30, 0x27	; 39
    5a92:	f0 e0       	ldi	r31, 0x00	; 0
    5a94:	90 81       	ld	r25, Z
    5a96:	8e 81       	ldd	r24, Y+6	; 0x06
    5a98:	89 2b       	or	r24, r25
    5a9a:	8c 93       	st	X, r24
		/*Start conversion*/
		SET_BIT(ADCSRA,ADCSRA_ADSC);
    5a9c:	a6 e2       	ldi	r26, 0x26	; 38
    5a9e:	b0 e0       	ldi	r27, 0x00	; 0
    5aa0:	e6 e2       	ldi	r30, 0x26	; 38
    5aa2:	f0 e0       	ldi	r31, 0x00	; 0
    5aa4:	80 81       	ld	r24, Z
    5aa6:	80 64       	ori	r24, 0x40	; 64
    5aa8:	8c 93       	st	X, r24
    5aaa:	0b c0       	rjmp	.+22     	; 0x5ac2 <ADC_u16StartConversionSynch+0x78>
		/*polling (Busy waiting) until the conversion complete flag is set*/
		while((GET_BIT(ADCSRA,ADCSRA_ADIF)==0) && (Local_u32Counter != ADC_u32TIMEOUT))
		{
			Local_u32Counter++;
    5aac:	8a 81       	ldd	r24, Y+2	; 0x02
    5aae:	9b 81       	ldd	r25, Y+3	; 0x03
    5ab0:	ac 81       	ldd	r26, Y+4	; 0x04
    5ab2:	bd 81       	ldd	r27, Y+5	; 0x05
    5ab4:	01 96       	adiw	r24, 0x01	; 1
    5ab6:	a1 1d       	adc	r26, r1
    5ab8:	b1 1d       	adc	r27, r1
    5aba:	8a 83       	std	Y+2, r24	; 0x02
    5abc:	9b 83       	std	Y+3, r25	; 0x03
    5abe:	ac 83       	std	Y+4, r26	; 0x04
    5ac0:	bd 83       	std	Y+5, r27	; 0x05
		/*Set the required channel into the MUX bits*/
		ADMUX|=Copy_u8Channel;
		/*Start conversion*/
		SET_BIT(ADCSRA,ADCSRA_ADSC);
		/*polling (Busy waiting) until the conversion complete flag is set*/
		while((GET_BIT(ADCSRA,ADCSRA_ADIF)==0) && (Local_u32Counter != ADC_u32TIMEOUT))
    5ac2:	e6 e2       	ldi	r30, 0x26	; 38
    5ac4:	f0 e0       	ldi	r31, 0x00	; 0
    5ac6:	80 81       	ld	r24, Z
    5ac8:	82 95       	swap	r24
    5aca:	8f 70       	andi	r24, 0x0F	; 15
    5acc:	88 2f       	mov	r24, r24
    5ace:	90 e0       	ldi	r25, 0x00	; 0
    5ad0:	81 70       	andi	r24, 0x01	; 1
    5ad2:	90 70       	andi	r25, 0x00	; 0
    5ad4:	00 97       	sbiw	r24, 0x00	; 0
    5ad6:	61 f4       	brne	.+24     	; 0x5af0 <ADC_u16StartConversionSynch+0xa6>
    5ad8:	8a 81       	ldd	r24, Y+2	; 0x02
    5ada:	9b 81       	ldd	r25, Y+3	; 0x03
    5adc:	ac 81       	ldd	r26, Y+4	; 0x04
    5ade:	bd 81       	ldd	r27, Y+5	; 0x05
    5ae0:	80 35       	cpi	r24, 0x50	; 80
    5ae2:	23 ec       	ldi	r18, 0xC3	; 195
    5ae4:	92 07       	cpc	r25, r18
    5ae6:	20 e0       	ldi	r18, 0x00	; 0
    5ae8:	a2 07       	cpc	r26, r18
    5aea:	20 e0       	ldi	r18, 0x00	; 0
    5aec:	b2 07       	cpc	r27, r18
    5aee:	f1 f6       	brne	.-68     	; 0x5aac <ADC_u16StartConversionSynch+0x62>
		{
			Local_u32Counter++;
		}
		if(Local_u32Counter==ADC_u32TIMEOUT)
    5af0:	8a 81       	ldd	r24, Y+2	; 0x02
    5af2:	9b 81       	ldd	r25, Y+3	; 0x03
    5af4:	ac 81       	ldd	r26, Y+4	; 0x04
    5af6:	bd 81       	ldd	r27, Y+5	; 0x05
    5af8:	80 35       	cpi	r24, 0x50	; 80
    5afa:	23 ec       	ldi	r18, 0xC3	; 195
    5afc:	92 07       	cpc	r25, r18
    5afe:	20 e0       	ldi	r18, 0x00	; 0
    5b00:	a2 07       	cpc	r26, r18
    5b02:	20 e0       	ldi	r18, 0x00	; 0
    5b04:	b2 07       	cpc	r27, r18
    5b06:	19 f4       	brne	.+6      	; 0x5b0e <ADC_u16StartConversionSynch+0xc4>
		{
			/*Loop is broken as the time out is reached*/
			Local_u8ErrorState=NOK;
    5b08:	81 e0       	ldi	r24, 0x01	; 1
    5b0a:	89 83       	std	Y+1, r24	; 0x01
    5b0c:	15 c0       	rjmp	.+42     	; 0x5b38 <ADC_u16StartConversionSynch+0xee>
		}
		else
		{
			/*Loop is broken as flag is raised*/
			/*Clear the conversion complete flag*/
			SET_BIT(ADCSRA,ADCSRA_ADIF);
    5b0e:	a6 e2       	ldi	r26, 0x26	; 38
    5b10:	b0 e0       	ldi	r27, 0x00	; 0
    5b12:	e6 e2       	ldi	r30, 0x26	; 38
    5b14:	f0 e0       	ldi	r31, 0x00	; 0
    5b16:	80 81       	ld	r24, Z
    5b18:	80 61       	ori	r24, 0x10	; 16
    5b1a:	8c 93       	st	X, r24
			#if ADC_RES==EIGHT_BIT
				*Copy_pu16Reading = ADCH;
    5b1c:	e5 e2       	ldi	r30, 0x25	; 37
    5b1e:	f0 e0       	ldi	r31, 0x00	; 0
    5b20:	80 81       	ld	r24, Z
    5b22:	88 2f       	mov	r24, r24
    5b24:	90 e0       	ldi	r25, 0x00	; 0
    5b26:	ef 81       	ldd	r30, Y+7	; 0x07
    5b28:	f8 85       	ldd	r31, Y+8	; 0x08
    5b2a:	91 83       	std	Z+1, r25	; 0x01
    5b2c:	80 83       	st	Z, r24
				*Copy_pu16Reading = ADC;
			#else
			#error "Wrong Conversion Mode"
			#endif
			/*ADC is finished, return it to IDLE*/
			ADC_u8BusyState=IDLE;
    5b2e:	10 92 5b 07 	sts	0x075B, r1
    5b32:	02 c0       	rjmp	.+4      	; 0x5b38 <ADC_u16StartConversionSynch+0xee>
		}
	}
	else
	{
		Local_u8ErrorState=BUSY_FUNC;
    5b34:	83 e0       	ldi	r24, 0x03	; 3
    5b36:	89 83       	std	Y+1, r24	; 0x01
	}
	return Local_u8ErrorState;
    5b38:	89 81       	ldd	r24, Y+1	; 0x01
    5b3a:	88 2f       	mov	r24, r24
    5b3c:	90 e0       	ldi	r25, 0x00	; 0
}
    5b3e:	28 96       	adiw	r28, 0x08	; 8
    5b40:	0f b6       	in	r0, 0x3f	; 63
    5b42:	f8 94       	cli
    5b44:	de bf       	out	0x3e, r29	; 62
    5b46:	0f be       	out	0x3f, r0	; 63
    5b48:	cd bf       	out	0x3d, r28	; 61
    5b4a:	cf 91       	pop	r28
    5b4c:	df 91       	pop	r29
    5b4e:	08 95       	ret

00005b50 <ADC_u8StartConversionAsynch>:

u8 ADC_u8StartConversionAsynch(u8 Copy_u8Channel,u16* Copy_pu16Reading,void (*Copy_pvNotififcationFunc)(void))
{
    5b50:	df 93       	push	r29
    5b52:	cf 93       	push	r28
    5b54:	00 d0       	rcall	.+0      	; 0x5b56 <ADC_u8StartConversionAsynch+0x6>
    5b56:	00 d0       	rcall	.+0      	; 0x5b58 <ADC_u8StartConversionAsynch+0x8>
    5b58:	00 d0       	rcall	.+0      	; 0x5b5a <ADC_u8StartConversionAsynch+0xa>
    5b5a:	cd b7       	in	r28, 0x3d	; 61
    5b5c:	de b7       	in	r29, 0x3e	; 62
    5b5e:	8a 83       	std	Y+2, r24	; 0x02
    5b60:	7c 83       	std	Y+4, r23	; 0x04
    5b62:	6b 83       	std	Y+3, r22	; 0x03
    5b64:	5e 83       	std	Y+6, r21	; 0x06
    5b66:	4d 83       	std	Y+5, r20	; 0x05
	u8 Local_u8ErrorState=OK;
    5b68:	19 82       	std	Y+1, r1	; 0x01
	if(ADC_u8BusyState==IDLE)
    5b6a:	80 91 5b 07 	lds	r24, 0x075B
    5b6e:	88 23       	and	r24, r24
    5b70:	d1 f5       	brne	.+116    	; 0x5be6 <ADC_u8StartConversionAsynch+0x96>
	{
		if((Copy_pu16Reading == NULL) || (Copy_pvNotififcationFunc == NULL))
    5b72:	8b 81       	ldd	r24, Y+3	; 0x03
    5b74:	9c 81       	ldd	r25, Y+4	; 0x04
    5b76:	00 97       	sbiw	r24, 0x00	; 0
    5b78:	21 f0       	breq	.+8      	; 0x5b82 <ADC_u8StartConversionAsynch+0x32>
    5b7a:	8d 81       	ldd	r24, Y+5	; 0x05
    5b7c:	9e 81       	ldd	r25, Y+6	; 0x06
    5b7e:	00 97       	sbiw	r24, 0x00	; 0
    5b80:	19 f4       	brne	.+6      	; 0x5b88 <ADC_u8StartConversionAsynch+0x38>
		{
			Local_u8ErrorState=NULL_POINTER;
    5b82:	82 e0       	ldi	r24, 0x02	; 2
    5b84:	89 83       	std	Y+1, r24	; 0x01
    5b86:	31 c0       	rjmp	.+98     	; 0x5bea <ADC_u8StartConversionAsynch+0x9a>
		}
		else
		{
			ADC_u8BusyState=BUSY;
    5b88:	81 e0       	ldi	r24, 0x01	; 1
    5b8a:	80 93 5b 07 	sts	0x075B, r24
			ADC_u8ISRSource=SINGLE_CHANNEL_ASYNCH;
    5b8e:	10 92 62 07 	sts	0x0762, r1
			/*Initialize the reading variable & CallBack Notification Function Globally*/
			ADC_pu16Reading=Copy_pu16Reading;
    5b92:	8b 81       	ldd	r24, Y+3	; 0x03
    5b94:	9c 81       	ldd	r25, Y+4	; 0x04
    5b96:	90 93 58 07 	sts	0x0758, r25
    5b9a:	80 93 57 07 	sts	0x0757, r24
			ADC_pvCallBackNotificationFunc=Copy_pvNotififcationFunc;
    5b9e:	8d 81       	ldd	r24, Y+5	; 0x05
    5ba0:	9e 81       	ldd	r25, Y+6	; 0x06
    5ba2:	90 93 5a 07 	sts	0x075A, r25
    5ba6:	80 93 59 07 	sts	0x0759, r24
			/*Clear The MUX bits in ADmux register*/
			ADMUX &=ADMUX_MASK;
    5baa:	a7 e2       	ldi	r26, 0x27	; 39
    5bac:	b0 e0       	ldi	r27, 0x00	; 0
    5bae:	e7 e2       	ldi	r30, 0x27	; 39
    5bb0:	f0 e0       	ldi	r31, 0x00	; 0
    5bb2:	80 81       	ld	r24, Z
    5bb4:	80 7e       	andi	r24, 0xE0	; 224
    5bb6:	8c 93       	st	X, r24
			/*Set the required channel into the MUX bits*/
			ADMUX|=Copy_u8Channel;
    5bb8:	a7 e2       	ldi	r26, 0x27	; 39
    5bba:	b0 e0       	ldi	r27, 0x00	; 0
    5bbc:	e7 e2       	ldi	r30, 0x27	; 39
    5bbe:	f0 e0       	ldi	r31, 0x00	; 0
    5bc0:	90 81       	ld	r25, Z
    5bc2:	8a 81       	ldd	r24, Y+2	; 0x02
    5bc4:	89 2b       	or	r24, r25
    5bc6:	8c 93       	st	X, r24
			/*Start conversion*/
			SET_BIT(ADCSRA,ADCSRA_ADSC);
    5bc8:	a6 e2       	ldi	r26, 0x26	; 38
    5bca:	b0 e0       	ldi	r27, 0x00	; 0
    5bcc:	e6 e2       	ldi	r30, 0x26	; 38
    5bce:	f0 e0       	ldi	r31, 0x00	; 0
    5bd0:	80 81       	ld	r24, Z
    5bd2:	80 64       	ori	r24, 0x40	; 64
    5bd4:	8c 93       	st	X, r24
			/*ADC Interrupt Enable*/
			SET_BIT(ADCSRA,ADCSRA_ADIE);
    5bd6:	a6 e2       	ldi	r26, 0x26	; 38
    5bd8:	b0 e0       	ldi	r27, 0x00	; 0
    5bda:	e6 e2       	ldi	r30, 0x26	; 38
    5bdc:	f0 e0       	ldi	r31, 0x00	; 0
    5bde:	80 81       	ld	r24, Z
    5be0:	88 60       	ori	r24, 0x08	; 8
    5be2:	8c 93       	st	X, r24
    5be4:	02 c0       	rjmp	.+4      	; 0x5bea <ADC_u8StartConversionAsynch+0x9a>
		}
	}
	else
	{
		Local_u8ErrorState=BUSY_FUNC;
    5be6:	83 e0       	ldi	r24, 0x03	; 3
    5be8:	89 83       	std	Y+1, r24	; 0x01
	}
	return Local_u8ErrorState;
    5bea:	89 81       	ldd	r24, Y+1	; 0x01
}
    5bec:	26 96       	adiw	r28, 0x06	; 6
    5bee:	0f b6       	in	r0, 0x3f	; 63
    5bf0:	f8 94       	cli
    5bf2:	de bf       	out	0x3e, r29	; 62
    5bf4:	0f be       	out	0x3f, r0	; 63
    5bf6:	cd bf       	out	0x3d, r28	; 61
    5bf8:	cf 91       	pop	r28
    5bfa:	df 91       	pop	r29
    5bfc:	08 95       	ret

00005bfe <ADC_u8startChainConversionAsynch>:
u8 ADC_u8startChainConversionAsynch(Chain_t *Copy_Chain)
{
    5bfe:	df 93       	push	r29
    5c00:	cf 93       	push	r28
    5c02:	00 d0       	rcall	.+0      	; 0x5c04 <ADC_u8startChainConversionAsynch+0x6>
    5c04:	0f 92       	push	r0
    5c06:	cd b7       	in	r28, 0x3d	; 61
    5c08:	de b7       	in	r29, 0x3e	; 62
    5c0a:	9b 83       	std	Y+3, r25	; 0x03
    5c0c:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_u8ErrorState=OK;
    5c0e:	19 82       	std	Y+1, r1	; 0x01
	if(Copy_Chain==NULL)
    5c10:	8a 81       	ldd	r24, Y+2	; 0x02
    5c12:	9b 81       	ldd	r25, Y+3	; 0x03
    5c14:	00 97       	sbiw	r24, 0x00	; 0
    5c16:	19 f4       	brne	.+6      	; 0x5c1e <ADC_u8startChainConversionAsynch+0x20>
	{
		Local_u8ErrorState=BUSY_FUNC;
    5c18:	83 e0       	ldi	r24, 0x03	; 3
    5c1a:	89 83       	std	Y+1, r24	; 0x01
    5c1c:	55 c0       	rjmp	.+170    	; 0x5cc8 <ADC_u8startChainConversionAsynch+0xca>
	}
	else
	{
		if(ADC_u8BusyState==IDLE)
    5c1e:	80 91 5b 07 	lds	r24, 0x075B
    5c22:	88 23       	and	r24, r24
    5c24:	09 f0       	breq	.+2      	; 0x5c28 <ADC_u8startChainConversionAsynch+0x2a>
    5c26:	4e c0       	rjmp	.+156    	; 0x5cc4 <ADC_u8startChainConversionAsynch+0xc6>
		{
			ADC_u8BusyState=BUSY;
    5c28:	81 e0       	ldi	r24, 0x01	; 1
    5c2a:	80 93 5b 07 	sts	0x075B, r24
			ADC_u8ISRSource=CHAIN_ASYNCH;
    5c2e:	81 e0       	ldi	r24, 0x01	; 1
    5c30:	80 93 62 07 	sts	0x0762, r24
			/*Initialize the reading variable & CallBack Notification Function Globally*/
			ADC_pu8chainChannelArr=Copy_Chain->Channel;
    5c34:	ea 81       	ldd	r30, Y+2	; 0x02
    5c36:	fb 81       	ldd	r31, Y+3	; 0x03
    5c38:	80 81       	ld	r24, Z
    5c3a:	91 81       	ldd	r25, Z+1	; 0x01
    5c3c:	90 93 5d 07 	sts	0x075D, r25
    5c40:	80 93 5c 07 	sts	0x075C, r24
			ADC_pvCallBackNotificationFunc=Copy_Chain->NotificationFunc;
    5c44:	ea 81       	ldd	r30, Y+2	; 0x02
    5c46:	fb 81       	ldd	r31, Y+3	; 0x03
    5c48:	83 81       	ldd	r24, Z+3	; 0x03
    5c4a:	94 81       	ldd	r25, Z+4	; 0x04
    5c4c:	90 93 5a 07 	sts	0x075A, r25
    5c50:	80 93 59 07 	sts	0x0759, r24
			ADC_pu16ChainResultArr=Copy_Chain->Result;
    5c54:	ea 81       	ldd	r30, Y+2	; 0x02
    5c56:	fb 81       	ldd	r31, Y+3	; 0x03
    5c58:	85 81       	ldd	r24, Z+5	; 0x05
    5c5a:	96 81       	ldd	r25, Z+6	; 0x06
    5c5c:	90 93 60 07 	sts	0x0760, r25
    5c60:	80 93 5f 07 	sts	0x075F, r24
			ADC_u8ChainSize=Copy_Chain->Size;
    5c64:	ea 81       	ldd	r30, Y+2	; 0x02
    5c66:	fb 81       	ldd	r31, Y+3	; 0x03
    5c68:	82 81       	ldd	r24, Z+2	; 0x02
    5c6a:	80 93 5e 07 	sts	0x075E, r24
			ADC_u8ChainConversionIndex=0;
    5c6e:	10 92 61 07 	sts	0x0761, r1
			/*Clear The MUX bits in ADmux register*/
			ADMUX &=ADMUX_MASK;
    5c72:	a7 e2       	ldi	r26, 0x27	; 39
    5c74:	b0 e0       	ldi	r27, 0x00	; 0
    5c76:	e7 e2       	ldi	r30, 0x27	; 39
    5c78:	f0 e0       	ldi	r31, 0x00	; 0
    5c7a:	80 81       	ld	r24, Z
    5c7c:	80 7e       	andi	r24, 0xE0	; 224
    5c7e:	8c 93       	st	X, r24
			/*Set the required channel into the MUX bits*/
			ADMUX|=ADC_pu8chainChannelArr[ADC_u8ChainConversionIndex];
    5c80:	a7 e2       	ldi	r26, 0x27	; 39
    5c82:	b0 e0       	ldi	r27, 0x00	; 0
    5c84:	e7 e2       	ldi	r30, 0x27	; 39
    5c86:	f0 e0       	ldi	r31, 0x00	; 0
    5c88:	40 81       	ld	r20, Z
    5c8a:	20 91 5c 07 	lds	r18, 0x075C
    5c8e:	30 91 5d 07 	lds	r19, 0x075D
    5c92:	80 91 61 07 	lds	r24, 0x0761
    5c96:	88 2f       	mov	r24, r24
    5c98:	90 e0       	ldi	r25, 0x00	; 0
    5c9a:	f9 01       	movw	r30, r18
    5c9c:	e8 0f       	add	r30, r24
    5c9e:	f9 1f       	adc	r31, r25
    5ca0:	80 81       	ld	r24, Z
    5ca2:	84 2b       	or	r24, r20
    5ca4:	8c 93       	st	X, r24
			/*Start conversion*/
			SET_BIT(ADCSRA,ADCSRA_ADSC);
    5ca6:	a6 e2       	ldi	r26, 0x26	; 38
    5ca8:	b0 e0       	ldi	r27, 0x00	; 0
    5caa:	e6 e2       	ldi	r30, 0x26	; 38
    5cac:	f0 e0       	ldi	r31, 0x00	; 0
    5cae:	80 81       	ld	r24, Z
    5cb0:	80 64       	ori	r24, 0x40	; 64
    5cb2:	8c 93       	st	X, r24
			/*ADC Interrupt Enable*/
			SET_BIT(ADCSRA,ADCSRA_ADIE);
    5cb4:	a6 e2       	ldi	r26, 0x26	; 38
    5cb6:	b0 e0       	ldi	r27, 0x00	; 0
    5cb8:	e6 e2       	ldi	r30, 0x26	; 38
    5cba:	f0 e0       	ldi	r31, 0x00	; 0
    5cbc:	80 81       	ld	r24, Z
    5cbe:	88 60       	ori	r24, 0x08	; 8
    5cc0:	8c 93       	st	X, r24
    5cc2:	02 c0       	rjmp	.+4      	; 0x5cc8 <ADC_u8startChainConversionAsynch+0xca>
		}
		else
		{
			Local_u8ErrorState=BUSY_FUNC;
    5cc4:	83 e0       	ldi	r24, 0x03	; 3
    5cc6:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	return Local_u8ErrorState;
    5cc8:	89 81       	ldd	r24, Y+1	; 0x01
}
    5cca:	0f 90       	pop	r0
    5ccc:	0f 90       	pop	r0
    5cce:	0f 90       	pop	r0
    5cd0:	cf 91       	pop	r28
    5cd2:	df 91       	pop	r29
    5cd4:	08 95       	ret

00005cd6 <__vector_16>:
void __vector_16 (void)  __attribute__((signal));

void __vector_16 (void)
{
    5cd6:	1f 92       	push	r1
    5cd8:	0f 92       	push	r0
    5cda:	0f b6       	in	r0, 0x3f	; 63
    5cdc:	0f 92       	push	r0
    5cde:	11 24       	eor	r1, r1
    5ce0:	2f 93       	push	r18
    5ce2:	3f 93       	push	r19
    5ce4:	4f 93       	push	r20
    5ce6:	5f 93       	push	r21
    5ce8:	6f 93       	push	r22
    5cea:	7f 93       	push	r23
    5cec:	8f 93       	push	r24
    5cee:	9f 93       	push	r25
    5cf0:	af 93       	push	r26
    5cf2:	bf 93       	push	r27
    5cf4:	ef 93       	push	r30
    5cf6:	ff 93       	push	r31
    5cf8:	df 93       	push	r29
    5cfa:	cf 93       	push	r28
    5cfc:	cd b7       	in	r28, 0x3d	; 61
    5cfe:	de b7       	in	r29, 0x3e	; 62
	if(ADC_u8ISRSource==SINGLE_CHANNEL_ASYNCH)
    5d00:	80 91 62 07 	lds	r24, 0x0762
    5d04:	88 23       	and	r24, r24
    5d06:	d1 f4       	brne	.+52     	; 0x5d3c <__vector_16+0x66>
	{
		/*Read ADC Reading*/
		#if ADC_RES==EIGHT_BIT
			*ADC_pu16Reading = ADCH;
    5d08:	a0 91 57 07 	lds	r26, 0x0757
    5d0c:	b0 91 58 07 	lds	r27, 0x0758
    5d10:	e5 e2       	ldi	r30, 0x25	; 37
    5d12:	f0 e0       	ldi	r31, 0x00	; 0
    5d14:	80 81       	ld	r24, Z
    5d16:	88 2f       	mov	r24, r24
    5d18:	90 e0       	ldi	r25, 0x00	; 0
    5d1a:	8d 93       	st	X+, r24
    5d1c:	9c 93       	st	X, r25
			*ADC_pu16Reading = ADC;
		#else
		#error "Wrong Conversion Mode"
		#endif
		/*Make ADC_u8BusyState Ideal*/
		ADC_u8BusyState=IDLE;
    5d1e:	10 92 5b 07 	sts	0x075B, r1
		/*Invoke the call Back Notification*/
		ADC_pvCallBackNotificationFunc();
    5d22:	e0 91 59 07 	lds	r30, 0x0759
    5d26:	f0 91 5a 07 	lds	r31, 0x075A
    5d2a:	09 95       	icall
		/*Disable ADC conversion Complete Interrupt*/
		CLR_BIT(ADCSRA,ADCSRA_ADIE);
    5d2c:	a6 e2       	ldi	r26, 0x26	; 38
    5d2e:	b0 e0       	ldi	r27, 0x00	; 0
    5d30:	e6 e2       	ldi	r30, 0x26	; 38
    5d32:	f0 e0       	ldi	r31, 0x00	; 0
    5d34:	80 81       	ld	r24, Z
    5d36:	87 7f       	andi	r24, 0xF7	; 247
    5d38:	8c 93       	st	X, r24
    5d3a:	55 c0       	rjmp	.+170    	; 0x5de6 <__vector_16+0x110>
	}
	else if(ADC_u8ISRSource==CHAIN_ASYNCH)
    5d3c:	80 91 62 07 	lds	r24, 0x0762
    5d40:	81 30       	cpi	r24, 0x01	; 1
    5d42:	09 f0       	breq	.+2      	; 0x5d46 <__vector_16+0x70>
    5d44:	50 c0       	rjmp	.+160    	; 0x5de6 <__vector_16+0x110>
	{
		#if ADC_RES==EIGHT_BIT
			ADC_pu16ChainResultArr[ADC_u8ChainConversionIndex] = ADCH;
    5d46:	20 91 5f 07 	lds	r18, 0x075F
    5d4a:	30 91 60 07 	lds	r19, 0x0760
    5d4e:	80 91 61 07 	lds	r24, 0x0761
    5d52:	88 2f       	mov	r24, r24
    5d54:	90 e0       	ldi	r25, 0x00	; 0
    5d56:	88 0f       	add	r24, r24
    5d58:	99 1f       	adc	r25, r25
    5d5a:	d9 01       	movw	r26, r18
    5d5c:	a8 0f       	add	r26, r24
    5d5e:	b9 1f       	adc	r27, r25
    5d60:	e5 e2       	ldi	r30, 0x25	; 37
    5d62:	f0 e0       	ldi	r31, 0x00	; 0
    5d64:	80 81       	ld	r24, Z
    5d66:	88 2f       	mov	r24, r24
    5d68:	90 e0       	ldi	r25, 0x00	; 0
    5d6a:	11 96       	adiw	r26, 0x01	; 1
    5d6c:	9c 93       	st	X, r25
    5d6e:	8e 93       	st	-X, r24
		#elif ADC_RES==TEN_BIT
			ADC_pu16ChainResultArr[ADC_u8ChainConversionIndex] = ADC;
		#else
		#error "Wrong Conversion Mode"
		#endif
		ADC_u8ChainConversionIndex++;
    5d70:	80 91 61 07 	lds	r24, 0x0761
    5d74:	8f 5f       	subi	r24, 0xFF	; 255
    5d76:	80 93 61 07 	sts	0x0761, r24
		if(ADC_u8ChainConversionIndex==ADC_u8ChainSize)
    5d7a:	90 91 61 07 	lds	r25, 0x0761
    5d7e:	80 91 5e 07 	lds	r24, 0x075E
    5d82:	98 17       	cp	r25, r24
    5d84:	79 f4       	brne	.+30     	; 0x5da4 <__vector_16+0xce>
		{
			/*Make ADC_u8BusyState Ideal*/
			ADC_u8BusyState=IDLE;
    5d86:	10 92 5b 07 	sts	0x075B, r1
			/*Invoke the call Back Notification*/
			ADC_pvCallBackNotificationFunc();
    5d8a:	e0 91 59 07 	lds	r30, 0x0759
    5d8e:	f0 91 5a 07 	lds	r31, 0x075A
    5d92:	09 95       	icall
			/*Disable ADC conversion Complete Interrupt*/
			CLR_BIT(ADCSRA,ADCSRA_ADIE);
    5d94:	a6 e2       	ldi	r26, 0x26	; 38
    5d96:	b0 e0       	ldi	r27, 0x00	; 0
    5d98:	e6 e2       	ldi	r30, 0x26	; 38
    5d9a:	f0 e0       	ldi	r31, 0x00	; 0
    5d9c:	80 81       	ld	r24, Z
    5d9e:	87 7f       	andi	r24, 0xF7	; 247
    5da0:	8c 93       	st	X, r24
    5da2:	21 c0       	rjmp	.+66     	; 0x5de6 <__vector_16+0x110>
		}
		else
		{
			/*Clear The MUX bits in ADmux register*/
			ADMUX &=ADMUX_MASK;
    5da4:	a7 e2       	ldi	r26, 0x27	; 39
    5da6:	b0 e0       	ldi	r27, 0x00	; 0
    5da8:	e7 e2       	ldi	r30, 0x27	; 39
    5daa:	f0 e0       	ldi	r31, 0x00	; 0
    5dac:	80 81       	ld	r24, Z
    5dae:	80 7e       	andi	r24, 0xE0	; 224
    5db0:	8c 93       	st	X, r24
			/*Set the required channel into the MUX bits*/
			ADMUX|=ADC_pu8chainChannelArr[ADC_u8ChainConversionIndex];
    5db2:	a7 e2       	ldi	r26, 0x27	; 39
    5db4:	b0 e0       	ldi	r27, 0x00	; 0
    5db6:	e7 e2       	ldi	r30, 0x27	; 39
    5db8:	f0 e0       	ldi	r31, 0x00	; 0
    5dba:	40 81       	ld	r20, Z
    5dbc:	20 91 5c 07 	lds	r18, 0x075C
    5dc0:	30 91 5d 07 	lds	r19, 0x075D
    5dc4:	80 91 61 07 	lds	r24, 0x0761
    5dc8:	88 2f       	mov	r24, r24
    5dca:	90 e0       	ldi	r25, 0x00	; 0
    5dcc:	f9 01       	movw	r30, r18
    5dce:	e8 0f       	add	r30, r24
    5dd0:	f9 1f       	adc	r31, r25
    5dd2:	80 81       	ld	r24, Z
    5dd4:	84 2b       	or	r24, r20
    5dd6:	8c 93       	st	X, r24
			/*Start conversion*/
			SET_BIT(ADCSRA,ADCSRA_ADSC);
    5dd8:	a6 e2       	ldi	r26, 0x26	; 38
    5dda:	b0 e0       	ldi	r27, 0x00	; 0
    5ddc:	e6 e2       	ldi	r30, 0x26	; 38
    5dde:	f0 e0       	ldi	r31, 0x00	; 0
    5de0:	80 81       	ld	r24, Z
    5de2:	80 64       	ori	r24, 0x40	; 64
    5de4:	8c 93       	st	X, r24
		}
	}
}
    5de6:	cf 91       	pop	r28
    5de8:	df 91       	pop	r29
    5dea:	ff 91       	pop	r31
    5dec:	ef 91       	pop	r30
    5dee:	bf 91       	pop	r27
    5df0:	af 91       	pop	r26
    5df2:	9f 91       	pop	r25
    5df4:	8f 91       	pop	r24
    5df6:	7f 91       	pop	r23
    5df8:	6f 91       	pop	r22
    5dfa:	5f 91       	pop	r21
    5dfc:	4f 91       	pop	r20
    5dfe:	3f 91       	pop	r19
    5e00:	2f 91       	pop	r18
    5e02:	0f 90       	pop	r0
    5e04:	0f be       	out	0x3f, r0	; 63
    5e06:	0f 90       	pop	r0
    5e08:	1f 90       	pop	r1
    5e0a:	18 95       	reti

00005e0c <ADC_S16ReadingMap>:
s16 ADC_S16ReadingMap(Map *Map,s16 Copy_u16InputValue)
{
    5e0c:	df 93       	push	r29
    5e0e:	cf 93       	push	r28
    5e10:	00 d0       	rcall	.+0      	; 0x5e12 <ADC_S16ReadingMap+0x6>
    5e12:	00 d0       	rcall	.+0      	; 0x5e14 <ADC_S16ReadingMap+0x8>
    5e14:	00 d0       	rcall	.+0      	; 0x5e16 <ADC_S16ReadingMap+0xa>
    5e16:	cd b7       	in	r28, 0x3d	; 61
    5e18:	de b7       	in	r29, 0x3e	; 62
    5e1a:	9c 83       	std	Y+4, r25	; 0x04
    5e1c:	8b 83       	std	Y+3, r24	; 0x03
    5e1e:	7e 83       	std	Y+6, r23	; 0x06
    5e20:	6d 83       	std	Y+5, r22	; 0x05
	u16 Local_u16MappedValue=0;
    5e22:	1a 82       	std	Y+2, r1	; 0x02
    5e24:	19 82       	std	Y+1, r1	; 0x01
	Local_u16MappedValue=(Map->Copy_u16outMax-Map->Copy_u16outMini);
    5e26:	eb 81       	ldd	r30, Y+3	; 0x03
    5e28:	fc 81       	ldd	r31, Y+4	; 0x04
    5e2a:	26 81       	ldd	r18, Z+6	; 0x06
    5e2c:	37 81       	ldd	r19, Z+7	; 0x07
    5e2e:	eb 81       	ldd	r30, Y+3	; 0x03
    5e30:	fc 81       	ldd	r31, Y+4	; 0x04
    5e32:	84 81       	ldd	r24, Z+4	; 0x04
    5e34:	95 81       	ldd	r25, Z+5	; 0x05
    5e36:	a9 01       	movw	r20, r18
    5e38:	48 1b       	sub	r20, r24
    5e3a:	59 0b       	sbc	r21, r25
    5e3c:	ca 01       	movw	r24, r20
    5e3e:	9a 83       	std	Y+2, r25	; 0x02
    5e40:	89 83       	std	Y+1, r24	; 0x01
	Local_u16MappedValue/=(Map->Copy_u16InputMax-Map->Copy_u16InputMini);
    5e42:	eb 81       	ldd	r30, Y+3	; 0x03
    5e44:	fc 81       	ldd	r31, Y+4	; 0x04
    5e46:	22 81       	ldd	r18, Z+2	; 0x02
    5e48:	33 81       	ldd	r19, Z+3	; 0x03
    5e4a:	eb 81       	ldd	r30, Y+3	; 0x03
    5e4c:	fc 81       	ldd	r31, Y+4	; 0x04
    5e4e:	80 81       	ld	r24, Z
    5e50:	91 81       	ldd	r25, Z+1	; 0x01
    5e52:	a9 01       	movw	r20, r18
    5e54:	48 1b       	sub	r20, r24
    5e56:	59 0b       	sbc	r21, r25
    5e58:	ca 01       	movw	r24, r20
    5e5a:	9c 01       	movw	r18, r24
    5e5c:	89 81       	ldd	r24, Y+1	; 0x01
    5e5e:	9a 81       	ldd	r25, Y+2	; 0x02
    5e60:	b9 01       	movw	r22, r18
    5e62:	0e 94 9d 35 	call	0x6b3a	; 0x6b3a <__udivmodhi4>
    5e66:	cb 01       	movw	r24, r22
    5e68:	9a 83       	std	Y+2, r25	; 0x02
    5e6a:	89 83       	std	Y+1, r24	; 0x01
	Local_u16MappedValue*=(Copy_u16InputValue-Map->Copy_u16InputMini);
    5e6c:	eb 81       	ldd	r30, Y+3	; 0x03
    5e6e:	fc 81       	ldd	r31, Y+4	; 0x04
    5e70:	20 81       	ld	r18, Z
    5e72:	31 81       	ldd	r19, Z+1	; 0x01
    5e74:	8d 81       	ldd	r24, Y+5	; 0x05
    5e76:	9e 81       	ldd	r25, Y+6	; 0x06
    5e78:	82 1b       	sub	r24, r18
    5e7a:	93 0b       	sbc	r25, r19
    5e7c:	9c 01       	movw	r18, r24
    5e7e:	89 81       	ldd	r24, Y+1	; 0x01
    5e80:	9a 81       	ldd	r25, Y+2	; 0x02
    5e82:	ac 01       	movw	r20, r24
    5e84:	42 9f       	mul	r20, r18
    5e86:	c0 01       	movw	r24, r0
    5e88:	43 9f       	mul	r20, r19
    5e8a:	90 0d       	add	r25, r0
    5e8c:	52 9f       	mul	r21, r18
    5e8e:	90 0d       	add	r25, r0
    5e90:	11 24       	eor	r1, r1
    5e92:	9a 83       	std	Y+2, r25	; 0x02
    5e94:	89 83       	std	Y+1, r24	; 0x01
	Local_u16MappedValue+=Map->Copy_u16outMini;
    5e96:	eb 81       	ldd	r30, Y+3	; 0x03
    5e98:	fc 81       	ldd	r31, Y+4	; 0x04
    5e9a:	84 81       	ldd	r24, Z+4	; 0x04
    5e9c:	95 81       	ldd	r25, Z+5	; 0x05
    5e9e:	9c 01       	movw	r18, r24
    5ea0:	89 81       	ldd	r24, Y+1	; 0x01
    5ea2:	9a 81       	ldd	r25, Y+2	; 0x02
    5ea4:	82 0f       	add	r24, r18
    5ea6:	93 1f       	adc	r25, r19
    5ea8:	9a 83       	std	Y+2, r25	; 0x02
    5eaa:	89 83       	std	Y+1, r24	; 0x01
	return Local_u16MappedValue;
    5eac:	89 81       	ldd	r24, Y+1	; 0x01
    5eae:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5eb0:	26 96       	adiw	r28, 0x06	; 6
    5eb2:	0f b6       	in	r0, 0x3f	; 63
    5eb4:	f8 94       	cli
    5eb6:	de bf       	out	0x3e, r29	; 62
    5eb8:	0f be       	out	0x3f, r0	; 63
    5eba:	cd bf       	out	0x3d, r28	; 61
    5ebc:	cf 91       	pop	r28
    5ebe:	df 91       	pop	r29
    5ec0:	08 95       	ret

00005ec2 <GIE_voidEnable>:

#include "GIE_interface.h"
#include "GIE_register.h"

void GIE_voidEnable(void)
{
    5ec2:	df 93       	push	r29
    5ec4:	cf 93       	push	r28
    5ec6:	cd b7       	in	r28, 0x3d	; 61
    5ec8:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(SREG,SREG_I);
    5eca:	af e5       	ldi	r26, 0x5F	; 95
    5ecc:	b0 e0       	ldi	r27, 0x00	; 0
    5ece:	ef e5       	ldi	r30, 0x5F	; 95
    5ed0:	f0 e0       	ldi	r31, 0x00	; 0
    5ed2:	80 81       	ld	r24, Z
    5ed4:	80 68       	ori	r24, 0x80	; 128
    5ed6:	8c 93       	st	X, r24
}
    5ed8:	cf 91       	pop	r28
    5eda:	df 91       	pop	r29
    5edc:	08 95       	ret

00005ede <GIE_voidDisable>:

void GIE_voidDisable(void)
{
    5ede:	df 93       	push	r29
    5ee0:	cf 93       	push	r28
    5ee2:	cd b7       	in	r28, 0x3d	; 61
    5ee4:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(SREG,SREG_I);
    5ee6:	af e5       	ldi	r26, 0x5F	; 95
    5ee8:	b0 e0       	ldi	r27, 0x00	; 0
    5eea:	ef e5       	ldi	r30, 0x5F	; 95
    5eec:	f0 e0       	ldi	r31, 0x00	; 0
    5eee:	80 81       	ld	r24, Z
    5ef0:	8f 77       	andi	r24, 0x7F	; 127
    5ef2:	8c 93       	st	X, r24
}
    5ef4:	cf 91       	pop	r28
    5ef6:	df 91       	pop	r29
    5ef8:	08 95       	ret

00005efa <PORT_voidInit>:
#include "PORT_private.h"
#include "PORT_interface.h"
#include "PORT_register.h"

void PORT_voidInit(void)
{
    5efa:	df 93       	push	r29
    5efc:	cf 93       	push	r28
    5efe:	cd b7       	in	r28, 0x3d	; 61
    5f00:	de b7       	in	r29, 0x3e	; 62
	DDRA=PORTA_DIR;
    5f02:	ea e3       	ldi	r30, 0x3A	; 58
    5f04:	f0 e0       	ldi	r31, 0x00	; 0
    5f06:	86 ef       	ldi	r24, 0xF6	; 246
    5f08:	80 83       	st	Z, r24
	DDRB=PORTB_DIR;
    5f0a:	e7 e3       	ldi	r30, 0x37	; 55
    5f0c:	f0 e0       	ldi	r31, 0x00	; 0
    5f0e:	80 ee       	ldi	r24, 0xE0	; 224
    5f10:	80 83       	st	Z, r24
	DDRC=PORTC_DIR;
    5f12:	e4 e3       	ldi	r30, 0x34	; 52
    5f14:	f0 e0       	ldi	r31, 0x00	; 0
    5f16:	8f ef       	ldi	r24, 0xFF	; 255
    5f18:	80 83       	st	Z, r24
	DDRD=PORTD_DIR;
    5f1a:	e1 e3       	ldi	r30, 0x31	; 49
    5f1c:	f0 e0       	ldi	r31, 0x00	; 0
    5f1e:	8f ef       	ldi	r24, 0xFF	; 255
    5f20:	80 83       	st	Z, r24
	PORTA=PORTA_INITIAL_VALUE;
    5f22:	eb e3       	ldi	r30, 0x3B	; 59
    5f24:	f0 e0       	ldi	r31, 0x00	; 0
    5f26:	80 ef       	ldi	r24, 0xF0	; 240
    5f28:	80 83       	st	Z, r24
	PORTB=PORTB_INITIAL_VALUE;
    5f2a:	e8 e3       	ldi	r30, 0x38	; 56
    5f2c:	f0 e0       	ldi	r31, 0x00	; 0
    5f2e:	8e ef       	ldi	r24, 0xFE	; 254
    5f30:	80 83       	st	Z, r24
	PORTC=PORTC_INITIAL_VALUE;
    5f32:	e5 e3       	ldi	r30, 0x35	; 53
    5f34:	f0 e0       	ldi	r31, 0x00	; 0
    5f36:	10 82       	st	Z, r1
	PORTD=PORTD_INITIAL_VALUE;
    5f38:	e2 e3       	ldi	r30, 0x32	; 50
    5f3a:	f0 e0       	ldi	r31, 0x00	; 0
    5f3c:	10 82       	st	Z, r1
}
    5f3e:	cf 91       	pop	r28
    5f40:	df 91       	pop	r29
    5f42:	08 95       	ret

00005f44 <DIO_u8SetPinValue>:
#include"DIO_interface.h"
#include"DIO_register.h"
#include"DIO_private.h"

u8 DIO_u8SetPinValue(u8 Copy_u8Port, u8 Copy_u8Pin, u8 Copy_u8Value)
{
    5f44:	df 93       	push	r29
    5f46:	cf 93       	push	r28
    5f48:	cd b7       	in	r28, 0x3d	; 61
    5f4a:	de b7       	in	r29, 0x3e	; 62
    5f4c:	28 97       	sbiw	r28, 0x08	; 8
    5f4e:	0f b6       	in	r0, 0x3f	; 63
    5f50:	f8 94       	cli
    5f52:	de bf       	out	0x3e, r29	; 62
    5f54:	0f be       	out	0x3f, r0	; 63
    5f56:	cd bf       	out	0x3d, r28	; 61
    5f58:	8a 83       	std	Y+2, r24	; 0x02
    5f5a:	6b 83       	std	Y+3, r22	; 0x03
    5f5c:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8ErrorState=0;
    5f5e:	19 82       	std	Y+1, r1	; 0x01
	if(Copy_u8Pin<=DIO_u8PIN7)
    5f60:	8b 81       	ldd	r24, Y+3	; 0x03
    5f62:	88 30       	cpi	r24, 0x08	; 8
    5f64:	08 f0       	brcs	.+2      	; 0x5f68 <DIO_u8SetPinValue+0x24>
    5f66:	f4 c0       	rjmp	.+488    	; 0x6150 <DIO_u8SetPinValue+0x20c>
	{
		if(Copy_u8Value==DIO_u8Pin_LOW)
    5f68:	8c 81       	ldd	r24, Y+4	; 0x04
    5f6a:	88 23       	and	r24, r24
    5f6c:	09 f0       	breq	.+2      	; 0x5f70 <DIO_u8SetPinValue+0x2c>
    5f6e:	77 c0       	rjmp	.+238    	; 0x605e <DIO_u8SetPinValue+0x11a>
		{
			switch(Copy_u8Port)
    5f70:	8a 81       	ldd	r24, Y+2	; 0x02
    5f72:	28 2f       	mov	r18, r24
    5f74:	30 e0       	ldi	r19, 0x00	; 0
    5f76:	38 87       	std	Y+8, r19	; 0x08
    5f78:	2f 83       	std	Y+7, r18	; 0x07
    5f7a:	8f 81       	ldd	r24, Y+7	; 0x07
    5f7c:	98 85       	ldd	r25, Y+8	; 0x08
    5f7e:	81 30       	cpi	r24, 0x01	; 1
    5f80:	91 05       	cpc	r25, r1
    5f82:	59 f1       	breq	.+86     	; 0x5fda <DIO_u8SetPinValue+0x96>
    5f84:	2f 81       	ldd	r18, Y+7	; 0x07
    5f86:	38 85       	ldd	r19, Y+8	; 0x08
    5f88:	22 30       	cpi	r18, 0x02	; 2
    5f8a:	31 05       	cpc	r19, r1
    5f8c:	2c f4       	brge	.+10     	; 0x5f98 <DIO_u8SetPinValue+0x54>
    5f8e:	8f 81       	ldd	r24, Y+7	; 0x07
    5f90:	98 85       	ldd	r25, Y+8	; 0x08
    5f92:	00 97       	sbiw	r24, 0x00	; 0
    5f94:	69 f0       	breq	.+26     	; 0x5fb0 <DIO_u8SetPinValue+0x6c>
    5f96:	60 c0       	rjmp	.+192    	; 0x6058 <DIO_u8SetPinValue+0x114>
    5f98:	2f 81       	ldd	r18, Y+7	; 0x07
    5f9a:	38 85       	ldd	r19, Y+8	; 0x08
    5f9c:	22 30       	cpi	r18, 0x02	; 2
    5f9e:	31 05       	cpc	r19, r1
    5fa0:	89 f1       	breq	.+98     	; 0x6004 <DIO_u8SetPinValue+0xc0>
    5fa2:	8f 81       	ldd	r24, Y+7	; 0x07
    5fa4:	98 85       	ldd	r25, Y+8	; 0x08
    5fa6:	83 30       	cpi	r24, 0x03	; 3
    5fa8:	91 05       	cpc	r25, r1
    5faa:	09 f4       	brne	.+2      	; 0x5fae <DIO_u8SetPinValue+0x6a>
    5fac:	40 c0       	rjmp	.+128    	; 0x602e <DIO_u8SetPinValue+0xea>
    5fae:	54 c0       	rjmp	.+168    	; 0x6058 <DIO_u8SetPinValue+0x114>
			{
			case DIO_u8PORTA: CLR_BIT(PORTA,Copy_u8Pin); break;
    5fb0:	ab e3       	ldi	r26, 0x3B	; 59
    5fb2:	b0 e0       	ldi	r27, 0x00	; 0
    5fb4:	eb e3       	ldi	r30, 0x3B	; 59
    5fb6:	f0 e0       	ldi	r31, 0x00	; 0
    5fb8:	80 81       	ld	r24, Z
    5fba:	48 2f       	mov	r20, r24
    5fbc:	8b 81       	ldd	r24, Y+3	; 0x03
    5fbe:	28 2f       	mov	r18, r24
    5fc0:	30 e0       	ldi	r19, 0x00	; 0
    5fc2:	81 e0       	ldi	r24, 0x01	; 1
    5fc4:	90 e0       	ldi	r25, 0x00	; 0
    5fc6:	02 2e       	mov	r0, r18
    5fc8:	02 c0       	rjmp	.+4      	; 0x5fce <DIO_u8SetPinValue+0x8a>
    5fca:	88 0f       	add	r24, r24
    5fcc:	99 1f       	adc	r25, r25
    5fce:	0a 94       	dec	r0
    5fd0:	e2 f7       	brpl	.-8      	; 0x5fca <DIO_u8SetPinValue+0x86>
    5fd2:	80 95       	com	r24
    5fd4:	84 23       	and	r24, r20
    5fd6:	8c 93       	st	X, r24
    5fd8:	bd c0       	rjmp	.+378    	; 0x6154 <DIO_u8SetPinValue+0x210>
			case DIO_u8PORTB: CLR_BIT(PORTB,Copy_u8Pin); break;
    5fda:	a8 e3       	ldi	r26, 0x38	; 56
    5fdc:	b0 e0       	ldi	r27, 0x00	; 0
    5fde:	e8 e3       	ldi	r30, 0x38	; 56
    5fe0:	f0 e0       	ldi	r31, 0x00	; 0
    5fe2:	80 81       	ld	r24, Z
    5fe4:	48 2f       	mov	r20, r24
    5fe6:	8b 81       	ldd	r24, Y+3	; 0x03
    5fe8:	28 2f       	mov	r18, r24
    5fea:	30 e0       	ldi	r19, 0x00	; 0
    5fec:	81 e0       	ldi	r24, 0x01	; 1
    5fee:	90 e0       	ldi	r25, 0x00	; 0
    5ff0:	02 2e       	mov	r0, r18
    5ff2:	02 c0       	rjmp	.+4      	; 0x5ff8 <DIO_u8SetPinValue+0xb4>
    5ff4:	88 0f       	add	r24, r24
    5ff6:	99 1f       	adc	r25, r25
    5ff8:	0a 94       	dec	r0
    5ffa:	e2 f7       	brpl	.-8      	; 0x5ff4 <DIO_u8SetPinValue+0xb0>
    5ffc:	80 95       	com	r24
    5ffe:	84 23       	and	r24, r20
    6000:	8c 93       	st	X, r24
    6002:	a8 c0       	rjmp	.+336    	; 0x6154 <DIO_u8SetPinValue+0x210>
			case DIO_u8PORTC: CLR_BIT(PORTC,Copy_u8Pin); break;
    6004:	a5 e3       	ldi	r26, 0x35	; 53
    6006:	b0 e0       	ldi	r27, 0x00	; 0
    6008:	e5 e3       	ldi	r30, 0x35	; 53
    600a:	f0 e0       	ldi	r31, 0x00	; 0
    600c:	80 81       	ld	r24, Z
    600e:	48 2f       	mov	r20, r24
    6010:	8b 81       	ldd	r24, Y+3	; 0x03
    6012:	28 2f       	mov	r18, r24
    6014:	30 e0       	ldi	r19, 0x00	; 0
    6016:	81 e0       	ldi	r24, 0x01	; 1
    6018:	90 e0       	ldi	r25, 0x00	; 0
    601a:	02 2e       	mov	r0, r18
    601c:	02 c0       	rjmp	.+4      	; 0x6022 <DIO_u8SetPinValue+0xde>
    601e:	88 0f       	add	r24, r24
    6020:	99 1f       	adc	r25, r25
    6022:	0a 94       	dec	r0
    6024:	e2 f7       	brpl	.-8      	; 0x601e <DIO_u8SetPinValue+0xda>
    6026:	80 95       	com	r24
    6028:	84 23       	and	r24, r20
    602a:	8c 93       	st	X, r24
    602c:	93 c0       	rjmp	.+294    	; 0x6154 <DIO_u8SetPinValue+0x210>
			case DIO_u8PORTD: CLR_BIT(PORTD,Copy_u8Pin); break;
    602e:	a2 e3       	ldi	r26, 0x32	; 50
    6030:	b0 e0       	ldi	r27, 0x00	; 0
    6032:	e2 e3       	ldi	r30, 0x32	; 50
    6034:	f0 e0       	ldi	r31, 0x00	; 0
    6036:	80 81       	ld	r24, Z
    6038:	48 2f       	mov	r20, r24
    603a:	8b 81       	ldd	r24, Y+3	; 0x03
    603c:	28 2f       	mov	r18, r24
    603e:	30 e0       	ldi	r19, 0x00	; 0
    6040:	81 e0       	ldi	r24, 0x01	; 1
    6042:	90 e0       	ldi	r25, 0x00	; 0
    6044:	02 2e       	mov	r0, r18
    6046:	02 c0       	rjmp	.+4      	; 0x604c <DIO_u8SetPinValue+0x108>
    6048:	88 0f       	add	r24, r24
    604a:	99 1f       	adc	r25, r25
    604c:	0a 94       	dec	r0
    604e:	e2 f7       	brpl	.-8      	; 0x6048 <DIO_u8SetPinValue+0x104>
    6050:	80 95       	com	r24
    6052:	84 23       	and	r24, r20
    6054:	8c 93       	st	X, r24
    6056:	7e c0       	rjmp	.+252    	; 0x6154 <DIO_u8SetPinValue+0x210>
			default: Local_u8ErrorState=1; break;
    6058:	81 e0       	ldi	r24, 0x01	; 1
    605a:	89 83       	std	Y+1, r24	; 0x01
    605c:	7b c0       	rjmp	.+246    	; 0x6154 <DIO_u8SetPinValue+0x210>
			}
		}
		else if(Copy_u8Value==DIO_u8Pin_HIGH)
    605e:	8c 81       	ldd	r24, Y+4	; 0x04
    6060:	81 30       	cpi	r24, 0x01	; 1
    6062:	09 f0       	breq	.+2      	; 0x6066 <DIO_u8SetPinValue+0x122>
    6064:	72 c0       	rjmp	.+228    	; 0x614a <DIO_u8SetPinValue+0x206>
		{
			switch(Copy_u8Port)
    6066:	8a 81       	ldd	r24, Y+2	; 0x02
    6068:	28 2f       	mov	r18, r24
    606a:	30 e0       	ldi	r19, 0x00	; 0
    606c:	3e 83       	std	Y+6, r19	; 0x06
    606e:	2d 83       	std	Y+5, r18	; 0x05
    6070:	8d 81       	ldd	r24, Y+5	; 0x05
    6072:	9e 81       	ldd	r25, Y+6	; 0x06
    6074:	81 30       	cpi	r24, 0x01	; 1
    6076:	91 05       	cpc	r25, r1
    6078:	49 f1       	breq	.+82     	; 0x60cc <DIO_u8SetPinValue+0x188>
    607a:	2d 81       	ldd	r18, Y+5	; 0x05
    607c:	3e 81       	ldd	r19, Y+6	; 0x06
    607e:	22 30       	cpi	r18, 0x02	; 2
    6080:	31 05       	cpc	r19, r1
    6082:	2c f4       	brge	.+10     	; 0x608e <DIO_u8SetPinValue+0x14a>
    6084:	8d 81       	ldd	r24, Y+5	; 0x05
    6086:	9e 81       	ldd	r25, Y+6	; 0x06
    6088:	00 97       	sbiw	r24, 0x00	; 0
    608a:	61 f0       	breq	.+24     	; 0x60a4 <DIO_u8SetPinValue+0x160>
    608c:	5b c0       	rjmp	.+182    	; 0x6144 <DIO_u8SetPinValue+0x200>
    608e:	2d 81       	ldd	r18, Y+5	; 0x05
    6090:	3e 81       	ldd	r19, Y+6	; 0x06
    6092:	22 30       	cpi	r18, 0x02	; 2
    6094:	31 05       	cpc	r19, r1
    6096:	71 f1       	breq	.+92     	; 0x60f4 <DIO_u8SetPinValue+0x1b0>
    6098:	8d 81       	ldd	r24, Y+5	; 0x05
    609a:	9e 81       	ldd	r25, Y+6	; 0x06
    609c:	83 30       	cpi	r24, 0x03	; 3
    609e:	91 05       	cpc	r25, r1
    60a0:	e9 f1       	breq	.+122    	; 0x611c <DIO_u8SetPinValue+0x1d8>
    60a2:	50 c0       	rjmp	.+160    	; 0x6144 <DIO_u8SetPinValue+0x200>
			{
			case DIO_u8PORTA: SET_BIT(PORTA,Copy_u8Pin); break;
    60a4:	ab e3       	ldi	r26, 0x3B	; 59
    60a6:	b0 e0       	ldi	r27, 0x00	; 0
    60a8:	eb e3       	ldi	r30, 0x3B	; 59
    60aa:	f0 e0       	ldi	r31, 0x00	; 0
    60ac:	80 81       	ld	r24, Z
    60ae:	48 2f       	mov	r20, r24
    60b0:	8b 81       	ldd	r24, Y+3	; 0x03
    60b2:	28 2f       	mov	r18, r24
    60b4:	30 e0       	ldi	r19, 0x00	; 0
    60b6:	81 e0       	ldi	r24, 0x01	; 1
    60b8:	90 e0       	ldi	r25, 0x00	; 0
    60ba:	02 2e       	mov	r0, r18
    60bc:	02 c0       	rjmp	.+4      	; 0x60c2 <DIO_u8SetPinValue+0x17e>
    60be:	88 0f       	add	r24, r24
    60c0:	99 1f       	adc	r25, r25
    60c2:	0a 94       	dec	r0
    60c4:	e2 f7       	brpl	.-8      	; 0x60be <DIO_u8SetPinValue+0x17a>
    60c6:	84 2b       	or	r24, r20
    60c8:	8c 93       	st	X, r24
    60ca:	44 c0       	rjmp	.+136    	; 0x6154 <DIO_u8SetPinValue+0x210>
			case DIO_u8PORTB: SET_BIT(PORTB,Copy_u8Pin); break;
    60cc:	a8 e3       	ldi	r26, 0x38	; 56
    60ce:	b0 e0       	ldi	r27, 0x00	; 0
    60d0:	e8 e3       	ldi	r30, 0x38	; 56
    60d2:	f0 e0       	ldi	r31, 0x00	; 0
    60d4:	80 81       	ld	r24, Z
    60d6:	48 2f       	mov	r20, r24
    60d8:	8b 81       	ldd	r24, Y+3	; 0x03
    60da:	28 2f       	mov	r18, r24
    60dc:	30 e0       	ldi	r19, 0x00	; 0
    60de:	81 e0       	ldi	r24, 0x01	; 1
    60e0:	90 e0       	ldi	r25, 0x00	; 0
    60e2:	02 2e       	mov	r0, r18
    60e4:	02 c0       	rjmp	.+4      	; 0x60ea <DIO_u8SetPinValue+0x1a6>
    60e6:	88 0f       	add	r24, r24
    60e8:	99 1f       	adc	r25, r25
    60ea:	0a 94       	dec	r0
    60ec:	e2 f7       	brpl	.-8      	; 0x60e6 <DIO_u8SetPinValue+0x1a2>
    60ee:	84 2b       	or	r24, r20
    60f0:	8c 93       	st	X, r24
    60f2:	30 c0       	rjmp	.+96     	; 0x6154 <DIO_u8SetPinValue+0x210>
			case DIO_u8PORTC: SET_BIT(PORTC,Copy_u8Pin); break;
    60f4:	a5 e3       	ldi	r26, 0x35	; 53
    60f6:	b0 e0       	ldi	r27, 0x00	; 0
    60f8:	e5 e3       	ldi	r30, 0x35	; 53
    60fa:	f0 e0       	ldi	r31, 0x00	; 0
    60fc:	80 81       	ld	r24, Z
    60fe:	48 2f       	mov	r20, r24
    6100:	8b 81       	ldd	r24, Y+3	; 0x03
    6102:	28 2f       	mov	r18, r24
    6104:	30 e0       	ldi	r19, 0x00	; 0
    6106:	81 e0       	ldi	r24, 0x01	; 1
    6108:	90 e0       	ldi	r25, 0x00	; 0
    610a:	02 2e       	mov	r0, r18
    610c:	02 c0       	rjmp	.+4      	; 0x6112 <DIO_u8SetPinValue+0x1ce>
    610e:	88 0f       	add	r24, r24
    6110:	99 1f       	adc	r25, r25
    6112:	0a 94       	dec	r0
    6114:	e2 f7       	brpl	.-8      	; 0x610e <DIO_u8SetPinValue+0x1ca>
    6116:	84 2b       	or	r24, r20
    6118:	8c 93       	st	X, r24
    611a:	1c c0       	rjmp	.+56     	; 0x6154 <DIO_u8SetPinValue+0x210>
			case DIO_u8PORTD: SET_BIT(PORTD,Copy_u8Pin); break;
    611c:	a2 e3       	ldi	r26, 0x32	; 50
    611e:	b0 e0       	ldi	r27, 0x00	; 0
    6120:	e2 e3       	ldi	r30, 0x32	; 50
    6122:	f0 e0       	ldi	r31, 0x00	; 0
    6124:	80 81       	ld	r24, Z
    6126:	48 2f       	mov	r20, r24
    6128:	8b 81       	ldd	r24, Y+3	; 0x03
    612a:	28 2f       	mov	r18, r24
    612c:	30 e0       	ldi	r19, 0x00	; 0
    612e:	81 e0       	ldi	r24, 0x01	; 1
    6130:	90 e0       	ldi	r25, 0x00	; 0
    6132:	02 2e       	mov	r0, r18
    6134:	02 c0       	rjmp	.+4      	; 0x613a <DIO_u8SetPinValue+0x1f6>
    6136:	88 0f       	add	r24, r24
    6138:	99 1f       	adc	r25, r25
    613a:	0a 94       	dec	r0
    613c:	e2 f7       	brpl	.-8      	; 0x6136 <DIO_u8SetPinValue+0x1f2>
    613e:	84 2b       	or	r24, r20
    6140:	8c 93       	st	X, r24
    6142:	08 c0       	rjmp	.+16     	; 0x6154 <DIO_u8SetPinValue+0x210>
			default: Local_u8ErrorState=1; break;
    6144:	81 e0       	ldi	r24, 0x01	; 1
    6146:	89 83       	std	Y+1, r24	; 0x01
    6148:	05 c0       	rjmp	.+10     	; 0x6154 <DIO_u8SetPinValue+0x210>
			}
		}
		else
		{
			Local_u8ErrorState=1;
    614a:	81 e0       	ldi	r24, 0x01	; 1
    614c:	89 83       	std	Y+1, r24	; 0x01
    614e:	02 c0       	rjmp	.+4      	; 0x6154 <DIO_u8SetPinValue+0x210>
		}
	}
	else
	{
		Local_u8ErrorState=1;
    6150:	81 e0       	ldi	r24, 0x01	; 1
    6152:	89 83       	std	Y+1, r24	; 0x01
	}

	return Local_u8ErrorState;
    6154:	89 81       	ldd	r24, Y+1	; 0x01
}
    6156:	28 96       	adiw	r28, 0x08	; 8
    6158:	0f b6       	in	r0, 0x3f	; 63
    615a:	f8 94       	cli
    615c:	de bf       	out	0x3e, r29	; 62
    615e:	0f be       	out	0x3f, r0	; 63
    6160:	cd bf       	out	0x3d, r28	; 61
    6162:	cf 91       	pop	r28
    6164:	df 91       	pop	r29
    6166:	08 95       	ret

00006168 <DIO_u8SetPortValue>:

u8 DIO_u8SetPortValue(u8 Copy_u8Port, u8 Copy_u8Value)
{
    6168:	df 93       	push	r29
    616a:	cf 93       	push	r28
    616c:	00 d0       	rcall	.+0      	; 0x616e <DIO_u8SetPortValue+0x6>
    616e:	00 d0       	rcall	.+0      	; 0x6170 <DIO_u8SetPortValue+0x8>
    6170:	0f 92       	push	r0
    6172:	cd b7       	in	r28, 0x3d	; 61
    6174:	de b7       	in	r29, 0x3e	; 62
    6176:	8a 83       	std	Y+2, r24	; 0x02
    6178:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErrorState=0;
    617a:	19 82       	std	Y+1, r1	; 0x01
	switch(Copy_u8Port)
    617c:	8a 81       	ldd	r24, Y+2	; 0x02
    617e:	28 2f       	mov	r18, r24
    6180:	30 e0       	ldi	r19, 0x00	; 0
    6182:	3d 83       	std	Y+5, r19	; 0x05
    6184:	2c 83       	std	Y+4, r18	; 0x04
    6186:	8c 81       	ldd	r24, Y+4	; 0x04
    6188:	9d 81       	ldd	r25, Y+5	; 0x05
    618a:	81 30       	cpi	r24, 0x01	; 1
    618c:	91 05       	cpc	r25, r1
    618e:	d1 f0       	breq	.+52     	; 0x61c4 <DIO_u8SetPortValue+0x5c>
    6190:	2c 81       	ldd	r18, Y+4	; 0x04
    6192:	3d 81       	ldd	r19, Y+5	; 0x05
    6194:	22 30       	cpi	r18, 0x02	; 2
    6196:	31 05       	cpc	r19, r1
    6198:	2c f4       	brge	.+10     	; 0x61a4 <DIO_u8SetPortValue+0x3c>
    619a:	8c 81       	ldd	r24, Y+4	; 0x04
    619c:	9d 81       	ldd	r25, Y+5	; 0x05
    619e:	00 97       	sbiw	r24, 0x00	; 0
    61a0:	61 f0       	breq	.+24     	; 0x61ba <DIO_u8SetPortValue+0x52>
    61a2:	1f c0       	rjmp	.+62     	; 0x61e2 <DIO_u8SetPortValue+0x7a>
    61a4:	2c 81       	ldd	r18, Y+4	; 0x04
    61a6:	3d 81       	ldd	r19, Y+5	; 0x05
    61a8:	22 30       	cpi	r18, 0x02	; 2
    61aa:	31 05       	cpc	r19, r1
    61ac:	81 f0       	breq	.+32     	; 0x61ce <DIO_u8SetPortValue+0x66>
    61ae:	8c 81       	ldd	r24, Y+4	; 0x04
    61b0:	9d 81       	ldd	r25, Y+5	; 0x05
    61b2:	83 30       	cpi	r24, 0x03	; 3
    61b4:	91 05       	cpc	r25, r1
    61b6:	81 f0       	breq	.+32     	; 0x61d8 <DIO_u8SetPortValue+0x70>
    61b8:	14 c0       	rjmp	.+40     	; 0x61e2 <DIO_u8SetPortValue+0x7a>
	{
	case DIO_u8PORTA: PORTA=Copy_u8Value; break;
    61ba:	eb e3       	ldi	r30, 0x3B	; 59
    61bc:	f0 e0       	ldi	r31, 0x00	; 0
    61be:	8b 81       	ldd	r24, Y+3	; 0x03
    61c0:	80 83       	st	Z, r24
    61c2:	11 c0       	rjmp	.+34     	; 0x61e6 <DIO_u8SetPortValue+0x7e>
	case DIO_u8PORTB: PORTB=Copy_u8Value; break;
    61c4:	e8 e3       	ldi	r30, 0x38	; 56
    61c6:	f0 e0       	ldi	r31, 0x00	; 0
    61c8:	8b 81       	ldd	r24, Y+3	; 0x03
    61ca:	80 83       	st	Z, r24
    61cc:	0c c0       	rjmp	.+24     	; 0x61e6 <DIO_u8SetPortValue+0x7e>
	case DIO_u8PORTC: PORTC=Copy_u8Value; break;
    61ce:	e5 e3       	ldi	r30, 0x35	; 53
    61d0:	f0 e0       	ldi	r31, 0x00	; 0
    61d2:	8b 81       	ldd	r24, Y+3	; 0x03
    61d4:	80 83       	st	Z, r24
    61d6:	07 c0       	rjmp	.+14     	; 0x61e6 <DIO_u8SetPortValue+0x7e>
	case DIO_u8PORTD: PORTD=Copy_u8Value; break;
    61d8:	e2 e3       	ldi	r30, 0x32	; 50
    61da:	f0 e0       	ldi	r31, 0x00	; 0
    61dc:	8b 81       	ldd	r24, Y+3	; 0x03
    61de:	80 83       	st	Z, r24
    61e0:	02 c0       	rjmp	.+4      	; 0x61e6 <DIO_u8SetPortValue+0x7e>
	default: Local_u8ErrorState=1; break;
    61e2:	81 e0       	ldi	r24, 0x01	; 1
    61e4:	89 83       	std	Y+1, r24	; 0x01
	}

	return Local_u8ErrorState;
    61e6:	89 81       	ldd	r24, Y+1	; 0x01
}
    61e8:	0f 90       	pop	r0
    61ea:	0f 90       	pop	r0
    61ec:	0f 90       	pop	r0
    61ee:	0f 90       	pop	r0
    61f0:	0f 90       	pop	r0
    61f2:	cf 91       	pop	r28
    61f4:	df 91       	pop	r29
    61f6:	08 95       	ret

000061f8 <DIO_u8TogglePinValue>:

u8 DIO_u8TogglePinValue(u8 Copy_u8Port, u8 Copy_u8Pin)
{
    61f8:	df 93       	push	r29
    61fa:	cf 93       	push	r28
    61fc:	00 d0       	rcall	.+0      	; 0x61fe <DIO_u8TogglePinValue+0x6>
    61fe:	00 d0       	rcall	.+0      	; 0x6200 <DIO_u8TogglePinValue+0x8>
    6200:	0f 92       	push	r0
    6202:	cd b7       	in	r28, 0x3d	; 61
    6204:	de b7       	in	r29, 0x3e	; 62
    6206:	8a 83       	std	Y+2, r24	; 0x02
    6208:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErrorState=0;
    620a:	19 82       	std	Y+1, r1	; 0x01
	if(Copy_u8Pin<=DIO_u8PIN7)
    620c:	8b 81       	ldd	r24, Y+3	; 0x03
    620e:	88 30       	cpi	r24, 0x08	; 8
    6210:	08 f0       	brcs	.+2      	; 0x6214 <DIO_u8TogglePinValue+0x1c>
    6212:	72 c0       	rjmp	.+228    	; 0x62f8 <DIO_u8TogglePinValue+0x100>
	{
		switch(Copy_u8Port)
    6214:	8a 81       	ldd	r24, Y+2	; 0x02
    6216:	28 2f       	mov	r18, r24
    6218:	30 e0       	ldi	r19, 0x00	; 0
    621a:	3d 83       	std	Y+5, r19	; 0x05
    621c:	2c 83       	std	Y+4, r18	; 0x04
    621e:	8c 81       	ldd	r24, Y+4	; 0x04
    6220:	9d 81       	ldd	r25, Y+5	; 0x05
    6222:	81 30       	cpi	r24, 0x01	; 1
    6224:	91 05       	cpc	r25, r1
    6226:	49 f1       	breq	.+82     	; 0x627a <DIO_u8TogglePinValue+0x82>
    6228:	2c 81       	ldd	r18, Y+4	; 0x04
    622a:	3d 81       	ldd	r19, Y+5	; 0x05
    622c:	22 30       	cpi	r18, 0x02	; 2
    622e:	31 05       	cpc	r19, r1
    6230:	2c f4       	brge	.+10     	; 0x623c <DIO_u8TogglePinValue+0x44>
    6232:	8c 81       	ldd	r24, Y+4	; 0x04
    6234:	9d 81       	ldd	r25, Y+5	; 0x05
    6236:	00 97       	sbiw	r24, 0x00	; 0
    6238:	61 f0       	breq	.+24     	; 0x6252 <DIO_u8TogglePinValue+0x5a>
    623a:	5b c0       	rjmp	.+182    	; 0x62f2 <DIO_u8TogglePinValue+0xfa>
    623c:	2c 81       	ldd	r18, Y+4	; 0x04
    623e:	3d 81       	ldd	r19, Y+5	; 0x05
    6240:	22 30       	cpi	r18, 0x02	; 2
    6242:	31 05       	cpc	r19, r1
    6244:	71 f1       	breq	.+92     	; 0x62a2 <DIO_u8TogglePinValue+0xaa>
    6246:	8c 81       	ldd	r24, Y+4	; 0x04
    6248:	9d 81       	ldd	r25, Y+5	; 0x05
    624a:	83 30       	cpi	r24, 0x03	; 3
    624c:	91 05       	cpc	r25, r1
    624e:	e9 f1       	breq	.+122    	; 0x62ca <DIO_u8TogglePinValue+0xd2>
    6250:	50 c0       	rjmp	.+160    	; 0x62f2 <DIO_u8TogglePinValue+0xfa>
		{
		case DIO_u8PORTA: TOGGLE_BIT(PORTA,Copy_u8Pin); break;
    6252:	ab e3       	ldi	r26, 0x3B	; 59
    6254:	b0 e0       	ldi	r27, 0x00	; 0
    6256:	eb e3       	ldi	r30, 0x3B	; 59
    6258:	f0 e0       	ldi	r31, 0x00	; 0
    625a:	80 81       	ld	r24, Z
    625c:	48 2f       	mov	r20, r24
    625e:	8b 81       	ldd	r24, Y+3	; 0x03
    6260:	28 2f       	mov	r18, r24
    6262:	30 e0       	ldi	r19, 0x00	; 0
    6264:	81 e0       	ldi	r24, 0x01	; 1
    6266:	90 e0       	ldi	r25, 0x00	; 0
    6268:	02 2e       	mov	r0, r18
    626a:	02 c0       	rjmp	.+4      	; 0x6270 <DIO_u8TogglePinValue+0x78>
    626c:	88 0f       	add	r24, r24
    626e:	99 1f       	adc	r25, r25
    6270:	0a 94       	dec	r0
    6272:	e2 f7       	brpl	.-8      	; 0x626c <DIO_u8TogglePinValue+0x74>
    6274:	84 27       	eor	r24, r20
    6276:	8c 93       	st	X, r24
    6278:	41 c0       	rjmp	.+130    	; 0x62fc <DIO_u8TogglePinValue+0x104>
		case DIO_u8PORTB: TOGGLE_BIT(PORTB,Copy_u8Pin); break;
    627a:	a8 e3       	ldi	r26, 0x38	; 56
    627c:	b0 e0       	ldi	r27, 0x00	; 0
    627e:	e8 e3       	ldi	r30, 0x38	; 56
    6280:	f0 e0       	ldi	r31, 0x00	; 0
    6282:	80 81       	ld	r24, Z
    6284:	48 2f       	mov	r20, r24
    6286:	8b 81       	ldd	r24, Y+3	; 0x03
    6288:	28 2f       	mov	r18, r24
    628a:	30 e0       	ldi	r19, 0x00	; 0
    628c:	81 e0       	ldi	r24, 0x01	; 1
    628e:	90 e0       	ldi	r25, 0x00	; 0
    6290:	02 2e       	mov	r0, r18
    6292:	02 c0       	rjmp	.+4      	; 0x6298 <DIO_u8TogglePinValue+0xa0>
    6294:	88 0f       	add	r24, r24
    6296:	99 1f       	adc	r25, r25
    6298:	0a 94       	dec	r0
    629a:	e2 f7       	brpl	.-8      	; 0x6294 <DIO_u8TogglePinValue+0x9c>
    629c:	84 27       	eor	r24, r20
    629e:	8c 93       	st	X, r24
    62a0:	2d c0       	rjmp	.+90     	; 0x62fc <DIO_u8TogglePinValue+0x104>
		case DIO_u8PORTC: TOGGLE_BIT(PORTC,Copy_u8Pin); break;
    62a2:	a5 e3       	ldi	r26, 0x35	; 53
    62a4:	b0 e0       	ldi	r27, 0x00	; 0
    62a6:	e5 e3       	ldi	r30, 0x35	; 53
    62a8:	f0 e0       	ldi	r31, 0x00	; 0
    62aa:	80 81       	ld	r24, Z
    62ac:	48 2f       	mov	r20, r24
    62ae:	8b 81       	ldd	r24, Y+3	; 0x03
    62b0:	28 2f       	mov	r18, r24
    62b2:	30 e0       	ldi	r19, 0x00	; 0
    62b4:	81 e0       	ldi	r24, 0x01	; 1
    62b6:	90 e0       	ldi	r25, 0x00	; 0
    62b8:	02 2e       	mov	r0, r18
    62ba:	02 c0       	rjmp	.+4      	; 0x62c0 <DIO_u8TogglePinValue+0xc8>
    62bc:	88 0f       	add	r24, r24
    62be:	99 1f       	adc	r25, r25
    62c0:	0a 94       	dec	r0
    62c2:	e2 f7       	brpl	.-8      	; 0x62bc <DIO_u8TogglePinValue+0xc4>
    62c4:	84 27       	eor	r24, r20
    62c6:	8c 93       	st	X, r24
    62c8:	19 c0       	rjmp	.+50     	; 0x62fc <DIO_u8TogglePinValue+0x104>
		case DIO_u8PORTD: TOGGLE_BIT(PORTD,Copy_u8Pin); break;
    62ca:	a2 e3       	ldi	r26, 0x32	; 50
    62cc:	b0 e0       	ldi	r27, 0x00	; 0
    62ce:	e2 e3       	ldi	r30, 0x32	; 50
    62d0:	f0 e0       	ldi	r31, 0x00	; 0
    62d2:	80 81       	ld	r24, Z
    62d4:	48 2f       	mov	r20, r24
    62d6:	8b 81       	ldd	r24, Y+3	; 0x03
    62d8:	28 2f       	mov	r18, r24
    62da:	30 e0       	ldi	r19, 0x00	; 0
    62dc:	81 e0       	ldi	r24, 0x01	; 1
    62de:	90 e0       	ldi	r25, 0x00	; 0
    62e0:	02 2e       	mov	r0, r18
    62e2:	02 c0       	rjmp	.+4      	; 0x62e8 <DIO_u8TogglePinValue+0xf0>
    62e4:	88 0f       	add	r24, r24
    62e6:	99 1f       	adc	r25, r25
    62e8:	0a 94       	dec	r0
    62ea:	e2 f7       	brpl	.-8      	; 0x62e4 <DIO_u8TogglePinValue+0xec>
    62ec:	84 27       	eor	r24, r20
    62ee:	8c 93       	st	X, r24
    62f0:	05 c0       	rjmp	.+10     	; 0x62fc <DIO_u8TogglePinValue+0x104>
		default: Local_u8ErrorState=1; break;
    62f2:	81 e0       	ldi	r24, 0x01	; 1
    62f4:	89 83       	std	Y+1, r24	; 0x01
    62f6:	02 c0       	rjmp	.+4      	; 0x62fc <DIO_u8TogglePinValue+0x104>

		}
	}
	else
	{
		Local_u8ErrorState=1;
    62f8:	81 e0       	ldi	r24, 0x01	; 1
    62fa:	89 83       	std	Y+1, r24	; 0x01
	}

	return Local_u8ErrorState;
    62fc:	89 81       	ldd	r24, Y+1	; 0x01
}
    62fe:	0f 90       	pop	r0
    6300:	0f 90       	pop	r0
    6302:	0f 90       	pop	r0
    6304:	0f 90       	pop	r0
    6306:	0f 90       	pop	r0
    6308:	cf 91       	pop	r28
    630a:	df 91       	pop	r29
    630c:	08 95       	ret

0000630e <DIO_u8GetPinValue>:

u8 DIO_u8GetPinValue(u8 Copy_u8Port, u8 Copy_u8Pin, u8* Copy_Pu8Value)
{
    630e:	df 93       	push	r29
    6310:	cf 93       	push	r28
    6312:	cd b7       	in	r28, 0x3d	; 61
    6314:	de b7       	in	r29, 0x3e	; 62
    6316:	27 97       	sbiw	r28, 0x07	; 7
    6318:	0f b6       	in	r0, 0x3f	; 63
    631a:	f8 94       	cli
    631c:	de bf       	out	0x3e, r29	; 62
    631e:	0f be       	out	0x3f, r0	; 63
    6320:	cd bf       	out	0x3d, r28	; 61
    6322:	8a 83       	std	Y+2, r24	; 0x02
    6324:	6b 83       	std	Y+3, r22	; 0x03
    6326:	5d 83       	std	Y+5, r21	; 0x05
    6328:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8ErrorState=0;
    632a:	19 82       	std	Y+1, r1	; 0x01
	if((Copy_Pu8Value!=NULL) && (Copy_u8Pin<=DIO_u8PIN7))
    632c:	8c 81       	ldd	r24, Y+4	; 0x04
    632e:	9d 81       	ldd	r25, Y+5	; 0x05
    6330:	00 97       	sbiw	r24, 0x00	; 0
    6332:	09 f4       	brne	.+2      	; 0x6336 <DIO_u8GetPinValue+0x28>
    6334:	78 c0       	rjmp	.+240    	; 0x6426 <DIO_u8GetPinValue+0x118>
    6336:	8b 81       	ldd	r24, Y+3	; 0x03
    6338:	88 30       	cpi	r24, 0x08	; 8
    633a:	08 f0       	brcs	.+2      	; 0x633e <DIO_u8GetPinValue+0x30>
    633c:	74 c0       	rjmp	.+232    	; 0x6426 <DIO_u8GetPinValue+0x118>
	{
		switch(Copy_u8Port)
    633e:	8a 81       	ldd	r24, Y+2	; 0x02
    6340:	28 2f       	mov	r18, r24
    6342:	30 e0       	ldi	r19, 0x00	; 0
    6344:	3f 83       	std	Y+7, r19	; 0x07
    6346:	2e 83       	std	Y+6, r18	; 0x06
    6348:	4e 81       	ldd	r20, Y+6	; 0x06
    634a:	5f 81       	ldd	r21, Y+7	; 0x07
    634c:	41 30       	cpi	r20, 0x01	; 1
    634e:	51 05       	cpc	r21, r1
    6350:	59 f1       	breq	.+86     	; 0x63a8 <DIO_u8GetPinValue+0x9a>
    6352:	8e 81       	ldd	r24, Y+6	; 0x06
    6354:	9f 81       	ldd	r25, Y+7	; 0x07
    6356:	82 30       	cpi	r24, 0x02	; 2
    6358:	91 05       	cpc	r25, r1
    635a:	34 f4       	brge	.+12     	; 0x6368 <DIO_u8GetPinValue+0x5a>
    635c:	2e 81       	ldd	r18, Y+6	; 0x06
    635e:	3f 81       	ldd	r19, Y+7	; 0x07
    6360:	21 15       	cp	r18, r1
    6362:	31 05       	cpc	r19, r1
    6364:	69 f0       	breq	.+26     	; 0x6380 <DIO_u8GetPinValue+0x72>
    6366:	5c c0       	rjmp	.+184    	; 0x6420 <DIO_u8GetPinValue+0x112>
    6368:	4e 81       	ldd	r20, Y+6	; 0x06
    636a:	5f 81       	ldd	r21, Y+7	; 0x07
    636c:	42 30       	cpi	r20, 0x02	; 2
    636e:	51 05       	cpc	r21, r1
    6370:	79 f1       	breq	.+94     	; 0x63d0 <DIO_u8GetPinValue+0xc2>
    6372:	8e 81       	ldd	r24, Y+6	; 0x06
    6374:	9f 81       	ldd	r25, Y+7	; 0x07
    6376:	83 30       	cpi	r24, 0x03	; 3
    6378:	91 05       	cpc	r25, r1
    637a:	09 f4       	brne	.+2      	; 0x637e <DIO_u8GetPinValue+0x70>
    637c:	3d c0       	rjmp	.+122    	; 0x63f8 <DIO_u8GetPinValue+0xea>
    637e:	50 c0       	rjmp	.+160    	; 0x6420 <DIO_u8GetPinValue+0x112>
		{
		case DIO_u8PORTA: *Copy_Pu8Value=GET_BIT(PINA, Copy_u8Pin); break;
    6380:	e9 e3       	ldi	r30, 0x39	; 57
    6382:	f0 e0       	ldi	r31, 0x00	; 0
    6384:	80 81       	ld	r24, Z
    6386:	28 2f       	mov	r18, r24
    6388:	30 e0       	ldi	r19, 0x00	; 0
    638a:	8b 81       	ldd	r24, Y+3	; 0x03
    638c:	88 2f       	mov	r24, r24
    638e:	90 e0       	ldi	r25, 0x00	; 0
    6390:	a9 01       	movw	r20, r18
    6392:	02 c0       	rjmp	.+4      	; 0x6398 <DIO_u8GetPinValue+0x8a>
    6394:	55 95       	asr	r21
    6396:	47 95       	ror	r20
    6398:	8a 95       	dec	r24
    639a:	e2 f7       	brpl	.-8      	; 0x6394 <DIO_u8GetPinValue+0x86>
    639c:	ca 01       	movw	r24, r20
    639e:	81 70       	andi	r24, 0x01	; 1
    63a0:	ec 81       	ldd	r30, Y+4	; 0x04
    63a2:	fd 81       	ldd	r31, Y+5	; 0x05
    63a4:	80 83       	st	Z, r24
    63a6:	41 c0       	rjmp	.+130    	; 0x642a <DIO_u8GetPinValue+0x11c>
		case DIO_u8PORTB: *Copy_Pu8Value=GET_BIT(PINB, Copy_u8Pin); break;
    63a8:	e6 e3       	ldi	r30, 0x36	; 54
    63aa:	f0 e0       	ldi	r31, 0x00	; 0
    63ac:	80 81       	ld	r24, Z
    63ae:	28 2f       	mov	r18, r24
    63b0:	30 e0       	ldi	r19, 0x00	; 0
    63b2:	8b 81       	ldd	r24, Y+3	; 0x03
    63b4:	88 2f       	mov	r24, r24
    63b6:	90 e0       	ldi	r25, 0x00	; 0
    63b8:	a9 01       	movw	r20, r18
    63ba:	02 c0       	rjmp	.+4      	; 0x63c0 <DIO_u8GetPinValue+0xb2>
    63bc:	55 95       	asr	r21
    63be:	47 95       	ror	r20
    63c0:	8a 95       	dec	r24
    63c2:	e2 f7       	brpl	.-8      	; 0x63bc <DIO_u8GetPinValue+0xae>
    63c4:	ca 01       	movw	r24, r20
    63c6:	81 70       	andi	r24, 0x01	; 1
    63c8:	ec 81       	ldd	r30, Y+4	; 0x04
    63ca:	fd 81       	ldd	r31, Y+5	; 0x05
    63cc:	80 83       	st	Z, r24
    63ce:	2d c0       	rjmp	.+90     	; 0x642a <DIO_u8GetPinValue+0x11c>
		case DIO_u8PORTC: *Copy_Pu8Value=GET_BIT(PINC, Copy_u8Pin); break;
    63d0:	e3 e3       	ldi	r30, 0x33	; 51
    63d2:	f0 e0       	ldi	r31, 0x00	; 0
    63d4:	80 81       	ld	r24, Z
    63d6:	28 2f       	mov	r18, r24
    63d8:	30 e0       	ldi	r19, 0x00	; 0
    63da:	8b 81       	ldd	r24, Y+3	; 0x03
    63dc:	88 2f       	mov	r24, r24
    63de:	90 e0       	ldi	r25, 0x00	; 0
    63e0:	a9 01       	movw	r20, r18
    63e2:	02 c0       	rjmp	.+4      	; 0x63e8 <DIO_u8GetPinValue+0xda>
    63e4:	55 95       	asr	r21
    63e6:	47 95       	ror	r20
    63e8:	8a 95       	dec	r24
    63ea:	e2 f7       	brpl	.-8      	; 0x63e4 <DIO_u8GetPinValue+0xd6>
    63ec:	ca 01       	movw	r24, r20
    63ee:	81 70       	andi	r24, 0x01	; 1
    63f0:	ec 81       	ldd	r30, Y+4	; 0x04
    63f2:	fd 81       	ldd	r31, Y+5	; 0x05
    63f4:	80 83       	st	Z, r24
    63f6:	19 c0       	rjmp	.+50     	; 0x642a <DIO_u8GetPinValue+0x11c>
		case DIO_u8PORTD: *Copy_Pu8Value=GET_BIT(PIND, Copy_u8Pin); break;
    63f8:	e0 e3       	ldi	r30, 0x30	; 48
    63fa:	f0 e0       	ldi	r31, 0x00	; 0
    63fc:	80 81       	ld	r24, Z
    63fe:	28 2f       	mov	r18, r24
    6400:	30 e0       	ldi	r19, 0x00	; 0
    6402:	8b 81       	ldd	r24, Y+3	; 0x03
    6404:	88 2f       	mov	r24, r24
    6406:	90 e0       	ldi	r25, 0x00	; 0
    6408:	a9 01       	movw	r20, r18
    640a:	02 c0       	rjmp	.+4      	; 0x6410 <DIO_u8GetPinValue+0x102>
    640c:	55 95       	asr	r21
    640e:	47 95       	ror	r20
    6410:	8a 95       	dec	r24
    6412:	e2 f7       	brpl	.-8      	; 0x640c <DIO_u8GetPinValue+0xfe>
    6414:	ca 01       	movw	r24, r20
    6416:	81 70       	andi	r24, 0x01	; 1
    6418:	ec 81       	ldd	r30, Y+4	; 0x04
    641a:	fd 81       	ldd	r31, Y+5	; 0x05
    641c:	80 83       	st	Z, r24
    641e:	05 c0       	rjmp	.+10     	; 0x642a <DIO_u8GetPinValue+0x11c>
		default: Local_u8ErrorState=1; break;
    6420:	81 e0       	ldi	r24, 0x01	; 1
    6422:	89 83       	std	Y+1, r24	; 0x01
    6424:	02 c0       	rjmp	.+4      	; 0x642a <DIO_u8GetPinValue+0x11c>
		}
	}
	else
	{
		Local_u8ErrorState=1;
    6426:	81 e0       	ldi	r24, 0x01	; 1
    6428:	89 83       	std	Y+1, r24	; 0x01
	}
	return Local_u8ErrorState;
    642a:	89 81       	ldd	r24, Y+1	; 0x01
}
    642c:	27 96       	adiw	r28, 0x07	; 7
    642e:	0f b6       	in	r0, 0x3f	; 63
    6430:	f8 94       	cli
    6432:	de bf       	out	0x3e, r29	; 62
    6434:	0f be       	out	0x3f, r0	; 63
    6436:	cd bf       	out	0x3d, r28	; 61
    6438:	cf 91       	pop	r28
    643a:	df 91       	pop	r29
    643c:	08 95       	ret

0000643e <DIO_U8GetPortValue>:
u8 DIO_U8GetPortValue(u8 Copy_u8Port, u8* Copy_Pu8Value)
{
    643e:	df 93       	push	r29
    6440:	cf 93       	push	r28
    6442:	00 d0       	rcall	.+0      	; 0x6444 <DIO_U8GetPortValue+0x6>
    6444:	00 d0       	rcall	.+0      	; 0x6446 <DIO_U8GetPortValue+0x8>
    6446:	00 d0       	rcall	.+0      	; 0x6448 <DIO_U8GetPortValue+0xa>
    6448:	cd b7       	in	r28, 0x3d	; 61
    644a:	de b7       	in	r29, 0x3e	; 62
    644c:	8a 83       	std	Y+2, r24	; 0x02
    644e:	7c 83       	std	Y+4, r23	; 0x04
    6450:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErrorState=0;
    6452:	19 82       	std	Y+1, r1	; 0x01
	if(Copy_Pu8Value!=NULL)
    6454:	8b 81       	ldd	r24, Y+3	; 0x03
    6456:	9c 81       	ldd	r25, Y+4	; 0x04
    6458:	00 97       	sbiw	r24, 0x00	; 0
    645a:	09 f4       	brne	.+2      	; 0x645e <DIO_U8GetPortValue+0x20>
    645c:	3e c0       	rjmp	.+124    	; 0x64da <DIO_U8GetPortValue+0x9c>
	{
		switch(Copy_u8Port)
    645e:	8a 81       	ldd	r24, Y+2	; 0x02
    6460:	28 2f       	mov	r18, r24
    6462:	30 e0       	ldi	r19, 0x00	; 0
    6464:	3e 83       	std	Y+6, r19	; 0x06
    6466:	2d 83       	std	Y+5, r18	; 0x05
    6468:	8d 81       	ldd	r24, Y+5	; 0x05
    646a:	9e 81       	ldd	r25, Y+6	; 0x06
    646c:	81 30       	cpi	r24, 0x01	; 1
    646e:	91 05       	cpc	r25, r1
    6470:	e1 f0       	breq	.+56     	; 0x64aa <DIO_U8GetPortValue+0x6c>
    6472:	2d 81       	ldd	r18, Y+5	; 0x05
    6474:	3e 81       	ldd	r19, Y+6	; 0x06
    6476:	22 30       	cpi	r18, 0x02	; 2
    6478:	31 05       	cpc	r19, r1
    647a:	2c f4       	brge	.+10     	; 0x6486 <DIO_U8GetPortValue+0x48>
    647c:	8d 81       	ldd	r24, Y+5	; 0x05
    647e:	9e 81       	ldd	r25, Y+6	; 0x06
    6480:	00 97       	sbiw	r24, 0x00	; 0
    6482:	61 f0       	breq	.+24     	; 0x649c <DIO_U8GetPortValue+0x5e>
    6484:	27 c0       	rjmp	.+78     	; 0x64d4 <DIO_U8GetPortValue+0x96>
    6486:	2d 81       	ldd	r18, Y+5	; 0x05
    6488:	3e 81       	ldd	r19, Y+6	; 0x06
    648a:	22 30       	cpi	r18, 0x02	; 2
    648c:	31 05       	cpc	r19, r1
    648e:	a1 f0       	breq	.+40     	; 0x64b8 <DIO_U8GetPortValue+0x7a>
    6490:	8d 81       	ldd	r24, Y+5	; 0x05
    6492:	9e 81       	ldd	r25, Y+6	; 0x06
    6494:	83 30       	cpi	r24, 0x03	; 3
    6496:	91 05       	cpc	r25, r1
    6498:	b1 f0       	breq	.+44     	; 0x64c6 <DIO_U8GetPortValue+0x88>
    649a:	1c c0       	rjmp	.+56     	; 0x64d4 <DIO_U8GetPortValue+0x96>
		{
		case DIO_u8PORTA: *Copy_Pu8Value=PINA; break;
    649c:	e9 e3       	ldi	r30, 0x39	; 57
    649e:	f0 e0       	ldi	r31, 0x00	; 0
    64a0:	80 81       	ld	r24, Z
    64a2:	eb 81       	ldd	r30, Y+3	; 0x03
    64a4:	fc 81       	ldd	r31, Y+4	; 0x04
    64a6:	80 83       	st	Z, r24
    64a8:	1a c0       	rjmp	.+52     	; 0x64de <DIO_U8GetPortValue+0xa0>
		case DIO_u8PORTB: *Copy_Pu8Value=PINB; break;
    64aa:	e6 e3       	ldi	r30, 0x36	; 54
    64ac:	f0 e0       	ldi	r31, 0x00	; 0
    64ae:	80 81       	ld	r24, Z
    64b0:	eb 81       	ldd	r30, Y+3	; 0x03
    64b2:	fc 81       	ldd	r31, Y+4	; 0x04
    64b4:	80 83       	st	Z, r24
    64b6:	13 c0       	rjmp	.+38     	; 0x64de <DIO_U8GetPortValue+0xa0>
		case DIO_u8PORTC: *Copy_Pu8Value=PINC; break;
    64b8:	e3 e3       	ldi	r30, 0x33	; 51
    64ba:	f0 e0       	ldi	r31, 0x00	; 0
    64bc:	80 81       	ld	r24, Z
    64be:	eb 81       	ldd	r30, Y+3	; 0x03
    64c0:	fc 81       	ldd	r31, Y+4	; 0x04
    64c2:	80 83       	st	Z, r24
    64c4:	0c c0       	rjmp	.+24     	; 0x64de <DIO_U8GetPortValue+0xa0>
		case DIO_u8PORTD: *Copy_Pu8Value=PIND; break;
    64c6:	e0 e3       	ldi	r30, 0x30	; 48
    64c8:	f0 e0       	ldi	r31, 0x00	; 0
    64ca:	80 81       	ld	r24, Z
    64cc:	eb 81       	ldd	r30, Y+3	; 0x03
    64ce:	fc 81       	ldd	r31, Y+4	; 0x04
    64d0:	80 83       	st	Z, r24
    64d2:	05 c0       	rjmp	.+10     	; 0x64de <DIO_U8GetPortValue+0xa0>
		default: Local_u8ErrorState=1; break;
    64d4:	81 e0       	ldi	r24, 0x01	; 1
    64d6:	89 83       	std	Y+1, r24	; 0x01
    64d8:	02 c0       	rjmp	.+4      	; 0x64de <DIO_U8GetPortValue+0xa0>
		}
	}
	else
	{
		Local_u8ErrorState=1;
    64da:	81 e0       	ldi	r24, 0x01	; 1
    64dc:	89 83       	std	Y+1, r24	; 0x01
	}
	return Local_u8ErrorState;
    64de:	89 81       	ldd	r24, Y+1	; 0x01
}
    64e0:	26 96       	adiw	r28, 0x06	; 6
    64e2:	0f b6       	in	r0, 0x3f	; 63
    64e4:	f8 94       	cli
    64e6:	de bf       	out	0x3e, r29	; 62
    64e8:	0f be       	out	0x3f, r0	; 63
    64ea:	cd bf       	out	0x3d, r28	; 61
    64ec:	cf 91       	pop	r28
    64ee:	df 91       	pop	r29
    64f0:	08 95       	ret

000064f2 <main>:
xSemaphoreHandle DoorSem;

xSemaphoreHandle TempSem;

int main(void)
{
    64f2:	af 92       	push	r10
    64f4:	bf 92       	push	r11
    64f6:	cf 92       	push	r12
    64f8:	df 92       	push	r13
    64fa:	ef 92       	push	r14
    64fc:	ff 92       	push	r15
    64fe:	0f 93       	push	r16
    6500:	df 93       	push	r29
    6502:	cf 93       	push	r28
    6504:	cd b7       	in	r28, 0x3d	; 61
    6506:	de b7       	in	r29, 0x3e	; 62
	PORT_voidInit();
    6508:	0e 94 7d 2f 	call	0x5efa	; 0x5efa <PORT_voidInit>
	ADC_voidInit();
    650c:	0e 94 ed 2c 	call	0x59da	; 0x59da <ADC_voidInit>
	CLCD_void_Init();
    6510:	0e 94 5a 29 	call	0x52b4	; 0x52b4 <CLCD_void_Init>
	GIE_voidEnable();
    6514:	0e 94 61 2f 	call	0x5ec2	; 0x5ec2 <GIE_voidEnable>
	TIMER2_voidInit();
    6518:	0e 94 ae 2c 	call	0x595c	; 0x595c <TIMER2_voidInit>
	CLCD_voidSendString("welcome");
    651c:	85 e6       	ldi	r24, 0x65	; 101
    651e:	90 e0       	ldi	r25, 0x00	; 0
    6520:	0e 94 24 2b 	call	0x5648	; 0x5648 <CLCD_voidSendString>
	LCDSem=xSemaphoreCreateCounting(1,1);
    6524:	81 e0       	ldi	r24, 0x01	; 1
    6526:	61 e0       	ldi	r22, 0x01	; 1
    6528:	0e 94 9d 0d 	call	0x1b3a	; 0x1b3a <xQueueCreateCountingSemaphore>
    652c:	90 93 6f 07 	sts	0x076F, r25
    6530:	80 93 6e 07 	sts	0x076E, r24
	DoorSem=xSemaphoreCreateCounting(1,0);
    6534:	81 e0       	ldi	r24, 0x01	; 1
    6536:	60 e0       	ldi	r22, 0x00	; 0
    6538:	0e 94 9d 0d 	call	0x1b3a	; 0x1b3a <xQueueCreateCountingSemaphore>
    653c:	90 93 75 07 	sts	0x0775, r25
    6540:	80 93 74 07 	sts	0x0774, r24
	TempSem=xSemaphoreCreateCounting(1,0);
    6544:	81 e0       	ldi	r24, 0x01	; 1
    6546:	60 e0       	ldi	r22, 0x00	; 0
    6548:	0e 94 9d 0d 	call	0x1b3a	; 0x1b3a <xQueueCreateCountingSemaphore>
    654c:	90 93 73 07 	sts	0x0773, r25
    6550:	80 93 72 07 	sts	0x0772, r24
	xTaskCreate(KeypadTask,NULL,250,NULL,5,NULL);
    6554:	81 ef       	ldi	r24, 0xF1	; 241
    6556:	92 e3       	ldi	r25, 0x32	; 50
    6558:	60 e0       	ldi	r22, 0x00	; 0
    655a:	70 e0       	ldi	r23, 0x00	; 0
    655c:	4a ef       	ldi	r20, 0xFA	; 250
    655e:	50 e0       	ldi	r21, 0x00	; 0
    6560:	20 e0       	ldi	r18, 0x00	; 0
    6562:	30 e0       	ldi	r19, 0x00	; 0
    6564:	05 e0       	ldi	r16, 0x05	; 5
    6566:	ee 24       	eor	r14, r14
    6568:	ff 24       	eor	r15, r15
    656a:	cc 24       	eor	r12, r12
    656c:	dd 24       	eor	r13, r13
    656e:	aa 24       	eor	r10, r10
    6570:	bb 24       	eor	r11, r11
    6572:	0e 94 94 11 	call	0x2328	; 0x2328 <xTaskGenericCreate>
	xTaskCreate(DoorTask,NULL,150,NULL,3,NULL);
    6576:	81 ee       	ldi	r24, 0xE1	; 225
    6578:	93 e3       	ldi	r25, 0x33	; 51
    657a:	60 e0       	ldi	r22, 0x00	; 0
    657c:	70 e0       	ldi	r23, 0x00	; 0
    657e:	46 e9       	ldi	r20, 0x96	; 150
    6580:	50 e0       	ldi	r21, 0x00	; 0
    6582:	20 e0       	ldi	r18, 0x00	; 0
    6584:	30 e0       	ldi	r19, 0x00	; 0
    6586:	03 e0       	ldi	r16, 0x03	; 3
    6588:	ee 24       	eor	r14, r14
    658a:	ff 24       	eor	r15, r15
    658c:	cc 24       	eor	r12, r12
    658e:	dd 24       	eor	r13, r13
    6590:	aa 24       	eor	r10, r10
    6592:	bb 24       	eor	r11, r11
    6594:	0e 94 94 11 	call	0x2328	; 0x2328 <xTaskGenericCreate>
	xTaskCreate(FanTask,NULL,150,NULL,2,NULL);
    6598:	89 e6       	ldi	r24, 0x69	; 105
    659a:	94 e3       	ldi	r25, 0x34	; 52
    659c:	60 e0       	ldi	r22, 0x00	; 0
    659e:	70 e0       	ldi	r23, 0x00	; 0
    65a0:	46 e9       	ldi	r20, 0x96	; 150
    65a2:	50 e0       	ldi	r21, 0x00	; 0
    65a4:	20 e0       	ldi	r18, 0x00	; 0
    65a6:	30 e0       	ldi	r19, 0x00	; 0
    65a8:	02 e0       	ldi	r16, 0x02	; 2
    65aa:	ee 24       	eor	r14, r14
    65ac:	ff 24       	eor	r15, r15
    65ae:	cc 24       	eor	r12, r12
    65b0:	dd 24       	eor	r13, r13
    65b2:	aa 24       	eor	r10, r10
    65b4:	bb 24       	eor	r11, r11
    65b6:	0e 94 94 11 	call	0x2328	; 0x2328 <xTaskGenericCreate>
	xTaskCreate(TempTask,NULL,150,NULL,4,NULL);
    65ba:	88 e7       	ldi	r24, 0x78	; 120
    65bc:	93 e3       	ldi	r25, 0x33	; 51
    65be:	60 e0       	ldi	r22, 0x00	; 0
    65c0:	70 e0       	ldi	r23, 0x00	; 0
    65c2:	46 e9       	ldi	r20, 0x96	; 150
    65c4:	50 e0       	ldi	r21, 0x00	; 0
    65c6:	20 e0       	ldi	r18, 0x00	; 0
    65c8:	30 e0       	ldi	r19, 0x00	; 0
    65ca:	04 e0       	ldi	r16, 0x04	; 4
    65cc:	ee 24       	eor	r14, r14
    65ce:	ff 24       	eor	r15, r15
    65d0:	cc 24       	eor	r12, r12
    65d2:	dd 24       	eor	r13, r13
    65d4:	aa 24       	eor	r10, r10
    65d6:	bb 24       	eor	r11, r11
    65d8:	0e 94 94 11 	call	0x2328	; 0x2328 <xTaskGenericCreate>
	//xTaskCreate(BuzzerTask,NULL,150,NULL,5,NULL);
	vTaskStartScheduler();
    65dc:	0e 94 8d 13 	call	0x271a	; 0x271a <vTaskStartScheduler>
    65e0:	ff cf       	rjmp	.-2      	; 0x65e0 <main+0xee>

000065e2 <KeypadTask>:
	while(1);
}

void KeypadTask(void *pv)
{
    65e2:	df 93       	push	r29
    65e4:	cf 93       	push	r28
    65e6:	cd b7       	in	r28, 0x3d	; 61
    65e8:	de b7       	in	r29, 0x3e	; 62
    65ea:	28 97       	sbiw	r28, 0x08	; 8
    65ec:	0f b6       	in	r0, 0x3f	; 63
    65ee:	f8 94       	cli
    65f0:	de bf       	out	0x3e, r29	; 62
    65f2:	0f be       	out	0x3f, r0	; 63
    65f4:	cd bf       	out	0x3d, r28	; 61
    65f6:	98 87       	std	Y+8, r25	; 0x08
    65f8:	8f 83       	std	Y+7, r24	; 0x07
	u32 Pass=0;
    65fa:	1b 82       	std	Y+3, r1	; 0x03
    65fc:	1c 82       	std	Y+4, r1	; 0x04
    65fe:	1d 82       	std	Y+5, r1	; 0x05
    6600:	1e 82       	std	Y+6, r1	; 0x06
	u8 Entered=0;
    6602:	1a 82       	std	Y+2, r1	; 0x02
	u8 SemState=0;
    6604:	19 82       	std	Y+1, r1	; 0x01
	while(1)
	{
		static u8 Local_Trails=0;
		static u8 Local_Counter=0;
		Entered=KPD_u8GetPressedKey();
    6606:	0e 94 e2 28 	call	0x51c4	; 0x51c4 <KPD_u8GetPressedKey>
    660a:	8a 83       	std	Y+2, r24	; 0x02
		SemState=xSemaphoreTake(LCDSem,35);
    660c:	80 91 6e 07 	lds	r24, 0x076E
    6610:	90 91 6f 07 	lds	r25, 0x076F
    6614:	60 e0       	ldi	r22, 0x00	; 0
    6616:	70 e0       	ldi	r23, 0x00	; 0
    6618:	43 e2       	ldi	r20, 0x23	; 35
    661a:	50 e0       	ldi	r21, 0x00	; 0
    661c:	20 e0       	ldi	r18, 0x00	; 0
    661e:	0e 94 a7 0e 	call	0x1d4e	; 0x1d4e <xQueueGenericReceive>
    6622:	89 83       	std	Y+1, r24	; 0x01
		if(Entered!=0xff)
    6624:	8a 81       	ldd	r24, Y+2	; 0x02
    6626:	8f 3f       	cpi	r24, 0xFF	; 255
    6628:	29 f1       	breq	.+74     	; 0x6674 <KeypadTask+0x92>
		{
			EnteredPass[Local_Counter]=Entered;
    662a:	80 91 6a 07 	lds	r24, 0x076A
    662e:	88 2f       	mov	r24, r24
    6630:	90 e0       	ldi	r25, 0x00	; 0
    6632:	fc 01       	movw	r30, r24
    6634:	ed 59       	subi	r30, 0x9D	; 157
    6636:	f8 4f       	sbci	r31, 0xF8	; 248
    6638:	8a 81       	ldd	r24, Y+2	; 0x02
    663a:	80 83       	st	Z, r24
			if(SemState == pdTRUE)
    663c:	89 81       	ldd	r24, Y+1	; 0x01
    663e:	81 30       	cpi	r24, 0x01	; 1
    6640:	a1 f4       	brne	.+40     	; 0x666a <KeypadTask+0x88>
			{
				CLCD_voidGoToXY(0,Local_Counter);
    6642:	90 91 6a 07 	lds	r25, 0x076A
    6646:	80 e0       	ldi	r24, 0x00	; 0
    6648:	69 2f       	mov	r22, r25
    664a:	0e 94 5a 2b 	call	0x56b4	; 0x56b4 <CLCD_voidGoToXY>
				CLCD_voidSendData('*');
    664e:	8a e2       	ldi	r24, 0x2A	; 42
    6650:	0e 94 86 2a 	call	0x550c	; 0x550c <CLCD_voidSendData>
				xSemaphoreGive(LCDSem);
    6654:	80 91 6e 07 	lds	r24, 0x076E
    6658:	90 91 6f 07 	lds	r25, 0x076F
    665c:	60 e0       	ldi	r22, 0x00	; 0
    665e:	70 e0       	ldi	r23, 0x00	; 0
    6660:	40 e0       	ldi	r20, 0x00	; 0
    6662:	50 e0       	ldi	r21, 0x00	; 0
    6664:	20 e0       	ldi	r18, 0x00	; 0
    6666:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <xQueueGenericSend>
			}
			Local_Counter++;
    666a:	80 91 6a 07 	lds	r24, 0x076A
    666e:	8f 5f       	subi	r24, 0xFF	; 255
    6670:	80 93 6a 07 	sts	0x076A, r24
		}
		if(Local_Counter==4)
    6674:	80 91 6a 07 	lds	r24, 0x076A
    6678:	84 30       	cpi	r24, 0x04	; 4
    667a:	a9 f5       	brne	.+106    	; 0x66e6 <KeypadTask+0x104>
		{
			Local_Counter=0;
    667c:	10 92 6a 07 	sts	0x076A, r1
			Pass=ConvertPass(EnteredPass,4);
    6680:	83 e6       	ldi	r24, 0x63	; 99
    6682:	97 e0       	ldi	r25, 0x07	; 7
    6684:	64 e0       	ldi	r22, 0x04	; 4
    6686:	0e 94 04 35 	call	0x6a08	; 0x6a08 <ConvertPass>
    668a:	dc 01       	movw	r26, r24
    668c:	cb 01       	movw	r24, r22
    668e:	8b 83       	std	Y+3, r24	; 0x03
    6690:	9c 83       	std	Y+4, r25	; 0x04
    6692:	ad 83       	std	Y+5, r26	; 0x05
    6694:	be 83       	std	Y+6, r27	; 0x06
			if(Pass == CorrectPass)
    6696:	80 91 d5 00 	lds	r24, 0x00D5
    669a:	90 91 d6 00 	lds	r25, 0x00D6
    669e:	9c 01       	movw	r18, r24
    66a0:	40 e0       	ldi	r20, 0x00	; 0
    66a2:	50 e0       	ldi	r21, 0x00	; 0
    66a4:	8b 81       	ldd	r24, Y+3	; 0x03
    66a6:	9c 81       	ldd	r25, Y+4	; 0x04
    66a8:	ad 81       	ldd	r26, Y+5	; 0x05
    66aa:	be 81       	ldd	r27, Y+6	; 0x06
    66ac:	28 17       	cp	r18, r24
    66ae:	39 07       	cpc	r19, r25
    66b0:	4a 07       	cpc	r20, r26
    66b2:	5b 07       	cpc	r21, r27
    66b4:	61 f4       	brne	.+24     	; 0x66ce <KeypadTask+0xec>
			{
				xSemaphoreGive(DoorSem);
    66b6:	80 91 74 07 	lds	r24, 0x0774
    66ba:	90 91 75 07 	lds	r25, 0x0775
    66be:	60 e0       	ldi	r22, 0x00	; 0
    66c0:	70 e0       	ldi	r23, 0x00	; 0
    66c2:	40 e0       	ldi	r20, 0x00	; 0
    66c4:	50 e0       	ldi	r21, 0x00	; 0
    66c6:	20 e0       	ldi	r18, 0x00	; 0
    66c8:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <xQueueGenericSend>
    66cc:	05 c0       	rjmp	.+10     	; 0x66d8 <KeypadTask+0xf6>
			}
			else
			{
				Local_Trails++;
    66ce:	80 91 6b 07 	lds	r24, 0x076B
    66d2:	8f 5f       	subi	r24, 0xFF	; 255
    66d4:	80 93 6b 07 	sts	0x076B, r24
			}
			if(Local_Trails==3)
    66d8:	80 91 6b 07 	lds	r24, 0x076B
    66dc:	83 30       	cpi	r24, 0x03	; 3
    66de:	19 f4       	brne	.+6      	; 0x66e6 <KeypadTask+0x104>
			{
				BuzzerFlag=1;
    66e0:	81 e0       	ldi	r24, 0x01	; 1
    66e2:	80 93 68 07 	sts	0x0768, r24
			}
		}
		vTaskDelay(100);
    66e6:	84 e6       	ldi	r24, 0x64	; 100
    66e8:	90 e0       	ldi	r25, 0x00	; 0
    66ea:	0e 94 58 13 	call	0x26b0	; 0x26b0 <vTaskDelay>
    66ee:	8b cf       	rjmp	.-234    	; 0x6606 <KeypadTask+0x24>

000066f0 <TempTask>:
	}
}

void TempTask(void *pv)
{
    66f0:	df 93       	push	r29
    66f2:	cf 93       	push	r28
    66f4:	00 d0       	rcall	.+0      	; 0x66f6 <TempTask+0x6>
    66f6:	0f 92       	push	r0
    66f8:	cd b7       	in	r28, 0x3d	; 61
    66fa:	de b7       	in	r29, 0x3e	; 62
    66fc:	9b 83       	std	Y+3, r25	; 0x03
    66fe:	8a 83       	std	Y+2, r24	; 0x02
	u8 SemState=0;
    6700:	19 82       	std	Y+1, r1	; 0x01
	while(1)
	{
		SemState=xSemaphoreTake(TempSem,25);
    6702:	80 91 72 07 	lds	r24, 0x0772
    6706:	90 91 73 07 	lds	r25, 0x0773
    670a:	60 e0       	ldi	r22, 0x00	; 0
    670c:	70 e0       	ldi	r23, 0x00	; 0
    670e:	49 e1       	ldi	r20, 0x19	; 25
    6710:	50 e0       	ldi	r21, 0x00	; 0
    6712:	20 e0       	ldi	r18, 0x00	; 0
    6714:	0e 94 a7 0e 	call	0x1d4e	; 0x1d4e <xQueueGenericReceive>
    6718:	89 83       	std	Y+1, r24	; 0x01
		if(SemState == pdPASS)
    671a:	89 81       	ldd	r24, Y+1	; 0x01
    671c:	81 30       	cpi	r24, 0x01	; 1
    671e:	a9 f4       	brne	.+42     	; 0x674a <TempTask+0x5a>
		{
			ADC_u8StartConversionAsynch(5,&Temp,TempNotificaton);
    6720:	20 e7       	ldi	r18, 0x70	; 112
    6722:	37 e0       	ldi	r19, 0x07	; 7
    6724:	42 ef       	ldi	r20, 0xF2	; 242
    6726:	54 e3       	ldi	r21, 0x34	; 52
    6728:	85 e0       	ldi	r24, 0x05	; 5
    672a:	b9 01       	movw	r22, r18
    672c:	0e 94 a8 2d 	call	0x5b50	; 0x5b50 <ADC_u8StartConversionAsynch>
			Temp*=2;
    6730:	80 91 70 07 	lds	r24, 0x0770
    6734:	90 91 71 07 	lds	r25, 0x0771
    6738:	88 0f       	add	r24, r24
    673a:	99 1f       	adc	r25, r25
    673c:	90 93 71 07 	sts	0x0771, r25
    6740:	80 93 70 07 	sts	0x0770, r24
			TempFlag=1;
    6744:	81 e0       	ldi	r24, 0x01	; 1
    6746:	80 93 69 07 	sts	0x0769, r24
		}
		vTaskDelay(250);
    674a:	8a ef       	ldi	r24, 0xFA	; 250
    674c:	90 e0       	ldi	r25, 0x00	; 0
    674e:	0e 94 58 13 	call	0x26b0	; 0x26b0 <vTaskDelay>
    6752:	d7 cf       	rjmp	.-82     	; 0x6702 <TempTask+0x12>

00006754 <BuzzerTask>:
	}
}

void BuzzerTask(void *pv)
{
    6754:	df 93       	push	r29
    6756:	cf 93       	push	r28
    6758:	00 d0       	rcall	.+0      	; 0x675a <BuzzerTask+0x6>
    675a:	cd b7       	in	r28, 0x3d	; 61
    675c:	de b7       	in	r29, 0x3e	; 62
    675e:	9a 83       	std	Y+2, r25	; 0x02
    6760:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		static u8 Counter=0;
		if(BuzzerFlag==1)
    6762:	80 91 68 07 	lds	r24, 0x0768
    6766:	81 30       	cpi	r24, 0x01	; 1
    6768:	a9 f4       	brne	.+42     	; 0x6794 <BuzzerTask+0x40>
		{
			CLCD_voidGoToXY(0,0);
    676a:	80 e0       	ldi	r24, 0x00	; 0
    676c:	60 e0       	ldi	r22, 0x00	; 0
    676e:	0e 94 5a 2b 	call	0x56b4	; 0x56b4 <CLCD_voidGoToXY>
			CLCD_voidSendString("Warning");
    6772:	8d e6       	ldi	r24, 0x6D	; 109
    6774:	90 e0       	ldi	r25, 0x00	; 0
    6776:	0e 94 24 2b 	call	0x5648	; 0x5648 <CLCD_voidSendString>
			DIO_u8TogglePinValue(DIO_u8PORTA,DIO_u8PIN4);
    677a:	80 e0       	ldi	r24, 0x00	; 0
    677c:	64 e0       	ldi	r22, 0x04	; 4
    677e:	0e 94 fc 30 	call	0x61f8	; 0x61f8 <DIO_u8TogglePinValue>
			DIO_u8TogglePinValue(DIO_u8PORTA,DIO_u8PIN5);
    6782:	80 e0       	ldi	r24, 0x00	; 0
    6784:	65 e0       	ldi	r22, 0x05	; 5
    6786:	0e 94 fc 30 	call	0x61f8	; 0x61f8 <DIO_u8TogglePinValue>
			Counter++;
    678a:	80 91 6c 07 	lds	r24, 0x076C
    678e:	8f 5f       	subi	r24, 0xFF	; 255
    6790:	80 93 6c 07 	sts	0x076C, r24
		}
		if(Counter==10)
    6794:	80 91 6c 07 	lds	r24, 0x076C
    6798:	8a 30       	cpi	r24, 0x0A	; 10
    679a:	71 f4       	brne	.+28     	; 0x67b8 <BuzzerTask+0x64>
		{
			BuzzerFlag=0;
    679c:	10 92 68 07 	sts	0x0768, r1
			Counter=0;
    67a0:	10 92 6c 07 	sts	0x076C, r1
			DIO_u8SetPinValue(DIO_u8PORTA,DIO_u8PIN5,DIO_u8Pin_HIGH);
    67a4:	80 e0       	ldi	r24, 0x00	; 0
    67a6:	65 e0       	ldi	r22, 0x05	; 5
    67a8:	41 e0       	ldi	r20, 0x01	; 1
    67aa:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
			DIO_u8SetPinValue(DIO_u8PORTA,DIO_u8PIN5,DIO_u8Pin_LOW);
    67ae:	80 e0       	ldi	r24, 0x00	; 0
    67b0:	65 e0       	ldi	r22, 0x05	; 5
    67b2:	40 e0       	ldi	r20, 0x00	; 0
    67b4:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <DIO_u8SetPinValue>
		}
		vTaskDelay(500);
    67b8:	84 ef       	ldi	r24, 0xF4	; 244
    67ba:	91 e0       	ldi	r25, 0x01	; 1
    67bc:	0e 94 58 13 	call	0x26b0	; 0x26b0 <vTaskDelay>
    67c0:	d0 cf       	rjmp	.-96     	; 0x6762 <BuzzerTask+0xe>

000067c2 <DoorTask>:
	}
}

void DoorTask(void *pv)
{
    67c2:	df 93       	push	r29
    67c4:	cf 93       	push	r28
    67c6:	cd b7       	in	r28, 0x3d	; 61
    67c8:	de b7       	in	r29, 0x3e	; 62
    67ca:	2b 97       	sbiw	r28, 0x0b	; 11
    67cc:	0f b6       	in	r0, 0x3f	; 63
    67ce:	f8 94       	cli
    67d0:	de bf       	out	0x3e, r29	; 62
    67d2:	0f be       	out	0x3f, r0	; 63
    67d4:	cd bf       	out	0x3d, r28	; 61
    67d6:	9e 83       	std	Y+6, r25	; 0x06
    67d8:	8d 83       	std	Y+5, r24	; 0x05
	DC_MOTOR Motor={DIO_u8PORTA,DIO_u8PIN1,DIO_u8PIN2};
    67da:	ce 01       	movw	r24, r28
    67dc:	02 96       	adiw	r24, 0x02	; 2
    67de:	98 87       	std	Y+8, r25	; 0x08
    67e0:	8f 83       	std	Y+7, r24	; 0x07
    67e2:	e8 ed       	ldi	r30, 0xD8	; 216
    67e4:	f0 e0       	ldi	r31, 0x00	; 0
    67e6:	fa 87       	std	Y+10, r31	; 0x0a
    67e8:	e9 87       	std	Y+9, r30	; 0x09
    67ea:	f3 e0       	ldi	r31, 0x03	; 3
    67ec:	fb 87       	std	Y+11, r31	; 0x0b
    67ee:	e9 85       	ldd	r30, Y+9	; 0x09
    67f0:	fa 85       	ldd	r31, Y+10	; 0x0a
    67f2:	00 80       	ld	r0, Z
    67f4:	89 85       	ldd	r24, Y+9	; 0x09
    67f6:	9a 85       	ldd	r25, Y+10	; 0x0a
    67f8:	01 96       	adiw	r24, 0x01	; 1
    67fa:	9a 87       	std	Y+10, r25	; 0x0a
    67fc:	89 87       	std	Y+9, r24	; 0x09
    67fe:	ef 81       	ldd	r30, Y+7	; 0x07
    6800:	f8 85       	ldd	r31, Y+8	; 0x08
    6802:	00 82       	st	Z, r0
    6804:	8f 81       	ldd	r24, Y+7	; 0x07
    6806:	98 85       	ldd	r25, Y+8	; 0x08
    6808:	01 96       	adiw	r24, 0x01	; 1
    680a:	98 87       	std	Y+8, r25	; 0x08
    680c:	8f 83       	std	Y+7, r24	; 0x07
    680e:	9b 85       	ldd	r25, Y+11	; 0x0b
    6810:	91 50       	subi	r25, 0x01	; 1
    6812:	9b 87       	std	Y+11, r25	; 0x0b
    6814:	eb 85       	ldd	r30, Y+11	; 0x0b
    6816:	ee 23       	and	r30, r30
    6818:	51 f7       	brne	.-44     	; 0x67ee <DoorTask+0x2c>
	u8 SemState=0;
    681a:	19 82       	std	Y+1, r1	; 0x01
	while(1)
	{
		SemState= xSemaphoreTake(DoorSem,35);
    681c:	80 91 74 07 	lds	r24, 0x0774
    6820:	90 91 75 07 	lds	r25, 0x0775
    6824:	60 e0       	ldi	r22, 0x00	; 0
    6826:	70 e0       	ldi	r23, 0x00	; 0
    6828:	43 e2       	ldi	r20, 0x23	; 35
    682a:	50 e0       	ldi	r21, 0x00	; 0
    682c:	20 e0       	ldi	r18, 0x00	; 0
    682e:	0e 94 a7 0e 	call	0x1d4e	; 0x1d4e <xQueueGenericReceive>
    6832:	89 83       	std	Y+1, r24	; 0x01
		static u8 Index=0;
		static u8 Close=4;
		if((SemState == pdPASS) && ( Index==0 ))
    6834:	89 81       	ldd	r24, Y+1	; 0x01
    6836:	81 30       	cpi	r24, 0x01	; 1
    6838:	b9 f4       	brne	.+46     	; 0x6868 <DoorTask+0xa6>
    683a:	80 91 6d 07 	lds	r24, 0x076D
    683e:	88 23       	and	r24, r24
    6840:	99 f4       	brne	.+38     	; 0x6868 <DoorTask+0xa6>
		{
			Index++;
    6842:	80 91 6d 07 	lds	r24, 0x076D
    6846:	8f 5f       	subi	r24, 0xFF	; 255
    6848:	80 93 6d 07 	sts	0x076D, r24
			DC_u8Rotate(&Motor,CW);
    684c:	ce 01       	movw	r24, r28
    684e:	02 96       	adiw	r24, 0x02	; 2
    6850:	61 e0       	ldi	r22, 0x01	; 1
    6852:	0e 94 7f 18 	call	0x30fe	; 0x30fe <DC_u8Rotate>
			CLCD_voidGoToXY(0,0);
    6856:	80 e0       	ldi	r24, 0x00	; 0
    6858:	60 e0       	ldi	r22, 0x00	; 0
    685a:	0e 94 5a 2b 	call	0x56b4	; 0x56b4 <CLCD_voidGoToXY>
			CLCD_voidSendString("Door Opening");
    685e:	85 e7       	ldi	r24, 0x75	; 117
    6860:	90 e0       	ldi	r25, 0x00	; 0
    6862:	0e 94 24 2b 	call	0x5648	; 0x5648 <CLCD_voidSendString>
    6866:	0d c0       	rjmp	.+26     	; 0x6882 <DoorTask+0xc0>
		}
		else if((Index>0)&&(Index<8))
    6868:	80 91 6d 07 	lds	r24, 0x076D
    686c:	88 23       	and	r24, r24
    686e:	49 f0       	breq	.+18     	; 0x6882 <DoorTask+0xc0>
    6870:	80 91 6d 07 	lds	r24, 0x076D
    6874:	88 30       	cpi	r24, 0x08	; 8
    6876:	28 f4       	brcc	.+10     	; 0x6882 <DoorTask+0xc0>
		{
			Index++;
    6878:	80 91 6d 07 	lds	r24, 0x076D
    687c:	8f 5f       	subi	r24, 0xFF	; 255
    687e:	80 93 6d 07 	sts	0x076D, r24
		}
		if(Index==8)
    6882:	80 91 6d 07 	lds	r24, 0x076D
    6886:	88 30       	cpi	r24, 0x08	; 8
    6888:	f9 f4       	brne	.+62     	; 0x68c8 <DoorTask+0x106>
		{
			CorrectFlag=0;
    688a:	10 92 67 07 	sts	0x0767, r1
			Close--;
    688e:	80 91 d7 00 	lds	r24, 0x00D7
    6892:	81 50       	subi	r24, 0x01	; 1
    6894:	80 93 d7 00 	sts	0x00D7, r24
			DC_u8Rotate(&Motor,CCW);
    6898:	ce 01       	movw	r24, r28
    689a:	02 96       	adiw	r24, 0x02	; 2
    689c:	62 e0       	ldi	r22, 0x02	; 2
    689e:	0e 94 7f 18 	call	0x30fe	; 0x30fe <DC_u8Rotate>
			if(Close==0)
    68a2:	80 91 d7 00 	lds	r24, 0x00D7
    68a6:	88 23       	and	r24, r24
    68a8:	79 f4       	brne	.+30     	; 0x68c8 <DoorTask+0x106>
			{
				DC_u8Stop(&Motor);
    68aa:	ce 01       	movw	r24, r28
    68ac:	02 96       	adiw	r24, 0x02	; 2
    68ae:	0e 94 d7 18 	call	0x31ae	; 0x31ae <DC_u8Stop>
				Index=0;
    68b2:	10 92 6d 07 	sts	0x076D, r1
				CLCD_voidCLR();
    68b6:	0e 94 78 2b 	call	0x56f0	; 0x56f0 <CLCD_voidCLR>
				CLCD_voidSendString("Door Closed");
    68ba:	82 e8       	ldi	r24, 0x82	; 130
    68bc:	90 e0       	ldi	r25, 0x00	; 0
    68be:	0e 94 24 2b 	call	0x5648	; 0x5648 <CLCD_voidSendString>
				Close=4;
    68c2:	84 e0       	ldi	r24, 0x04	; 4
    68c4:	80 93 d7 00 	sts	0x00D7, r24
			}
		}
		vTaskDelay(1000);
    68c8:	88 ee       	ldi	r24, 0xE8	; 232
    68ca:	93 e0       	ldi	r25, 0x03	; 3
    68cc:	0e 94 58 13 	call	0x26b0	; 0x26b0 <vTaskDelay>
    68d0:	a5 cf       	rjmp	.-182    	; 0x681c <DoorTask+0x5a>

000068d2 <FanTask>:
	}
}

void FanTask(void *pv)
{
    68d2:	df 93       	push	r29
    68d4:	cf 93       	push	r28
    68d6:	00 d0       	rcall	.+0      	; 0x68d8 <FanTask+0x6>
    68d8:	0f 92       	push	r0
    68da:	cd b7       	in	r28, 0x3d	; 61
    68dc:	de b7       	in	r29, 0x3e	; 62
    68de:	9b 83       	std	Y+3, r25	; 0x03
    68e0:	8a 83       	std	Y+2, r24	; 0x02
	u8 SemState=0;
    68e2:	19 82       	std	Y+1, r1	; 0x01
	while(1)
	{
		if(TempFlag==1)
    68e4:	80 91 69 07 	lds	r24, 0x0769
    68e8:	81 30       	cpi	r24, 0x01	; 1
    68ea:	09 f0       	breq	.+2      	; 0x68ee <FanTask+0x1c>
    68ec:	76 c0       	rjmp	.+236    	; 0x69da <FanTask+0x108>
		{
			SemState=xSemaphoreTake(LCDSem,35);
    68ee:	80 91 6e 07 	lds	r24, 0x076E
    68f2:	90 91 6f 07 	lds	r25, 0x076F
    68f6:	60 e0       	ldi	r22, 0x00	; 0
    68f8:	70 e0       	ldi	r23, 0x00	; 0
    68fa:	43 e2       	ldi	r20, 0x23	; 35
    68fc:	50 e0       	ldi	r21, 0x00	; 0
    68fe:	20 e0       	ldi	r18, 0x00	; 0
    6900:	0e 94 a7 0e 	call	0x1d4e	; 0x1d4e <xQueueGenericReceive>
    6904:	89 83       	std	Y+1, r24	; 0x01
			if(SemState==pdTRUE)
    6906:	89 81       	ldd	r24, Y+1	; 0x01
    6908:	81 30       	cpi	r24, 0x01	; 1
    690a:	09 f0       	breq	.+2      	; 0x690e <FanTask+0x3c>
    690c:	66 c0       	rjmp	.+204    	; 0x69da <FanTask+0x108>
			{
				CLCD_voidGoToXY(1,0);
    690e:	81 e0       	ldi	r24, 0x01	; 1
    6910:	60 e0       	ldi	r22, 0x00	; 0
    6912:	0e 94 5a 2b 	call	0x56b4	; 0x56b4 <CLCD_voidGoToXY>
				CLCD_voidSendString("Temp=");
    6916:	8e e8       	ldi	r24, 0x8E	; 142
    6918:	90 e0       	ldi	r25, 0x00	; 0
    691a:	0e 94 24 2b 	call	0x5648	; 0x5648 <CLCD_voidSendString>
				CLCD_void_SendNumber(Temp);
    691e:	80 91 70 07 	lds	r24, 0x0770
    6922:	90 91 71 07 	lds	r25, 0x0771
    6926:	cc 01       	movw	r24, r24
    6928:	a0 e0       	ldi	r26, 0x00	; 0
    692a:	b0 e0       	ldi	r27, 0x00	; 0
    692c:	bc 01       	movw	r22, r24
    692e:	cd 01       	movw	r24, r26
    6930:	0e 94 c3 2b 	call	0x5786	; 0x5786 <CLCD_void_SendNumber>
				CLCD_voidGoToXY(1,8);
    6934:	81 e0       	ldi	r24, 0x01	; 1
    6936:	68 e0       	ldi	r22, 0x08	; 8
    6938:	0e 94 5a 2b 	call	0x56b4	; 0x56b4 <CLCD_voidGoToXY>
				if((Temp>27) && (Temp<=30))
    693c:	80 91 70 07 	lds	r24, 0x0770
    6940:	90 91 71 07 	lds	r25, 0x0771
    6944:	8c 31       	cpi	r24, 0x1C	; 28
    6946:	91 05       	cpc	r25, r1
    6948:	78 f0       	brcs	.+30     	; 0x6968 <FanTask+0x96>
    694a:	80 91 70 07 	lds	r24, 0x0770
    694e:	90 91 71 07 	lds	r25, 0x0771
    6952:	8f 31       	cpi	r24, 0x1F	; 31
    6954:	91 05       	cpc	r25, r1
    6956:	40 f4       	brcc	.+16     	; 0x6968 <FanTask+0x96>
				{
					TIMER2_voidSetCompMatchValue(85);
    6958:	85 e5       	ldi	r24, 0x55	; 85
    695a:	0e 94 df 2c 	call	0x59be	; 0x59be <TIMER2_voidSetCompMatchValue>
					CLCD_voidSendString(" Fan 33%");
    695e:	84 e9       	ldi	r24, 0x94	; 148
    6960:	90 e0       	ldi	r25, 0x00	; 0
    6962:	0e 94 24 2b 	call	0x5648	; 0x5648 <CLCD_voidSendString>
    6966:	2c c0       	rjmp	.+88     	; 0x69c0 <FanTask+0xee>
				}
				else if((Temp>30) && (Temp<=35))
    6968:	80 91 70 07 	lds	r24, 0x0770
    696c:	90 91 71 07 	lds	r25, 0x0771
    6970:	8f 31       	cpi	r24, 0x1F	; 31
    6972:	91 05       	cpc	r25, r1
    6974:	78 f0       	brcs	.+30     	; 0x6994 <FanTask+0xc2>
    6976:	80 91 70 07 	lds	r24, 0x0770
    697a:	90 91 71 07 	lds	r25, 0x0771
    697e:	84 32       	cpi	r24, 0x24	; 36
    6980:	91 05       	cpc	r25, r1
    6982:	40 f4       	brcc	.+16     	; 0x6994 <FanTask+0xc2>
				{
					TIMER2_voidSetCompMatchValue(170);
    6984:	8a ea       	ldi	r24, 0xAA	; 170
    6986:	0e 94 df 2c 	call	0x59be	; 0x59be <TIMER2_voidSetCompMatchValue>
					CLCD_voidSendString(" Fan 67%");
    698a:	8d e9       	ldi	r24, 0x9D	; 157
    698c:	90 e0       	ldi	r25, 0x00	; 0
    698e:	0e 94 24 2b 	call	0x5648	; 0x5648 <CLCD_voidSendString>
    6992:	16 c0       	rjmp	.+44     	; 0x69c0 <FanTask+0xee>
				}
				else if(Temp>35)
    6994:	80 91 70 07 	lds	r24, 0x0770
    6998:	90 91 71 07 	lds	r25, 0x0771
    699c:	84 32       	cpi	r24, 0x24	; 36
    699e:	91 05       	cpc	r25, r1
    69a0:	40 f0       	brcs	.+16     	; 0x69b2 <FanTask+0xe0>
				{
					TIMER2_voidSetCompMatchValue(255);
    69a2:	8f ef       	ldi	r24, 0xFF	; 255
    69a4:	0e 94 df 2c 	call	0x59be	; 0x59be <TIMER2_voidSetCompMatchValue>
					CLCD_voidSendString("Fan 100%");
    69a8:	86 ea       	ldi	r24, 0xA6	; 166
    69aa:	90 e0       	ldi	r25, 0x00	; 0
    69ac:	0e 94 24 2b 	call	0x5648	; 0x5648 <CLCD_voidSendString>
    69b0:	07 c0       	rjmp	.+14     	; 0x69c0 <FanTask+0xee>
				}
				else
				{
					TIMER2_voidSetCompMatchValue(0);
    69b2:	80 e0       	ldi	r24, 0x00	; 0
    69b4:	0e 94 df 2c 	call	0x59be	; 0x59be <TIMER2_voidSetCompMatchValue>
					CLCD_voidSendString(" Fan OFF");
    69b8:	8f ea       	ldi	r24, 0xAF	; 175
    69ba:	90 e0       	ldi	r25, 0x00	; 0
    69bc:	0e 94 24 2b 	call	0x5648	; 0x5648 <CLCD_voidSendString>
				}
				TempFlag=0;
    69c0:	10 92 69 07 	sts	0x0769, r1
				xSemaphoreGive(LCDSem);
    69c4:	80 91 6e 07 	lds	r24, 0x076E
    69c8:	90 91 6f 07 	lds	r25, 0x076F
    69cc:	60 e0       	ldi	r22, 0x00	; 0
    69ce:	70 e0       	ldi	r23, 0x00	; 0
    69d0:	40 e0       	ldi	r20, 0x00	; 0
    69d2:	50 e0       	ldi	r21, 0x00	; 0
    69d4:	20 e0       	ldi	r18, 0x00	; 0
    69d6:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <xQueueGenericSend>
			}
		}
		vTaskDelay(1000);
    69da:	88 ee       	ldi	r24, 0xE8	; 232
    69dc:	93 e0       	ldi	r25, 0x03	; 3
    69de:	0e 94 58 13 	call	0x26b0	; 0x26b0 <vTaskDelay>
    69e2:	80 cf       	rjmp	.-256    	; 0x68e4 <FanTask+0x12>

000069e4 <TempNotificaton>:
	}
}

void TempNotificaton(void)
{
    69e4:	df 93       	push	r29
    69e6:	cf 93       	push	r28
    69e8:	cd b7       	in	r28, 0x3d	; 61
    69ea:	de b7       	in	r29, 0x3e	; 62
	xSemaphoreGive(TempSem);
    69ec:	80 91 72 07 	lds	r24, 0x0772
    69f0:	90 91 73 07 	lds	r25, 0x0773
    69f4:	60 e0       	ldi	r22, 0x00	; 0
    69f6:	70 e0       	ldi	r23, 0x00	; 0
    69f8:	40 e0       	ldi	r20, 0x00	; 0
    69fa:	50 e0       	ldi	r21, 0x00	; 0
    69fc:	20 e0       	ldi	r18, 0x00	; 0
    69fe:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <xQueueGenericSend>
}
    6a02:	cf 91       	pop	r28
    6a04:	df 91       	pop	r29
    6a06:	08 95       	ret

00006a08 <ConvertPass>:

u32 ConvertPass(u8* PassArr,u8 PassLen)
{
    6a08:	df 93       	push	r29
    6a0a:	cf 93       	push	r28
    6a0c:	cd b7       	in	r28, 0x3d	; 61
    6a0e:	de b7       	in	r29, 0x3e	; 62
    6a10:	2d 97       	sbiw	r28, 0x0d	; 13
    6a12:	0f b6       	in	r0, 0x3f	; 63
    6a14:	f8 94       	cli
    6a16:	de bf       	out	0x3e, r29	; 62
    6a18:	0f be       	out	0x3f, r0	; 63
    6a1a:	cd bf       	out	0x3d, r28	; 61
    6a1c:	9c 87       	std	Y+12, r25	; 0x0c
    6a1e:	8b 87       	std	Y+11, r24	; 0x0b
    6a20:	6d 87       	std	Y+13, r22	; 0x0d
	u32 Pass=0;
    6a22:	1f 82       	std	Y+7, r1	; 0x07
    6a24:	18 86       	std	Y+8, r1	; 0x08
    6a26:	19 86       	std	Y+9, r1	; 0x09
    6a28:	1a 86       	std	Y+10, r1	; 0x0a
	u32 Temp=0;
    6a2a:	1b 82       	std	Y+3, r1	; 0x03
    6a2c:	1c 82       	std	Y+4, r1	; 0x04
    6a2e:	1d 82       	std	Y+5, r1	; 0x05
    6a30:	1e 82       	std	Y+6, r1	; 0x06
	for(u8 Index=0;Index<PassLen;Index++)
    6a32:	1a 82       	std	Y+2, r1	; 0x02
    6a34:	4f c0       	rjmp	.+158    	; 0x6ad4 <ConvertPass+0xcc>
	{
		Temp=PassArr[Index]-'0';
    6a36:	8a 81       	ldd	r24, Y+2	; 0x02
    6a38:	28 2f       	mov	r18, r24
    6a3a:	30 e0       	ldi	r19, 0x00	; 0
    6a3c:	8b 85       	ldd	r24, Y+11	; 0x0b
    6a3e:	9c 85       	ldd	r25, Y+12	; 0x0c
    6a40:	fc 01       	movw	r30, r24
    6a42:	e2 0f       	add	r30, r18
    6a44:	f3 1f       	adc	r31, r19
    6a46:	80 81       	ld	r24, Z
    6a48:	88 2f       	mov	r24, r24
    6a4a:	90 e0       	ldi	r25, 0x00	; 0
    6a4c:	c0 97       	sbiw	r24, 0x30	; 48
    6a4e:	aa 27       	eor	r26, r26
    6a50:	97 fd       	sbrc	r25, 7
    6a52:	a0 95       	com	r26
    6a54:	ba 2f       	mov	r27, r26
    6a56:	8b 83       	std	Y+3, r24	; 0x03
    6a58:	9c 83       	std	Y+4, r25	; 0x04
    6a5a:	ad 83       	std	Y+5, r26	; 0x05
    6a5c:	be 83       	std	Y+6, r27	; 0x06
		for(u8 Power=0;Power<(PassLen-Index-1);Power++)
    6a5e:	19 82       	std	Y+1, r1	; 0x01
    6a60:	15 c0       	rjmp	.+42     	; 0x6a8c <ConvertPass+0x84>
		{
			Temp*=10;
    6a62:	8b 81       	ldd	r24, Y+3	; 0x03
    6a64:	9c 81       	ldd	r25, Y+4	; 0x04
    6a66:	ad 81       	ldd	r26, Y+5	; 0x05
    6a68:	be 81       	ldd	r27, Y+6	; 0x06
    6a6a:	2a e0       	ldi	r18, 0x0A	; 10
    6a6c:	30 e0       	ldi	r19, 0x00	; 0
    6a6e:	40 e0       	ldi	r20, 0x00	; 0
    6a70:	50 e0       	ldi	r21, 0x00	; 0
    6a72:	bc 01       	movw	r22, r24
    6a74:	cd 01       	movw	r24, r26
    6a76:	0e 94 7e 35 	call	0x6afc	; 0x6afc <__mulsi3>
    6a7a:	dc 01       	movw	r26, r24
    6a7c:	cb 01       	movw	r24, r22
    6a7e:	8b 83       	std	Y+3, r24	; 0x03
    6a80:	9c 83       	std	Y+4, r25	; 0x04
    6a82:	ad 83       	std	Y+5, r26	; 0x05
    6a84:	be 83       	std	Y+6, r27	; 0x06
	u32 Pass=0;
	u32 Temp=0;
	for(u8 Index=0;Index<PassLen;Index++)
	{
		Temp=PassArr[Index]-'0';
		for(u8 Power=0;Power<(PassLen-Index-1);Power++)
    6a86:	89 81       	ldd	r24, Y+1	; 0x01
    6a88:	8f 5f       	subi	r24, 0xFF	; 255
    6a8a:	89 83       	std	Y+1, r24	; 0x01
    6a8c:	89 81       	ldd	r24, Y+1	; 0x01
    6a8e:	48 2f       	mov	r20, r24
    6a90:	50 e0       	ldi	r21, 0x00	; 0
    6a92:	8d 85       	ldd	r24, Y+13	; 0x0d
    6a94:	28 2f       	mov	r18, r24
    6a96:	30 e0       	ldi	r19, 0x00	; 0
    6a98:	8a 81       	ldd	r24, Y+2	; 0x02
    6a9a:	88 2f       	mov	r24, r24
    6a9c:	90 e0       	ldi	r25, 0x00	; 0
    6a9e:	b9 01       	movw	r22, r18
    6aa0:	68 1b       	sub	r22, r24
    6aa2:	79 0b       	sbc	r23, r25
    6aa4:	cb 01       	movw	r24, r22
    6aa6:	01 97       	sbiw	r24, 0x01	; 1
    6aa8:	48 17       	cp	r20, r24
    6aaa:	59 07       	cpc	r21, r25
    6aac:	d4 f2       	brlt	.-76     	; 0x6a62 <ConvertPass+0x5a>
		{
			Temp*=10;
		}
		Pass += Temp;
    6aae:	2f 81       	ldd	r18, Y+7	; 0x07
    6ab0:	38 85       	ldd	r19, Y+8	; 0x08
    6ab2:	49 85       	ldd	r20, Y+9	; 0x09
    6ab4:	5a 85       	ldd	r21, Y+10	; 0x0a
    6ab6:	8b 81       	ldd	r24, Y+3	; 0x03
    6ab8:	9c 81       	ldd	r25, Y+4	; 0x04
    6aba:	ad 81       	ldd	r26, Y+5	; 0x05
    6abc:	be 81       	ldd	r27, Y+6	; 0x06
    6abe:	82 0f       	add	r24, r18
    6ac0:	93 1f       	adc	r25, r19
    6ac2:	a4 1f       	adc	r26, r20
    6ac4:	b5 1f       	adc	r27, r21
    6ac6:	8f 83       	std	Y+7, r24	; 0x07
    6ac8:	98 87       	std	Y+8, r25	; 0x08
    6aca:	a9 87       	std	Y+9, r26	; 0x09
    6acc:	ba 87       	std	Y+10, r27	; 0x0a

u32 ConvertPass(u8* PassArr,u8 PassLen)
{
	u32 Pass=0;
	u32 Temp=0;
	for(u8 Index=0;Index<PassLen;Index++)
    6ace:	8a 81       	ldd	r24, Y+2	; 0x02
    6ad0:	8f 5f       	subi	r24, 0xFF	; 255
    6ad2:	8a 83       	std	Y+2, r24	; 0x02
    6ad4:	9a 81       	ldd	r25, Y+2	; 0x02
    6ad6:	8d 85       	ldd	r24, Y+13	; 0x0d
    6ad8:	98 17       	cp	r25, r24
    6ada:	08 f4       	brcc	.+2      	; 0x6ade <ConvertPass+0xd6>
    6adc:	ac cf       	rjmp	.-168    	; 0x6a36 <ConvertPass+0x2e>
		{
			Temp*=10;
		}
		Pass += Temp;
	}
	return Pass;
    6ade:	8f 81       	ldd	r24, Y+7	; 0x07
    6ae0:	98 85       	ldd	r25, Y+8	; 0x08
    6ae2:	a9 85       	ldd	r26, Y+9	; 0x09
    6ae4:	ba 85       	ldd	r27, Y+10	; 0x0a
}
    6ae6:	bc 01       	movw	r22, r24
    6ae8:	cd 01       	movw	r24, r26
    6aea:	2d 96       	adiw	r28, 0x0d	; 13
    6aec:	0f b6       	in	r0, 0x3f	; 63
    6aee:	f8 94       	cli
    6af0:	de bf       	out	0x3e, r29	; 62
    6af2:	0f be       	out	0x3f, r0	; 63
    6af4:	cd bf       	out	0x3d, r28	; 61
    6af6:	cf 91       	pop	r28
    6af8:	df 91       	pop	r29
    6afa:	08 95       	ret

00006afc <__mulsi3>:
    6afc:	62 9f       	mul	r22, r18
    6afe:	d0 01       	movw	r26, r0
    6b00:	73 9f       	mul	r23, r19
    6b02:	f0 01       	movw	r30, r0
    6b04:	82 9f       	mul	r24, r18
    6b06:	e0 0d       	add	r30, r0
    6b08:	f1 1d       	adc	r31, r1
    6b0a:	64 9f       	mul	r22, r20
    6b0c:	e0 0d       	add	r30, r0
    6b0e:	f1 1d       	adc	r31, r1
    6b10:	92 9f       	mul	r25, r18
    6b12:	f0 0d       	add	r31, r0
    6b14:	83 9f       	mul	r24, r19
    6b16:	f0 0d       	add	r31, r0
    6b18:	74 9f       	mul	r23, r20
    6b1a:	f0 0d       	add	r31, r0
    6b1c:	65 9f       	mul	r22, r21
    6b1e:	f0 0d       	add	r31, r0
    6b20:	99 27       	eor	r25, r25
    6b22:	72 9f       	mul	r23, r18
    6b24:	b0 0d       	add	r27, r0
    6b26:	e1 1d       	adc	r30, r1
    6b28:	f9 1f       	adc	r31, r25
    6b2a:	63 9f       	mul	r22, r19
    6b2c:	b0 0d       	add	r27, r0
    6b2e:	e1 1d       	adc	r30, r1
    6b30:	f9 1f       	adc	r31, r25
    6b32:	bd 01       	movw	r22, r26
    6b34:	cf 01       	movw	r24, r30
    6b36:	11 24       	eor	r1, r1
    6b38:	08 95       	ret

00006b3a <__udivmodhi4>:
    6b3a:	aa 1b       	sub	r26, r26
    6b3c:	bb 1b       	sub	r27, r27
    6b3e:	51 e1       	ldi	r21, 0x11	; 17
    6b40:	07 c0       	rjmp	.+14     	; 0x6b50 <__udivmodhi4_ep>

00006b42 <__udivmodhi4_loop>:
    6b42:	aa 1f       	adc	r26, r26
    6b44:	bb 1f       	adc	r27, r27
    6b46:	a6 17       	cp	r26, r22
    6b48:	b7 07       	cpc	r27, r23
    6b4a:	10 f0       	brcs	.+4      	; 0x6b50 <__udivmodhi4_ep>
    6b4c:	a6 1b       	sub	r26, r22
    6b4e:	b7 0b       	sbc	r27, r23

00006b50 <__udivmodhi4_ep>:
    6b50:	88 1f       	adc	r24, r24
    6b52:	99 1f       	adc	r25, r25
    6b54:	5a 95       	dec	r21
    6b56:	a9 f7       	brne	.-22     	; 0x6b42 <__udivmodhi4_loop>
    6b58:	80 95       	com	r24
    6b5a:	90 95       	com	r25
    6b5c:	bc 01       	movw	r22, r24
    6b5e:	cd 01       	movw	r24, r26
    6b60:	08 95       	ret

00006b62 <__udivmodsi4>:
    6b62:	a1 e2       	ldi	r26, 0x21	; 33
    6b64:	1a 2e       	mov	r1, r26
    6b66:	aa 1b       	sub	r26, r26
    6b68:	bb 1b       	sub	r27, r27
    6b6a:	fd 01       	movw	r30, r26
    6b6c:	0d c0       	rjmp	.+26     	; 0x6b88 <__udivmodsi4_ep>

00006b6e <__udivmodsi4_loop>:
    6b6e:	aa 1f       	adc	r26, r26
    6b70:	bb 1f       	adc	r27, r27
    6b72:	ee 1f       	adc	r30, r30
    6b74:	ff 1f       	adc	r31, r31
    6b76:	a2 17       	cp	r26, r18
    6b78:	b3 07       	cpc	r27, r19
    6b7a:	e4 07       	cpc	r30, r20
    6b7c:	f5 07       	cpc	r31, r21
    6b7e:	20 f0       	brcs	.+8      	; 0x6b88 <__udivmodsi4_ep>
    6b80:	a2 1b       	sub	r26, r18
    6b82:	b3 0b       	sbc	r27, r19
    6b84:	e4 0b       	sbc	r30, r20
    6b86:	f5 0b       	sbc	r31, r21

00006b88 <__udivmodsi4_ep>:
    6b88:	66 1f       	adc	r22, r22
    6b8a:	77 1f       	adc	r23, r23
    6b8c:	88 1f       	adc	r24, r24
    6b8e:	99 1f       	adc	r25, r25
    6b90:	1a 94       	dec	r1
    6b92:	69 f7       	brne	.-38     	; 0x6b6e <__udivmodsi4_loop>
    6b94:	60 95       	com	r22
    6b96:	70 95       	com	r23
    6b98:	80 95       	com	r24
    6b9a:	90 95       	com	r25
    6b9c:	9b 01       	movw	r18, r22
    6b9e:	ac 01       	movw	r20, r24
    6ba0:	bd 01       	movw	r22, r26
    6ba2:	cf 01       	movw	r24, r30
    6ba4:	08 95       	ret

00006ba6 <__divmodsi4>:
    6ba6:	97 fb       	bst	r25, 7
    6ba8:	09 2e       	mov	r0, r25
    6baa:	05 26       	eor	r0, r21
    6bac:	0e d0       	rcall	.+28     	; 0x6bca <__divmodsi4_neg1>
    6bae:	57 fd       	sbrc	r21, 7
    6bb0:	04 d0       	rcall	.+8      	; 0x6bba <__divmodsi4_neg2>
    6bb2:	d7 df       	rcall	.-82     	; 0x6b62 <__udivmodsi4>
    6bb4:	0a d0       	rcall	.+20     	; 0x6bca <__divmodsi4_neg1>
    6bb6:	00 1c       	adc	r0, r0
    6bb8:	38 f4       	brcc	.+14     	; 0x6bc8 <__divmodsi4_exit>

00006bba <__divmodsi4_neg2>:
    6bba:	50 95       	com	r21
    6bbc:	40 95       	com	r20
    6bbe:	30 95       	com	r19
    6bc0:	21 95       	neg	r18
    6bc2:	3f 4f       	sbci	r19, 0xFF	; 255
    6bc4:	4f 4f       	sbci	r20, 0xFF	; 255
    6bc6:	5f 4f       	sbci	r21, 0xFF	; 255

00006bc8 <__divmodsi4_exit>:
    6bc8:	08 95       	ret

00006bca <__divmodsi4_neg1>:
    6bca:	f6 f7       	brtc	.-4      	; 0x6bc8 <__divmodsi4_exit>
    6bcc:	90 95       	com	r25
    6bce:	80 95       	com	r24
    6bd0:	70 95       	com	r23
    6bd2:	61 95       	neg	r22
    6bd4:	7f 4f       	sbci	r23, 0xFF	; 255
    6bd6:	8f 4f       	sbci	r24, 0xFF	; 255
    6bd8:	9f 4f       	sbci	r25, 0xFF	; 255
    6bda:	08 95       	ret

00006bdc <__prologue_saves__>:
    6bdc:	2f 92       	push	r2
    6bde:	3f 92       	push	r3
    6be0:	4f 92       	push	r4
    6be2:	5f 92       	push	r5
    6be4:	6f 92       	push	r6
    6be6:	7f 92       	push	r7
    6be8:	8f 92       	push	r8
    6bea:	9f 92       	push	r9
    6bec:	af 92       	push	r10
    6bee:	bf 92       	push	r11
    6bf0:	cf 92       	push	r12
    6bf2:	df 92       	push	r13
    6bf4:	ef 92       	push	r14
    6bf6:	ff 92       	push	r15
    6bf8:	0f 93       	push	r16
    6bfa:	1f 93       	push	r17
    6bfc:	cf 93       	push	r28
    6bfe:	df 93       	push	r29
    6c00:	cd b7       	in	r28, 0x3d	; 61
    6c02:	de b7       	in	r29, 0x3e	; 62
    6c04:	ca 1b       	sub	r28, r26
    6c06:	db 0b       	sbc	r29, r27
    6c08:	0f b6       	in	r0, 0x3f	; 63
    6c0a:	f8 94       	cli
    6c0c:	de bf       	out	0x3e, r29	; 62
    6c0e:	0f be       	out	0x3f, r0	; 63
    6c10:	cd bf       	out	0x3d, r28	; 61
    6c12:	09 94       	ijmp

00006c14 <__epilogue_restores__>:
    6c14:	2a 88       	ldd	r2, Y+18	; 0x12
    6c16:	39 88       	ldd	r3, Y+17	; 0x11
    6c18:	48 88       	ldd	r4, Y+16	; 0x10
    6c1a:	5f 84       	ldd	r5, Y+15	; 0x0f
    6c1c:	6e 84       	ldd	r6, Y+14	; 0x0e
    6c1e:	7d 84       	ldd	r7, Y+13	; 0x0d
    6c20:	8c 84       	ldd	r8, Y+12	; 0x0c
    6c22:	9b 84       	ldd	r9, Y+11	; 0x0b
    6c24:	aa 84       	ldd	r10, Y+10	; 0x0a
    6c26:	b9 84       	ldd	r11, Y+9	; 0x09
    6c28:	c8 84       	ldd	r12, Y+8	; 0x08
    6c2a:	df 80       	ldd	r13, Y+7	; 0x07
    6c2c:	ee 80       	ldd	r14, Y+6	; 0x06
    6c2e:	fd 80       	ldd	r15, Y+5	; 0x05
    6c30:	0c 81       	ldd	r16, Y+4	; 0x04
    6c32:	1b 81       	ldd	r17, Y+3	; 0x03
    6c34:	aa 81       	ldd	r26, Y+2	; 0x02
    6c36:	b9 81       	ldd	r27, Y+1	; 0x01
    6c38:	ce 0f       	add	r28, r30
    6c3a:	d1 1d       	adc	r29, r1
    6c3c:	0f b6       	in	r0, 0x3f	; 63
    6c3e:	f8 94       	cli
    6c40:	de bf       	out	0x3e, r29	; 62
    6c42:	0f be       	out	0x3f, r0	; 63
    6c44:	cd bf       	out	0x3d, r28	; 61
    6c46:	ed 01       	movw	r28, r26
    6c48:	08 95       	ret

00006c4a <memcpy>:
    6c4a:	fb 01       	movw	r30, r22
    6c4c:	dc 01       	movw	r26, r24
    6c4e:	02 c0       	rjmp	.+4      	; 0x6c54 <memcpy+0xa>
    6c50:	01 90       	ld	r0, Z+
    6c52:	0d 92       	st	X+, r0
    6c54:	41 50       	subi	r20, 0x01	; 1
    6c56:	50 40       	sbci	r21, 0x00	; 0
    6c58:	d8 f7       	brcc	.-10     	; 0x6c50 <memcpy+0x6>
    6c5a:	08 95       	ret

00006c5c <memset>:
    6c5c:	dc 01       	movw	r26, r24
    6c5e:	01 c0       	rjmp	.+2      	; 0x6c62 <memset+0x6>
    6c60:	6d 93       	st	X+, r22
    6c62:	41 50       	subi	r20, 0x01	; 1
    6c64:	50 40       	sbci	r21, 0x00	; 0
    6c66:	e0 f7       	brcc	.-8      	; 0x6c60 <memset+0x4>
    6c68:	08 95       	ret

00006c6a <strncpy>:
    6c6a:	fb 01       	movw	r30, r22
    6c6c:	dc 01       	movw	r26, r24
    6c6e:	41 50       	subi	r20, 0x01	; 1
    6c70:	50 40       	sbci	r21, 0x00	; 0
    6c72:	48 f0       	brcs	.+18     	; 0x6c86 <strncpy+0x1c>
    6c74:	01 90       	ld	r0, Z+
    6c76:	0d 92       	st	X+, r0
    6c78:	00 20       	and	r0, r0
    6c7a:	c9 f7       	brne	.-14     	; 0x6c6e <strncpy+0x4>
    6c7c:	01 c0       	rjmp	.+2      	; 0x6c80 <strncpy+0x16>
    6c7e:	1d 92       	st	X+, r1
    6c80:	41 50       	subi	r20, 0x01	; 1
    6c82:	50 40       	sbci	r21, 0x00	; 0
    6c84:	e0 f7       	brcc	.-8      	; 0x6c7e <strncpy+0x14>
    6c86:	08 95       	ret

00006c88 <_exit>:
    6c88:	f8 94       	cli

00006c8a <__stop_program>:
    6c8a:	ff cf       	rjmp	.-2      	; 0x6c8a <__stop_program>
